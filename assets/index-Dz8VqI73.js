function DL(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();var wN=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function bE(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function _L(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var Tv={exports:{}},kf={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var SN;function OL(){if(SN)return kf;SN=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,r,i){var a=null;if(i!==void 0&&(a=""+i),r.key!==void 0&&(a=""+r.key),"key"in r){i={};for(var o in r)o!=="key"&&(i[o]=r[o])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:a,ref:r!==void 0?r:null,props:i}}return kf.Fragment=e,kf.jsx=t,kf.jsxs=t,kf}var CN;function FL(){return CN||(CN=1,Tv.exports=OL()),Tv.exports}var Ga=FL(),Ev={exports:{}},vt={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $N;function zL(){if($N)return vt;$N=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),f=Symbol.iterator;function p(W){return W===null||typeof W!="object"?null:(W=f&&W[f]||W["@@iterator"],typeof W=="function"?W:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,b={};function v(W,ne,pe){this.props=W,this.context=ne,this.refs=b,this.updater=pe||g}v.prototype.isReactComponent={},v.prototype.setState=function(W,ne){if(typeof W!="object"&&typeof W!="function"&&W!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,W,ne,"setState")},v.prototype.forceUpdate=function(W){this.updater.enqueueForceUpdate(this,W,"forceUpdate")};function w(){}w.prototype=v.prototype;function $(W,ne,pe){this.props=W,this.context=ne,this.refs=b,this.updater=pe||g}var I=$.prototype=new w;I.constructor=$,x(I,v.prototype),I.isPureReactComponent=!0;var N=Array.isArray,E={H:null,A:null,T:null,S:null,V:null},D=Object.prototype.hasOwnProperty;function O(W,ne,pe,de,we,ke){return pe=ke.ref,{$$typeof:n,type:W,key:ne,ref:pe!==void 0?pe:null,props:ke}}function L(W,ne){return O(W.type,ne,void 0,void 0,void 0,W.props)}function z(W){return typeof W=="object"&&W!==null&&W.$$typeof===n}function P(W){var ne={"=":"=0",":":"=2"};return"$"+W.replace(/[=:]/g,function(pe){return ne[pe]})}var _=/\/+/g;function H(W,ne){return typeof W=="object"&&W!==null&&W.key!=null?P(""+W.key):ne.toString(36)}function q(){}function ee(W){switch(W.status){case"fulfilled":return W.value;case"rejected":throw W.reason;default:switch(typeof W.status=="string"?W.then(q,q):(W.status="pending",W.then(function(ne){W.status==="pending"&&(W.status="fulfilled",W.value=ne)},function(ne){W.status==="pending"&&(W.status="rejected",W.reason=ne)})),W.status){case"fulfilled":return W.value;case"rejected":throw W.reason}}throw W}function Y(W,ne,pe,de,we){var ke=typeof W;(ke==="undefined"||ke==="boolean")&&(W=null);var Ne=!1;if(W===null)Ne=!0;else switch(ke){case"bigint":case"string":case"number":Ne=!0;break;case"object":switch(W.$$typeof){case n:case e:Ne=!0;break;case d:return Ne=W._init,Y(Ne(W._payload),ne,pe,de,we)}}if(Ne)return we=we(W),Ne=de===""?"."+H(W,0):de,N(we)?(pe="",Ne!=null&&(pe=Ne.replace(_,"$&/")+"/"),Y(we,ne,pe,"",function(Ge){return Ge})):we!=null&&(z(we)&&(we=L(we,pe+(we.key==null||W&&W.key===we.key?"":(""+we.key).replace(_,"$&/")+"/")+Ne)),ne.push(we)),1;Ne=0;var Ue=de===""?".":de+":";if(N(W))for(var Le=0;Le<W.length;Le++)de=W[Le],ke=Ue+H(de,Le),Ne+=Y(de,ne,pe,ke,we);else if(Le=p(W),typeof Le=="function")for(W=Le.call(W),Le=0;!(de=W.next()).done;)de=de.value,ke=Ue+H(de,Le++),Ne+=Y(de,ne,pe,ke,we);else if(ke==="object"){if(typeof W.then=="function")return Y(ee(W),ne,pe,de,we);throw ne=String(W),Error("Objects are not valid as a React child (found: "+(ne==="[object Object]"?"object with keys {"+Object.keys(W).join(", ")+"}":ne)+"). If you meant to render a collection of children, use an array instead.")}return Ne}function G(W,ne,pe){if(W==null)return W;var de=[],we=0;return Y(W,de,"","",function(ke){return ne.call(pe,ke,we++)}),de}function te(W){if(W._status===-1){var ne=W._result;ne=ne(),ne.then(function(pe){(W._status===0||W._status===-1)&&(W._status=1,W._result=pe)},function(pe){(W._status===0||W._status===-1)&&(W._status=2,W._result=pe)}),W._status===-1&&(W._status=0,W._result=ne)}if(W._status===1)return W._result.default;throw W._result}var re=typeof reportError=="function"?reportError:function(W){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var ne=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof W=="object"&&W!==null&&typeof W.message=="string"?String(W.message):String(W),error:W});if(!window.dispatchEvent(ne))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",W);return}console.error(W)};function he(){}return vt.Children={map:G,forEach:function(W,ne,pe){G(W,function(){ne.apply(this,arguments)},pe)},count:function(W){var ne=0;return G(W,function(){ne++}),ne},toArray:function(W){return G(W,function(ne){return ne})||[]},only:function(W){if(!z(W))throw Error("React.Children.only expected to receive a single React element child.");return W}},vt.Component=v,vt.Fragment=t,vt.Profiler=r,vt.PureComponent=$,vt.StrictMode=s,vt.Suspense=l,vt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=E,vt.__COMPILER_RUNTIME={__proto__:null,c:function(W){return E.H.useMemoCache(W)}},vt.cache=function(W){return function(){return W.apply(null,arguments)}},vt.cloneElement=function(W,ne,pe){if(W==null)throw Error("The argument must be a React element, but you passed "+W+".");var de=x({},W.props),we=W.key,ke=void 0;if(ne!=null)for(Ne in ne.ref!==void 0&&(ke=void 0),ne.key!==void 0&&(we=""+ne.key),ne)!D.call(ne,Ne)||Ne==="key"||Ne==="__self"||Ne==="__source"||Ne==="ref"&&ne.ref===void 0||(de[Ne]=ne[Ne]);var Ne=arguments.length-2;if(Ne===1)de.children=pe;else if(1<Ne){for(var Ue=Array(Ne),Le=0;Le<Ne;Le++)Ue[Le]=arguments[Le+2];de.children=Ue}return O(W.type,we,void 0,void 0,ke,de)},vt.createContext=function(W){return W={$$typeof:a,_currentValue:W,_currentValue2:W,_threadCount:0,Provider:null,Consumer:null},W.Provider=W,W.Consumer={$$typeof:i,_context:W},W},vt.createElement=function(W,ne,pe){var de,we={},ke=null;if(ne!=null)for(de in ne.key!==void 0&&(ke=""+ne.key),ne)D.call(ne,de)&&de!=="key"&&de!=="__self"&&de!=="__source"&&(we[de]=ne[de]);var Ne=arguments.length-2;if(Ne===1)we.children=pe;else if(1<Ne){for(var Ue=Array(Ne),Le=0;Le<Ne;Le++)Ue[Le]=arguments[Le+2];we.children=Ue}if(W&&W.defaultProps)for(de in Ne=W.defaultProps,Ne)we[de]===void 0&&(we[de]=Ne[de]);return O(W,ke,void 0,void 0,null,we)},vt.createRef=function(){return{current:null}},vt.forwardRef=function(W){return{$$typeof:o,render:W}},vt.isValidElement=z,vt.lazy=function(W){return{$$typeof:d,_payload:{_status:-1,_result:W},_init:te}},vt.memo=function(W,ne){return{$$typeof:c,type:W,compare:ne===void 0?null:ne}},vt.startTransition=function(W){var ne=E.T,pe={};E.T=pe;try{var de=W(),we=E.S;we!==null&&we(pe,de),typeof de=="object"&&de!==null&&typeof de.then=="function"&&de.then(he,re)}catch(ke){re(ke)}finally{E.T=ne}},vt.unstable_useCacheRefresh=function(){return E.H.useCacheRefresh()},vt.use=function(W){return E.H.use(W)},vt.useActionState=function(W,ne,pe){return E.H.useActionState(W,ne,pe)},vt.useCallback=function(W,ne){return E.H.useCallback(W,ne)},vt.useContext=function(W){return E.H.useContext(W)},vt.useDebugValue=function(){},vt.useDeferredValue=function(W,ne){return E.H.useDeferredValue(W,ne)},vt.useEffect=function(W,ne,pe){var de=E.H;if(typeof pe=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return de.useEffect(W,ne)},vt.useId=function(){return E.H.useId()},vt.useImperativeHandle=function(W,ne,pe){return E.H.useImperativeHandle(W,ne,pe)},vt.useInsertionEffect=function(W,ne){return E.H.useInsertionEffect(W,ne)},vt.useLayoutEffect=function(W,ne){return E.H.useLayoutEffect(W,ne)},vt.useMemo=function(W,ne){return E.H.useMemo(W,ne)},vt.useOptimistic=function(W,ne){return E.H.useOptimistic(W,ne)},vt.useReducer=function(W,ne,pe){return E.H.useReducer(W,ne,pe)},vt.useRef=function(W){return E.H.useRef(W)},vt.useState=function(W){return E.H.useState(W)},vt.useSyncExternalStore=function(W,ne,pe){return E.H.useSyncExternalStore(W,ne,pe)},vt.useTransition=function(){return E.H.useTransition()},vt.version="19.1.0",vt}var kN;function ox(){return kN||(kN=1,Ev.exports=zL()),Ev.exports}var Gl=ox(),Rv={exports:{}},Nf={},Av={exports:{}},Dv={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var NN;function LL(){return NN||(NN=1,function(n){function e(G,te){var re=G.length;G.push(te);e:for(;0<re;){var he=re-1>>>1,W=G[he];if(0<r(W,te))G[he]=te,G[re]=W,re=he;else break e}}function t(G){return G.length===0?null:G[0]}function s(G){if(G.length===0)return null;var te=G[0],re=G.pop();if(re!==te){G[0]=re;e:for(var he=0,W=G.length,ne=W>>>1;he<ne;){var pe=2*(he+1)-1,de=G[pe],we=pe+1,ke=G[we];if(0>r(de,re))we<W&&0>r(ke,de)?(G[he]=ke,G[we]=re,he=we):(G[he]=de,G[pe]=re,he=pe);else if(we<W&&0>r(ke,re))G[he]=ke,G[we]=re,he=we;else break e}}return te}function r(G,te){var re=G.sortIndex-te.sortIndex;return re!==0?re:G.id-te.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var a=Date,o=a.now();n.unstable_now=function(){return a.now()-o}}var l=[],c=[],d=1,f=null,p=3,g=!1,x=!1,b=!1,v=!1,w=typeof setTimeout=="function"?setTimeout:null,$=typeof clearTimeout=="function"?clearTimeout:null,I=typeof setImmediate<"u"?setImmediate:null;function N(G){for(var te=t(c);te!==null;){if(te.callback===null)s(c);else if(te.startTime<=G)s(c),te.sortIndex=te.expirationTime,e(l,te);else break;te=t(c)}}function E(G){if(b=!1,N(G),!x)if(t(l)!==null)x=!0,D||(D=!0,H());else{var te=t(c);te!==null&&Y(E,te.startTime-G)}}var D=!1,O=-1,L=5,z=-1;function P(){return v?!0:!(n.unstable_now()-z<L)}function _(){if(v=!1,D){var G=n.unstable_now();z=G;var te=!0;try{e:{x=!1,b&&(b=!1,$(O),O=-1),g=!0;var re=p;try{t:{for(N(G),f=t(l);f!==null&&!(f.expirationTime>G&&P());){var he=f.callback;if(typeof he=="function"){f.callback=null,p=f.priorityLevel;var W=he(f.expirationTime<=G);if(G=n.unstable_now(),typeof W=="function"){f.callback=W,N(G),te=!0;break t}f===t(l)&&s(l),N(G)}else s(l);f=t(l)}if(f!==null)te=!0;else{var ne=t(c);ne!==null&&Y(E,ne.startTime-G),te=!1}}break e}finally{f=null,p=re,g=!1}te=void 0}}finally{te?H():D=!1}}}var H;if(typeof I=="function")H=function(){I(_)};else if(typeof MessageChannel<"u"){var q=new MessageChannel,ee=q.port2;q.port1.onmessage=_,H=function(){ee.postMessage(null)}}else H=function(){w(_,0)};function Y(G,te){O=w(function(){G(n.unstable_now())},te)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(G){G.callback=null},n.unstable_forceFrameRate=function(G){0>G||125<G?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):L=0<G?Math.floor(1e3/G):5},n.unstable_getCurrentPriorityLevel=function(){return p},n.unstable_next=function(G){switch(p){case 1:case 2:case 3:var te=3;break;default:te=p}var re=p;p=te;try{return G()}finally{p=re}},n.unstable_requestPaint=function(){v=!0},n.unstable_runWithPriority=function(G,te){switch(G){case 1:case 2:case 3:case 4:case 5:break;default:G=3}var re=p;p=G;try{return te()}finally{p=re}},n.unstable_scheduleCallback=function(G,te,re){var he=n.unstable_now();switch(typeof re=="object"&&re!==null?(re=re.delay,re=typeof re=="number"&&0<re?he+re:he):re=he,G){case 1:var W=-1;break;case 2:W=250;break;case 5:W=1073741823;break;case 4:W=1e4;break;default:W=5e3}return W=re+W,G={id:d++,callback:te,priorityLevel:G,startTime:re,expirationTime:W,sortIndex:-1},re>he?(G.sortIndex=re,e(c,G),t(l)===null&&G===t(c)&&(b?($(O),O=-1):b=!0,Y(E,re-he))):(G.sortIndex=W,e(l,G),x||g||(x=!0,D||(D=!0,H()))),G},n.unstable_shouldYield=P,n.unstable_wrapCallback=function(G){var te=p;return function(){var re=p;p=te;try{return G.apply(this,arguments)}finally{p=re}}}}(Dv)),Dv}var IN;function PL(){return IN||(IN=1,Av.exports=LL()),Av.exports}var _v={exports:{}},Ms={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var TN;function ML(){if(TN)return Ms;TN=1;var n=ox();function e(l){var c="https://react.dev/errors/"+l;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)c+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(l,c,d){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:f==null?null:""+f,children:l,containerInfo:c,implementation:d}}var a=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(l,c){if(l==="font")return"";if(typeof c=="string")return c==="use-credentials"?c:""}return Ms.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Ms.createPortal=function(l,c){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!c||c.nodeType!==1&&c.nodeType!==9&&c.nodeType!==11)throw Error(e(299));return i(l,c,null,d)},Ms.flushSync=function(l){var c=a.T,d=s.p;try{if(a.T=null,s.p=2,l)return l()}finally{a.T=c,s.p=d,s.d.f()}},Ms.preconnect=function(l,c){typeof l=="string"&&(c?(c=c.crossOrigin,c=typeof c=="string"?c==="use-credentials"?c:"":void 0):c=null,s.d.C(l,c))},Ms.prefetchDNS=function(l){typeof l=="string"&&s.d.D(l)},Ms.preinit=function(l,c){if(typeof l=="string"&&c&&typeof c.as=="string"){var d=c.as,f=o(d,c.crossOrigin),p=typeof c.integrity=="string"?c.integrity:void 0,g=typeof c.fetchPriority=="string"?c.fetchPriority:void 0;d==="style"?s.d.S(l,typeof c.precedence=="string"?c.precedence:void 0,{crossOrigin:f,integrity:p,fetchPriority:g}):d==="script"&&s.d.X(l,{crossOrigin:f,integrity:p,fetchPriority:g,nonce:typeof c.nonce=="string"?c.nonce:void 0})}},Ms.preinitModule=function(l,c){if(typeof l=="string")if(typeof c=="object"&&c!==null){if(c.as==null||c.as==="script"){var d=o(c.as,c.crossOrigin);s.d.M(l,{crossOrigin:d,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0})}}else c==null&&s.d.M(l)},Ms.preload=function(l,c){if(typeof l=="string"&&typeof c=="object"&&c!==null&&typeof c.as=="string"){var d=c.as,f=o(d,c.crossOrigin);s.d.L(l,d,{crossOrigin:f,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0,type:typeof c.type=="string"?c.type:void 0,fetchPriority:typeof c.fetchPriority=="string"?c.fetchPriority:void 0,referrerPolicy:typeof c.referrerPolicy=="string"?c.referrerPolicy:void 0,imageSrcSet:typeof c.imageSrcSet=="string"?c.imageSrcSet:void 0,imageSizes:typeof c.imageSizes=="string"?c.imageSizes:void 0,media:typeof c.media=="string"?c.media:void 0})}},Ms.preloadModule=function(l,c){if(typeof l=="string")if(c){var d=o(c.as,c.crossOrigin);s.d.m(l,{as:typeof c.as=="string"&&c.as!=="script"?c.as:void 0,crossOrigin:d,integrity:typeof c.integrity=="string"?c.integrity:void 0})}else s.d.m(l)},Ms.requestFormReset=function(l){s.d.r(l)},Ms.unstable_batchedUpdates=function(l,c){return l(c)},Ms.useFormState=function(l,c,d){return a.H.useFormState(l,c,d)},Ms.useFormStatus=function(){return a.H.useHostTransitionStatus()},Ms.version="19.1.0",Ms}var EN;function BL(){if(EN)return _v.exports;EN=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),_v.exports=ML(),_v.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var RN;function VL(){if(RN)return Nf;RN=1;var n=PL(),e=ox(),t=BL();function s(u){var h="https://react.dev/errors/"+u;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var m=2;m<arguments.length;m++)h+="&args[]="+encodeURIComponent(arguments[m])}return"Minified React error #"+u+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function i(u){var h=u,m=u;if(u.alternate)for(;h.return;)h=h.return;else{u=h;do h=u,(h.flags&4098)!==0&&(m=h.return),u=h.return;while(u)}return h.tag===3?m:null}function a(u){if(u.tag===13){var h=u.memoizedState;if(h===null&&(u=u.alternate,u!==null&&(h=u.memoizedState)),h!==null)return h.dehydrated}return null}function o(u){if(i(u)!==u)throw Error(s(188))}function l(u){var h=u.alternate;if(!h){if(h=i(u),h===null)throw Error(s(188));return h!==u?null:u}for(var m=u,y=h;;){var S=m.return;if(S===null)break;var k=S.alternate;if(k===null){if(y=S.return,y!==null){m=y;continue}break}if(S.child===k.child){for(k=S.child;k;){if(k===m)return o(S),u;if(k===y)return o(S),h;k=k.sibling}throw Error(s(188))}if(m.return!==y.return)m=S,y=k;else{for(var F=!1,V=S.child;V;){if(V===m){F=!0,m=S,y=k;break}if(V===y){F=!0,y=S,m=k;break}V=V.sibling}if(!F){for(V=k.child;V;){if(V===m){F=!0,m=k,y=S;break}if(V===y){F=!0,y=k,m=S;break}V=V.sibling}if(!F)throw Error(s(189))}}if(m.alternate!==y)throw Error(s(190))}if(m.tag!==3)throw Error(s(188));return m.stateNode.current===m?u:h}function c(u){var h=u.tag;if(h===5||h===26||h===27||h===6)return u;for(u=u.child;u!==null;){if(h=c(u),h!==null)return h;u=u.sibling}return null}var d=Object.assign,f=Symbol.for("react.element"),p=Symbol.for("react.transitional.element"),g=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),b=Symbol.for("react.strict_mode"),v=Symbol.for("react.profiler"),w=Symbol.for("react.provider"),$=Symbol.for("react.consumer"),I=Symbol.for("react.context"),N=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),D=Symbol.for("react.suspense_list"),O=Symbol.for("react.memo"),L=Symbol.for("react.lazy"),z=Symbol.for("react.activity"),P=Symbol.for("react.memo_cache_sentinel"),_=Symbol.iterator;function H(u){return u===null||typeof u!="object"?null:(u=_&&u[_]||u["@@iterator"],typeof u=="function"?u:null)}var q=Symbol.for("react.client.reference");function ee(u){if(u==null)return null;if(typeof u=="function")return u.$$typeof===q?null:u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case x:return"Fragment";case v:return"Profiler";case b:return"StrictMode";case E:return"Suspense";case D:return"SuspenseList";case z:return"Activity"}if(typeof u=="object")switch(u.$$typeof){case g:return"Portal";case I:return(u.displayName||"Context")+".Provider";case $:return(u._context.displayName||"Context")+".Consumer";case N:var h=u.render;return u=u.displayName,u||(u=h.displayName||h.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case O:return h=u.displayName||null,h!==null?h:ee(u.type)||"Memo";case L:h=u._payload,u=u._init;try{return ee(u(h))}catch{}}return null}var Y=Array.isArray,G=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,te=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,re={pending:!1,data:null,method:null,action:null},he=[],W=-1;function ne(u){return{current:u}}function pe(u){0>W||(u.current=he[W],he[W]=null,W--)}function de(u,h){W++,he[W]=u.current,u.current=h}var we=ne(null),ke=ne(null),Ne=ne(null),Ue=ne(null);function Le(u,h){switch(de(Ne,h),de(ke,u),de(we,null),h.nodeType){case 9:case 11:u=(u=h.documentElement)&&(u=u.namespaceURI)?Kk(u):0;break;default:if(u=h.tagName,h=h.namespaceURI)h=Kk(h),u=Yk(h,u);else switch(u){case"svg":u=1;break;case"math":u=2;break;default:u=0}}pe(we),de(we,u)}function Ge(){pe(we),pe(ke),pe(Ne)}function at(u){u.memoizedState!==null&&de(Ue,u);var h=we.current,m=Yk(h,u.type);h!==m&&(de(ke,u),de(we,m))}function nt(u){ke.current===u&&(pe(we),pe(ke)),Ue.current===u&&(pe(Ue),vf._currentValue=re)}var Tt=Object.prototype.hasOwnProperty,st=n.unstable_scheduleCallback,gt=n.unstable_cancelCallback,Bt=n.unstable_shouldYield,Pt=n.unstable_requestPaint,$t=n.unstable_now,Ht=n.unstable_getCurrentPriorityLevel,Ys=n.unstable_ImmediatePriority,gn=n.unstable_UserBlockingPriority,Os=n.unstable_NormalPriority,rs=n.unstable_LowPriority,Rr=n.unstable_IdlePriority,Ln=n.log,hr=n.unstable_setDisableYieldValue,is=null,hn=null;function as(u){if(typeof Ln=="function"&&hr(u),hn&&typeof hn.setStrictMode=="function")try{hn.setStrictMode(is,u)}catch{}}var Tn=Math.clz32?Math.clz32:zu,ul=Math.log,no=Math.LN2;function zu(u){return u>>>=0,u===0?32:31-(ul(u)/no|0)|0}var Qs=256,Hi=4194304;function Kr(u){var h=u&42;if(h!==0)return h;switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return u&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return u}}function Lu(u,h,m){var y=u.pendingLanes;if(y===0)return 0;var S=0,k=u.suspendedLanes,F=u.pingedLanes;u=u.warmLanes;var V=y&134217727;return V!==0?(y=V&~k,y!==0?S=Kr(y):(F&=V,F!==0?S=Kr(F):m||(m=V&~u,m!==0&&(S=Kr(m))))):(V=y&~k,V!==0?S=Kr(V):F!==0?S=Kr(F):m||(m=y&~u,m!==0&&(S=Kr(m)))),S===0?0:h!==0&&h!==S&&(h&k)===0&&(k=S&-S,m=h&-h,k>=m||k===32&&(m&4194048)!==0)?h:S}function so(u,h){return(u.pendingLanes&~(u.suspendedLanes&~u.pingedLanes)&h)===0}function Sd(u,h){switch(u){case 1:case 2:case 4:case 8:case 64:return h+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function ji(){var u=Qs;return Qs<<=1,(Qs&4194048)===0&&(Qs=256),u}function ro(){var u=Hi;return Hi<<=1,(Hi&62914560)===0&&(Hi=4194304),u}function Pu(u){for(var h=[],m=0;31>m;m++)h.push(u);return h}function io(u,h){u.pendingLanes|=h,h!==268435456&&(u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0)}function Cd(u,h,m,y,S,k){var F=u.pendingLanes;u.pendingLanes=m,u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0,u.expiredLanes&=m,u.entangledLanes&=m,u.errorRecoveryDisabledLanes&=m,u.shellSuspendCounter=0;var V=u.entanglements,Z=u.expirationTimes,ye=u.hiddenUpdates;for(m=F&~m;0<m;){var $e=31-Tn(m),Te=1<<$e;V[$e]=0,Z[$e]=-1;var xe=ye[$e];if(xe!==null)for(ye[$e]=null,$e=0;$e<xe.length;$e++){var ve=xe[$e];ve!==null&&(ve.lane&=-536870913)}m&=~Te}y!==0&&$d(u,y,0),k!==0&&S===0&&u.tag!==0&&(u.suspendedLanes|=k&~(F&~h))}function $d(u,h,m){u.pendingLanes|=h,u.suspendedLanes&=~h;var y=31-Tn(h);u.entangledLanes|=h,u.entanglements[y]=u.entanglements[y]|1073741824|m&4194090}function qi(u,h){var m=u.entangledLanes|=h;for(u=u.entanglements;m;){var y=31-Tn(m),S=1<<y;S&h|u[y]&h&&(u[y]|=h),m&=~S}}function cl(u){switch(u){case 2:u=1;break;case 8:u=4;break;case 32:u=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:u=128;break;case 268435456:u=134217728;break;default:u=0}return u}function Mu(u){return u&=-u,2<u?8<u?(u&134217727)!==0?32:268435456:8:2}function hl(){var u=te.p;return u!==0?u:(u=window.event,u===void 0?32:mN(u.type))}function Bu(u,h){var m=te.p;try{return te.p=u,h()}finally{te.p=m}}var Xi=Math.random().toString(36).slice(2),wn="__reactFiber$"+Xi,Fs="__reactProps$"+Xi,zs="__reactContainer$"+Xi,Si="__reactEvents$"+Xi,Fm="__reactListeners$"+Xi,Sn="__reactHandles$"+Xi,Ar="__reactResources$"+Xi,Sa="__reactMarker$"+Xi;function kd(u){delete u[wn],delete u[Fs],delete u[Si],delete u[Fm],delete u[Sn]}function Ci(u){var h=u[wn];if(h)return h;for(var m=u.parentNode;m;){if(h=m[zs]||m[wn]){if(m=h.alternate,h.child!==null||m!==null&&m.child!==null)for(u=eN(u);u!==null;){if(m=u[wn])return m;u=eN(u)}return h}u=m,m=u.parentNode}return null}function Ki(u){if(u=u[wn]||u[zs]){var h=u.tag;if(h===5||h===6||h===13||h===26||h===27||h===3)return u}return null}function Yi(u){var h=u.tag;if(h===5||h===26||h===27||h===6)return u.stateNode;throw Error(s(33))}function Yr(u){var h=u[Ar];return h||(h=u[Ar]={hoistableStyles:new Map,hoistableScripts:new Map}),h}function Pn(u){u[Sa]=!0}var Vu=new Set,Uu={};function Qi(u,h){ps(u,h),ps(u+"Capture",h)}function ps(u,h){for(Uu[u]=h,u=0;u<h.length;u++)Vu.add(h[u])}var Qr=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),ao={},Wu={};function Nd(u){return Tt.call(Wu,u)?!0:Tt.call(ao,u)?!1:Qr.test(u)?Wu[u]=!0:(ao[u]=!0,!1)}function dl(u,h,m){if(Nd(h))if(m===null)u.removeAttribute(h);else{switch(typeof m){case"undefined":case"function":case"symbol":u.removeAttribute(h);return;case"boolean":var y=h.toLowerCase().slice(0,5);if(y!=="data-"&&y!=="aria-"){u.removeAttribute(h);return}}u.setAttribute(h,""+m)}}function oo(u,h,m){if(m===null)u.removeAttribute(h);else{switch(typeof m){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(h);return}u.setAttribute(h,""+m)}}function Hn(u,h,m,y){if(y===null)u.removeAttribute(m);else{switch(typeof y){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(m);return}u.setAttributeNS(h,m,""+y)}}var Gu,fl;function ks(u){if(Gu===void 0)try{throw Error()}catch(m){var h=m.stack.trim().match(/\n( *(at )?)/);Gu=h&&h[1]||"",fl=-1<m.stack.indexOf(`
    at`)?" (<anonymous>)":-1<m.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Gu+u+fl}var lo=!1;function Id(u,h){if(!u||lo)return"";lo=!0;var m=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var y={DetermineComponentFrameRoot:function(){try{if(h){var Te=function(){throw Error()};if(Object.defineProperty(Te.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Te,[])}catch(ve){var xe=ve}Reflect.construct(u,[],Te)}else{try{Te.call()}catch(ve){xe=ve}u.call(Te.prototype)}}else{try{throw Error()}catch(ve){xe=ve}(Te=u())&&typeof Te.catch=="function"&&Te.catch(function(){})}}catch(ve){if(ve&&xe&&typeof ve.stack=="string")return[ve.stack,xe.stack]}return[null,null]}};y.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var S=Object.getOwnPropertyDescriptor(y.DetermineComponentFrameRoot,"name");S&&S.configurable&&Object.defineProperty(y.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var k=y.DetermineComponentFrameRoot(),F=k[0],V=k[1];if(F&&V){var Z=F.split(`
`),ye=V.split(`
`);for(S=y=0;y<Z.length&&!Z[y].includes("DetermineComponentFrameRoot");)y++;for(;S<ye.length&&!ye[S].includes("DetermineComponentFrameRoot");)S++;if(y===Z.length||S===ye.length)for(y=Z.length-1,S=ye.length-1;1<=y&&0<=S&&Z[y]!==ye[S];)S--;for(;1<=y&&0<=S;y--,S--)if(Z[y]!==ye[S]){if(y!==1||S!==1)do if(y--,S--,0>S||Z[y]!==ye[S]){var $e=`
`+Z[y].replace(" at new "," at ");return u.displayName&&$e.includes("<anonymous>")&&($e=$e.replace("<anonymous>",u.displayName)),$e}while(1<=y&&0<=S);break}}}finally{lo=!1,Error.prepareStackTrace=m}return(m=u?u.displayName||u.name:"")?ks(m):""}function zm(u){switch(u.tag){case 26:case 27:case 5:return ks(u.type);case 16:return ks("Lazy");case 13:return ks("Suspense");case 19:return ks("SuspenseList");case 0:case 15:return Id(u.type,!1);case 11:return Id(u.type.render,!1);case 1:return Id(u.type,!0);case 31:return ks("Activity");default:return""}}function Hu(u){try{var h="";do h+=zm(u),u=u.return;while(u);return h}catch(m){return`
Error generating stack: `+m.message+`
`+m.stack}}function dr(u){switch(typeof u){case"bigint":case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function Lm(u){var h=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(h==="checkbox"||h==="radio")}function Pm(u){var h=Lm(u)?"checked":"value",m=Object.getOwnPropertyDescriptor(u.constructor.prototype,h),y=""+u[h];if(!u.hasOwnProperty(h)&&typeof m<"u"&&typeof m.get=="function"&&typeof m.set=="function"){var S=m.get,k=m.set;return Object.defineProperty(u,h,{configurable:!0,get:function(){return S.call(this)},set:function(F){y=""+F,k.call(this,F)}}),Object.defineProperty(u,h,{enumerable:m.enumerable}),{getValue:function(){return y},setValue:function(F){y=""+F},stopTracking:function(){u._valueTracker=null,delete u[h]}}}}function pl(u){u._valueTracker||(u._valueTracker=Pm(u))}function Td(u){if(!u)return!1;var h=u._valueTracker;if(!h)return!0;var m=h.getValue(),y="";return u&&(y=Lm(u)?u.checked?"true":"false":u.value),u=y,u!==m?(h.setValue(u),!0):!1}function ml(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}var Ls=/[\n"\\]/g;function Zs(u){return u.replace(Ls,function(h){return"\\"+h.charCodeAt(0).toString(16)+" "})}function ju(u,h,m,y,S,k,F,V){u.name="",F!=null&&typeof F!="function"&&typeof F!="symbol"&&typeof F!="boolean"?u.type=F:u.removeAttribute("type"),h!=null?F==="number"?(h===0&&u.value===""||u.value!=h)&&(u.value=""+dr(h)):u.value!==""+dr(h)&&(u.value=""+dr(h)):F!=="submit"&&F!=="reset"||u.removeAttribute("value"),h!=null?qu(u,F,dr(h)):m!=null?qu(u,F,dr(m)):y!=null&&u.removeAttribute("value"),S==null&&k!=null&&(u.defaultChecked=!!k),S!=null&&(u.checked=S&&typeof S!="function"&&typeof S!="symbol"),V!=null&&typeof V!="function"&&typeof V!="symbol"&&typeof V!="boolean"?u.name=""+dr(V):u.removeAttribute("name")}function gl(u,h,m,y,S,k,F,V){if(k!=null&&typeof k!="function"&&typeof k!="symbol"&&typeof k!="boolean"&&(u.type=k),h!=null||m!=null){if(!(k!=="submit"&&k!=="reset"||h!=null))return;m=m!=null?""+dr(m):"",h=h!=null?""+dr(h):m,V||h===u.value||(u.value=h),u.defaultValue=h}y=y??S,y=typeof y!="function"&&typeof y!="symbol"&&!!y,u.checked=V?u.checked:!!y,u.defaultChecked=!!y,F!=null&&typeof F!="function"&&typeof F!="symbol"&&typeof F!="boolean"&&(u.name=F)}function qu(u,h,m){h==="number"&&ml(u.ownerDocument)===u||u.defaultValue===""+m||(u.defaultValue=""+m)}function Ca(u,h,m,y){if(u=u.options,h){h={};for(var S=0;S<m.length;S++)h["$"+m[S]]=!0;for(m=0;m<u.length;m++)S=h.hasOwnProperty("$"+u[m].value),u[m].selected!==S&&(u[m].selected=S),S&&y&&(u[m].defaultSelected=!0)}else{for(m=""+dr(m),h=null,S=0;S<u.length;S++){if(u[S].value===m){u[S].selected=!0,y&&(u[S].defaultSelected=!0);return}h!==null||u[S].disabled||(h=u[S])}h!==null&&(h.selected=!0)}}function Mm(u,h,m){if(h!=null&&(h=""+dr(h),h!==u.value&&(u.value=h),m==null)){u.defaultValue!==h&&(u.defaultValue=h);return}u.defaultValue=m!=null?""+dr(m):""}function Bm(u,h,m,y){if(h==null){if(y!=null){if(m!=null)throw Error(s(92));if(Y(y)){if(1<y.length)throw Error(s(93));y=y[0]}m=y}m==null&&(m=""),h=m}m=dr(h),u.defaultValue=m,y=u.textContent,y===m&&y!==""&&y!==null&&(u.value=y)}function $a(u,h){if(h){var m=u.firstChild;if(m&&m===u.lastChild&&m.nodeType===3){m.nodeValue=h;return}}u.textContent=h}var Vm=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function yl(u,h,m){var y=h.indexOf("--")===0;m==null||typeof m=="boolean"||m===""?y?u.setProperty(h,""):h==="float"?u.cssFloat="":u[h]="":y?u.setProperty(h,m):typeof m!="number"||m===0||Vm.has(h)?h==="float"?u.cssFloat=m:u[h]=(""+m).trim():u[h]=m+"px"}function Ed(u,h,m){if(h!=null&&typeof h!="object")throw Error(s(62));if(u=u.style,m!=null){for(var y in m)!m.hasOwnProperty(y)||h!=null&&h.hasOwnProperty(y)||(y.indexOf("--")===0?u.setProperty(y,""):y==="float"?u.cssFloat="":u[y]="");for(var S in h)y=h[S],h.hasOwnProperty(S)&&m[S]!==y&&yl(u,S,y)}else for(var k in h)h.hasOwnProperty(k)&&yl(u,k,h[k])}function Xu(u){if(u.indexOf("-")===-1)return!1;switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var xl=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),w0=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Ku(u){return w0.test(""+u)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":u}var Rd=null;function Ad(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var Zi=null,Zr=null;function Um(u){var h=Ki(u);if(h&&(u=h.stateNode)){var m=u[Fs]||null;e:switch(u=h.stateNode,h.type){case"input":if(ju(u,m.value,m.defaultValue,m.defaultValue,m.checked,m.defaultChecked,m.type,m.name),h=m.name,m.type==="radio"&&h!=null){for(m=u;m.parentNode;)m=m.parentNode;for(m=m.querySelectorAll('input[name="'+Zs(""+h)+'"][type="radio"]'),h=0;h<m.length;h++){var y=m[h];if(y!==u&&y.form===u.form){var S=y[Fs]||null;if(!S)throw Error(s(90));ju(y,S.value,S.defaultValue,S.defaultValue,S.checked,S.defaultChecked,S.type,S.name)}}for(h=0;h<m.length;h++)y=m[h],y.form===u.form&&Td(y)}break e;case"textarea":Mm(u,m.value,m.defaultValue);break e;case"select":h=m.value,h!=null&&Ca(u,!!m.multiple,h,!1)}}}var Dd=!1;function Wm(u,h,m){if(Dd)return u(h,m);Dd=!0;try{var y=u(h);return y}finally{if(Dd=!1,(Zi!==null||Zr!==null)&&(Ag(),Zi&&(h=Zi,u=Zr,Zr=Zi=null,Um(h),u)))for(h=0;h<u.length;h++)Um(u[h])}}function bl(u,h){var m=u.stateNode;if(m===null)return null;var y=m[Fs]||null;if(y===null)return null;m=y[h];e:switch(h){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(y=!y.disabled)||(u=u.type,y=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!y;break e;default:u=!1}if(u)return null;if(m&&typeof m!="function")throw Error(s(231,h,typeof m));return m}var Dr=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Yu=!1;if(Dr)try{var uo={};Object.defineProperty(uo,"passive",{get:function(){Yu=!0}}),window.addEventListener("test",uo,uo),window.removeEventListener("test",uo,uo)}catch{Yu=!1}var fr=null,Js=null,Qu=null;function Gm(){if(Qu)return Qu;var u,h=Js,m=h.length,y,S="value"in fr?fr.value:fr.textContent,k=S.length;for(u=0;u<m&&h[u]===S[u];u++);var F=m-u;for(y=1;y<=F&&h[m-y]===S[k-y];y++);return Qu=S.slice(u,1<y?1-y:void 0)}function vl(u){var h=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&h===13&&(u=13)):u=h,u===10&&(u=13),32<=u||u===13?u:0}function wl(){return!0}function Zu(){return!1}function ms(u){function h(m,y,S,k,F){this._reactName=m,this._targetInst=S,this.type=y,this.nativeEvent=k,this.target=F,this.currentTarget=null;for(var V in u)u.hasOwnProperty(V)&&(m=u[V],this[V]=m?m(k):k[V]);return this.isDefaultPrevented=(k.defaultPrevented!=null?k.defaultPrevented:k.returnValue===!1)?wl:Zu,this.isPropagationStopped=Zu,this}return d(h.prototype,{preventDefault:function(){this.defaultPrevented=!0;var m=this.nativeEvent;m&&(m.preventDefault?m.preventDefault():typeof m.returnValue!="unknown"&&(m.returnValue=!1),this.isDefaultPrevented=wl)},stopPropagation:function(){var m=this.nativeEvent;m&&(m.stopPropagation?m.stopPropagation():typeof m.cancelBubble!="unknown"&&(m.cancelBubble=!0),this.isPropagationStopped=wl)},persist:function(){},isPersistent:wl}),h}var pr={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Sl=ms(pr),ka=d({},pr,{view:0,detail:0}),S0=ms(ka),_d,Na,co,Cl=d({},ka,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ec,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==co&&(co&&u.type==="mousemove"?(_d=u.screenX-co.screenX,Na=u.screenY-co.screenY):Na=_d=0,co=u),_d)},movementY:function(u){return"movementY"in u?u.movementY:Na}}),Hm=ms(Cl),C0=d({},Cl,{dataTransfer:0}),Ju=ms(C0),jm=d({},ka,{relatedTarget:0}),Od=ms(jm),qm=d({},pr,{animationName:0,elapsedTime:0,pseudoElement:0}),$0=ms(qm),k0=d({},pr,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),Fd=ms(k0),zd=d({},pr,{data:0}),Ld=ms(zd),N0={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},I0={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},T0={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function E0(u){var h=this.nativeEvent;return h.getModifierState?h.getModifierState(u):(u=T0[u])?!!h[u]:!1}function ec(){return E0}var R0=d({},ka,{key:function(u){if(u.key){var h=N0[u.key]||u.key;if(h!=="Unidentified")return h}return u.type==="keypress"?(u=vl(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?I0[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ec,charCode:function(u){return u.type==="keypress"?vl(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?vl(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),A0=ms(R0),Pd=d({},Cl,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Xm=ms(Pd),D0=d({},ka,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ec}),_0=ms(D0),tc=d({},pr,{propertyName:0,elapsedTime:0,pseudoElement:0}),O0=ms(tc),F0=d({},Cl,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),z0=ms(F0),Km=d({},pr,{newState:0,oldState:0}),Ym=ms(Km),C=[9,13,27,32],T=Dr&&"CompositionEvent"in window,A=null;Dr&&"documentMode"in document&&(A=document.documentMode);var M=Dr&&"TextEvent"in window&&!A,j=Dr&&(!T||A&&8<A&&11>=A),K=" ",X=!1;function oe(u,h){switch(u){case"keyup":return C.indexOf(h.keyCode)!==-1;case"keydown":return h.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function be(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var Re=!1;function Fe(u,h){switch(u){case"compositionend":return be(h);case"keypress":return h.which!==32?null:(X=!0,K);case"textInput":return u=h.data,u===K&&X?null:u;default:return null}}function ot(u,h){if(Re)return u==="compositionend"||!T&&oe(u,h)?(u=Gm(),Qu=Js=fr=null,Re=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(h.ctrlKey||h.altKey||h.metaKey)||h.ctrlKey&&h.altKey){if(h.char&&1<h.char.length)return h.char;if(h.which)return String.fromCharCode(h.which)}return null;case"compositionend":return j&&h.locale!=="ko"?null:h.data;default:return null}}var Ze={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Ve(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h==="input"?!!Ze[u.type]:h==="textarea"}function rt(u,h,m,y){Zi?Zr?Zr.push(y):Zr=[y]:Zi=y,h=Lg(h,"onChange"),0<h.length&&(m=new Sl("onChange","change",null,m,y),u.push({event:m,listeners:h}))}var mt=null,Ut=null;function Jt(u){Gk(u,0)}function En(u){var h=Yi(u);if(Td(h))return u}function er(u,h){if(u==="change")return h}var Ns=!1;if(Dr){var Et;if(Dr){var Mn="oninput"in document;if(!Mn){var $i=document.createElement("div");$i.setAttribute("oninput","return;"),Mn=typeof $i.oninput=="function"}Et=Mn}else Et=!1;Ns=Et&&(!document.documentMode||9<document.documentMode)}function Qm(){mt&&(mt.detachEvent("onpropertychange",Zm),Ut=mt=null)}function Zm(u){if(u.propertyName==="value"&&En(Ut)){var h=[];rt(h,Ut,u,Ad(u)),Wm(Jt,h)}}function L0(u,h,m){u==="focusin"?(Qm(),mt=h,Ut=m,mt.attachEvent("onpropertychange",Zm)):u==="focusout"&&Qm()}function P0(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return En(Ut)}function M0(u,h){if(u==="click")return En(h)}function nc(u,h){if(u==="input"||u==="change")return En(h)}function dz(u,h){return u===h&&(u!==0||1/u===1/h)||u!==u&&h!==h}var _r=typeof Object.is=="function"?Object.is:dz;function Md(u,h){if(_r(u,h))return!0;if(typeof u!="object"||u===null||typeof h!="object"||h===null)return!1;var m=Object.keys(u),y=Object.keys(h);if(m.length!==y.length)return!1;for(y=0;y<m.length;y++){var S=m[y];if(!Tt.call(h,S)||!_r(u[S],h[S]))return!1}return!0}function gC(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function yC(u,h){var m=gC(u);u=0;for(var y;m;){if(m.nodeType===3){if(y=u+m.textContent.length,u<=h&&y>=h)return{node:m,offset:h-u};u=y}e:{for(;m;){if(m.nextSibling){m=m.nextSibling;break e}m=m.parentNode}m=void 0}m=gC(m)}}function xC(u,h){return u&&h?u===h?!0:u&&u.nodeType===3?!1:h&&h.nodeType===3?xC(u,h.parentNode):"contains"in u?u.contains(h):u.compareDocumentPosition?!!(u.compareDocumentPosition(h)&16):!1:!1}function bC(u){u=u!=null&&u.ownerDocument!=null&&u.ownerDocument.defaultView!=null?u.ownerDocument.defaultView:window;for(var h=ml(u.document);h instanceof u.HTMLIFrameElement;){try{var m=typeof h.contentWindow.location.href=="string"}catch{m=!1}if(m)u=h.contentWindow;else break;h=ml(u.document)}return h}function B0(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h&&(h==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||h==="textarea"||u.contentEditable==="true")}var fz=Dr&&"documentMode"in document&&11>=document.documentMode,sc=null,V0=null,Bd=null,U0=!1;function vC(u,h,m){var y=m.window===m?m.document:m.nodeType===9?m:m.ownerDocument;U0||sc==null||sc!==ml(y)||(y=sc,"selectionStart"in y&&B0(y)?y={start:y.selectionStart,end:y.selectionEnd}:(y=(y.ownerDocument&&y.ownerDocument.defaultView||window).getSelection(),y={anchorNode:y.anchorNode,anchorOffset:y.anchorOffset,focusNode:y.focusNode,focusOffset:y.focusOffset}),Bd&&Md(Bd,y)||(Bd=y,y=Lg(V0,"onSelect"),0<y.length&&(h=new Sl("onSelect","select",null,h,m),u.push({event:h,listeners:y}),h.target=sc)))}function $l(u,h){var m={};return m[u.toLowerCase()]=h.toLowerCase(),m["Webkit"+u]="webkit"+h,m["Moz"+u]="moz"+h,m}var rc={animationend:$l("Animation","AnimationEnd"),animationiteration:$l("Animation","AnimationIteration"),animationstart:$l("Animation","AnimationStart"),transitionrun:$l("Transition","TransitionRun"),transitionstart:$l("Transition","TransitionStart"),transitioncancel:$l("Transition","TransitionCancel"),transitionend:$l("Transition","TransitionEnd")},W0={},wC={};Dr&&(wC=document.createElement("div").style,"AnimationEvent"in window||(delete rc.animationend.animation,delete rc.animationiteration.animation,delete rc.animationstart.animation),"TransitionEvent"in window||delete rc.transitionend.transition);function kl(u){if(W0[u])return W0[u];if(!rc[u])return u;var h=rc[u],m;for(m in h)if(h.hasOwnProperty(m)&&m in wC)return W0[u]=h[m];return u}var SC=kl("animationend"),CC=kl("animationiteration"),$C=kl("animationstart"),pz=kl("transitionrun"),mz=kl("transitionstart"),gz=kl("transitioncancel"),kC=kl("transitionend"),NC=new Map,G0="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");G0.push("scrollEnd");function ki(u,h){NC.set(u,h),Qi(h,[u])}var IC=new WeakMap;function Jr(u,h){if(typeof u=="object"&&u!==null){var m=IC.get(u);return m!==void 0?m:(h={value:u,source:h,stack:Hu(h)},IC.set(u,h),h)}return{value:u,source:h,stack:Hu(h)}}var ei=[],ic=0,H0=0;function Jm(){for(var u=ic,h=H0=ic=0;h<u;){var m=ei[h];ei[h++]=null;var y=ei[h];ei[h++]=null;var S=ei[h];ei[h++]=null;var k=ei[h];if(ei[h++]=null,y!==null&&S!==null){var F=y.pending;F===null?S.next=S:(S.next=F.next,F.next=S),y.pending=S}k!==0&&TC(m,S,k)}}function eg(u,h,m,y){ei[ic++]=u,ei[ic++]=h,ei[ic++]=m,ei[ic++]=y,H0|=y,u.lanes|=y,u=u.alternate,u!==null&&(u.lanes|=y)}function j0(u,h,m,y){return eg(u,h,m,y),tg(u)}function ac(u,h){return eg(u,null,null,h),tg(u)}function TC(u,h,m){u.lanes|=m;var y=u.alternate;y!==null&&(y.lanes|=m);for(var S=!1,k=u.return;k!==null;)k.childLanes|=m,y=k.alternate,y!==null&&(y.childLanes|=m),k.tag===22&&(u=k.stateNode,u===null||u._visibility&1||(S=!0)),u=k,k=k.return;return u.tag===3?(k=u.stateNode,S&&h!==null&&(S=31-Tn(m),u=k.hiddenUpdates,y=u[S],y===null?u[S]=[h]:y.push(h),h.lane=m|536870912),k):null}function tg(u){if(50<df)throw df=0,Z1=null,Error(s(185));for(var h=u.return;h!==null;)u=h,h=u.return;return u.tag===3?u.stateNode:null}var oc={};function yz(u,h,m,y){this.tag=u,this.key=m,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=y,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Or(u,h,m,y){return new yz(u,h,m,y)}function q0(u){return u=u.prototype,!(!u||!u.isReactComponent)}function Ia(u,h){var m=u.alternate;return m===null?(m=Or(u.tag,h,u.key,u.mode),m.elementType=u.elementType,m.type=u.type,m.stateNode=u.stateNode,m.alternate=u,u.alternate=m):(m.pendingProps=h,m.type=u.type,m.flags=0,m.subtreeFlags=0,m.deletions=null),m.flags=u.flags&65011712,m.childLanes=u.childLanes,m.lanes=u.lanes,m.child=u.child,m.memoizedProps=u.memoizedProps,m.memoizedState=u.memoizedState,m.updateQueue=u.updateQueue,h=u.dependencies,m.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},m.sibling=u.sibling,m.index=u.index,m.ref=u.ref,m.refCleanup=u.refCleanup,m}function EC(u,h){u.flags&=65011714;var m=u.alternate;return m===null?(u.childLanes=0,u.lanes=h,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=m.childLanes,u.lanes=m.lanes,u.child=m.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=m.memoizedProps,u.memoizedState=m.memoizedState,u.updateQueue=m.updateQueue,u.type=m.type,h=m.dependencies,u.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext}),u}function ng(u,h,m,y,S,k){var F=0;if(y=u,typeof u=="function")q0(u)&&(F=1);else if(typeof u=="string")F=bL(u,m,we.current)?26:u==="html"||u==="head"||u==="body"?27:5;else e:switch(u){case z:return u=Or(31,m,h,S),u.elementType=z,u.lanes=k,u;case x:return Nl(m.children,S,k,h);case b:F=8,S|=24;break;case v:return u=Or(12,m,h,S|2),u.elementType=v,u.lanes=k,u;case E:return u=Or(13,m,h,S),u.elementType=E,u.lanes=k,u;case D:return u=Or(19,m,h,S),u.elementType=D,u.lanes=k,u;default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case w:case I:F=10;break e;case $:F=9;break e;case N:F=11;break e;case O:F=14;break e;case L:F=16,y=null;break e}F=29,m=Error(s(130,u===null?"null":typeof u,"")),y=null}return h=Or(F,m,h,S),h.elementType=u,h.type=y,h.lanes=k,h}function Nl(u,h,m,y){return u=Or(7,u,y,h),u.lanes=m,u}function X0(u,h,m){return u=Or(6,u,null,h),u.lanes=m,u}function K0(u,h,m){return h=Or(4,u.children!==null?u.children:[],u.key,h),h.lanes=m,h.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},h}var lc=[],uc=0,sg=null,rg=0,ti=[],ni=0,Il=null,Ta=1,Ea="";function Tl(u,h){lc[uc++]=rg,lc[uc++]=sg,sg=u,rg=h}function RC(u,h,m){ti[ni++]=Ta,ti[ni++]=Ea,ti[ni++]=Il,Il=u;var y=Ta;u=Ea;var S=32-Tn(y)-1;y&=~(1<<S),m+=1;var k=32-Tn(h)+S;if(30<k){var F=S-S%5;k=(y&(1<<F)-1).toString(32),y>>=F,S-=F,Ta=1<<32-Tn(h)+S|m<<S|y,Ea=k+u}else Ta=1<<k|m<<S|y,Ea=u}function Y0(u){u.return!==null&&(Tl(u,1),RC(u,1,0))}function Q0(u){for(;u===sg;)sg=lc[--uc],lc[uc]=null,rg=lc[--uc],lc[uc]=null;for(;u===Il;)Il=ti[--ni],ti[ni]=null,Ea=ti[--ni],ti[ni]=null,Ta=ti[--ni],ti[ni]=null}var tr=null,Rn=null,Wt=!1,El=null,Ji=!1,Z0=Error(s(519));function Rl(u){var h=Error(s(418,""));throw Wd(Jr(h,u)),Z0}function AC(u){var h=u.stateNode,m=u.type,y=u.memoizedProps;switch(h[wn]=u,h[Fs]=y,m){case"dialog":It("cancel",h),It("close",h);break;case"iframe":case"object":case"embed":It("load",h);break;case"video":case"audio":for(m=0;m<pf.length;m++)It(pf[m],h);break;case"source":It("error",h);break;case"img":case"image":case"link":It("error",h),It("load",h);break;case"details":It("toggle",h);break;case"input":It("invalid",h),gl(h,y.value,y.defaultValue,y.checked,y.defaultChecked,y.type,y.name,!0),pl(h);break;case"select":It("invalid",h);break;case"textarea":It("invalid",h),Bm(h,y.value,y.defaultValue,y.children),pl(h)}m=y.children,typeof m!="string"&&typeof m!="number"&&typeof m!="bigint"||h.textContent===""+m||y.suppressHydrationWarning===!0||Xk(h.textContent,m)?(y.popover!=null&&(It("beforetoggle",h),It("toggle",h)),y.onScroll!=null&&It("scroll",h),y.onScrollEnd!=null&&It("scrollend",h),y.onClick!=null&&(h.onclick=Pg),h=!0):h=!1,h||Rl(u)}function DC(u){for(tr=u.return;tr;)switch(tr.tag){case 5:case 13:Ji=!1;return;case 27:case 3:Ji=!0;return;default:tr=tr.return}}function Vd(u){if(u!==tr)return!1;if(!Wt)return DC(u),Wt=!0,!1;var h=u.tag,m;if((m=h!==3&&h!==27)&&((m=h===5)&&(m=u.type,m=!(m!=="form"&&m!=="button")||pv(u.type,u.memoizedProps)),m=!m),m&&Rn&&Rl(u),DC(u),h===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));e:{for(u=u.nextSibling,h=0;u;){if(u.nodeType===8)if(m=u.data,m==="/$"){if(h===0){Rn=Ii(u.nextSibling);break e}h--}else m!=="$"&&m!=="$!"&&m!=="$?"||h++;u=u.nextSibling}Rn=null}}else h===27?(h=Rn,Io(u.type)?(u=xv,xv=null,Rn=u):Rn=h):Rn=tr?Ii(u.stateNode.nextSibling):null;return!0}function Ud(){Rn=tr=null,Wt=!1}function _C(){var u=El;return u!==null&&(yr===null?yr=u:yr.push.apply(yr,u),El=null),u}function Wd(u){El===null?El=[u]:El.push(u)}var J0=ne(null),Al=null,Ra=null;function ho(u,h,m){de(J0,h._currentValue),h._currentValue=m}function Aa(u){u._currentValue=J0.current,pe(J0)}function e1(u,h,m){for(;u!==null;){var y=u.alternate;if((u.childLanes&h)!==h?(u.childLanes|=h,y!==null&&(y.childLanes|=h)):y!==null&&(y.childLanes&h)!==h&&(y.childLanes|=h),u===m)break;u=u.return}}function t1(u,h,m,y){var S=u.child;for(S!==null&&(S.return=u);S!==null;){var k=S.dependencies;if(k!==null){var F=S.child;k=k.firstContext;e:for(;k!==null;){var V=k;k=S;for(var Z=0;Z<h.length;Z++)if(V.context===h[Z]){k.lanes|=m,V=k.alternate,V!==null&&(V.lanes|=m),e1(k.return,m,u),y||(F=null);break e}k=V.next}}else if(S.tag===18){if(F=S.return,F===null)throw Error(s(341));F.lanes|=m,k=F.alternate,k!==null&&(k.lanes|=m),e1(F,m,u),F=null}else F=S.child;if(F!==null)F.return=S;else for(F=S;F!==null;){if(F===u){F=null;break}if(S=F.sibling,S!==null){S.return=F.return,F=S;break}F=F.return}S=F}}function Gd(u,h,m,y){u=null;for(var S=h,k=!1;S!==null;){if(!k){if((S.flags&524288)!==0)k=!0;else if((S.flags&262144)!==0)break}if(S.tag===10){var F=S.alternate;if(F===null)throw Error(s(387));if(F=F.memoizedProps,F!==null){var V=S.type;_r(S.pendingProps.value,F.value)||(u!==null?u.push(V):u=[V])}}else if(S===Ue.current){if(F=S.alternate,F===null)throw Error(s(387));F.memoizedState.memoizedState!==S.memoizedState.memoizedState&&(u!==null?u.push(vf):u=[vf])}S=S.return}u!==null&&t1(h,u,m,y),h.flags|=262144}function ig(u){for(u=u.firstContext;u!==null;){if(!_r(u.context._currentValue,u.memoizedValue))return!0;u=u.next}return!1}function Dl(u){Al=u,Ra=null,u=u.dependencies,u!==null&&(u.firstContext=null)}function Ps(u){return OC(Al,u)}function ag(u,h){return Al===null&&Dl(u),OC(u,h)}function OC(u,h){var m=h._currentValue;if(h={context:h,memoizedValue:m,next:null},Ra===null){if(u===null)throw Error(s(308));Ra=h,u.dependencies={lanes:0,firstContext:h},u.flags|=524288}else Ra=Ra.next=h;return m}var xz=typeof AbortController<"u"?AbortController:function(){var u=[],h=this.signal={aborted:!1,addEventListener:function(m,y){u.push(y)}};this.abort=function(){h.aborted=!0,u.forEach(function(m){return m()})}},bz=n.unstable_scheduleCallback,vz=n.unstable_NormalPriority,os={$$typeof:I,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function n1(){return{controller:new xz,data:new Map,refCount:0}}function Hd(u){u.refCount--,u.refCount===0&&bz(vz,function(){u.controller.abort()})}var jd=null,s1=0,cc=0,hc=null;function wz(u,h){if(jd===null){var m=jd=[];s1=0,cc=iv(),hc={status:"pending",value:void 0,then:function(y){m.push(y)}}}return s1++,h.then(FC,FC),h}function FC(){if(--s1===0&&jd!==null){hc!==null&&(hc.status="fulfilled");var u=jd;jd=null,cc=0,hc=null;for(var h=0;h<u.length;h++)(0,u[h])()}}function Sz(u,h){var m=[],y={status:"pending",value:null,reason:null,then:function(S){m.push(S)}};return u.then(function(){y.status="fulfilled",y.value=h;for(var S=0;S<m.length;S++)(0,m[S])(h)},function(S){for(y.status="rejected",y.reason=S,S=0;S<m.length;S++)(0,m[S])(void 0)}),y}var zC=G.S;G.S=function(u,h){typeof h=="object"&&h!==null&&typeof h.then=="function"&&wz(u,h),zC!==null&&zC(u,h)};var _l=ne(null);function r1(){var u=_l.current;return u!==null?u:dn.pooledCache}function og(u,h){h===null?de(_l,_l.current):de(_l,h.pool)}function LC(){var u=r1();return u===null?null:{parent:os._currentValue,pool:u}}var qd=Error(s(460)),PC=Error(s(474)),lg=Error(s(542)),i1={then:function(){}};function MC(u){return u=u.status,u==="fulfilled"||u==="rejected"}function ug(){}function BC(u,h,m){switch(m=u[m],m===void 0?u.push(h):m!==h&&(h.then(ug,ug),h=m),h.status){case"fulfilled":return h.value;case"rejected":throw u=h.reason,UC(u),u;default:if(typeof h.status=="string")h.then(ug,ug);else{if(u=dn,u!==null&&100<u.shellSuspendCounter)throw Error(s(482));u=h,u.status="pending",u.then(function(y){if(h.status==="pending"){var S=h;S.status="fulfilled",S.value=y}},function(y){if(h.status==="pending"){var S=h;S.status="rejected",S.reason=y}})}switch(h.status){case"fulfilled":return h.value;case"rejected":throw u=h.reason,UC(u),u}throw Xd=h,qd}}var Xd=null;function VC(){if(Xd===null)throw Error(s(459));var u=Xd;return Xd=null,u}function UC(u){if(u===qd||u===lg)throw Error(s(483))}var fo=!1;function a1(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function o1(u,h){u=u.updateQueue,h.updateQueue===u&&(h.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,callbacks:null})}function po(u){return{lane:u,tag:0,payload:null,callback:null,next:null}}function mo(u,h,m){var y=u.updateQueue;if(y===null)return null;if(y=y.shared,(Xt&2)!==0){var S=y.pending;return S===null?h.next=h:(h.next=S.next,S.next=h),y.pending=h,h=tg(u),TC(u,null,m),h}return eg(u,y,h,m),tg(u)}function Kd(u,h,m){if(h=h.updateQueue,h!==null&&(h=h.shared,(m&4194048)!==0)){var y=h.lanes;y&=u.pendingLanes,m|=y,h.lanes=m,qi(u,m)}}function l1(u,h){var m=u.updateQueue,y=u.alternate;if(y!==null&&(y=y.updateQueue,m===y)){var S=null,k=null;if(m=m.firstBaseUpdate,m!==null){do{var F={lane:m.lane,tag:m.tag,payload:m.payload,callback:null,next:null};k===null?S=k=F:k=k.next=F,m=m.next}while(m!==null);k===null?S=k=h:k=k.next=h}else S=k=h;m={baseState:y.baseState,firstBaseUpdate:S,lastBaseUpdate:k,shared:y.shared,callbacks:y.callbacks},u.updateQueue=m;return}u=m.lastBaseUpdate,u===null?m.firstBaseUpdate=h:u.next=h,m.lastBaseUpdate=h}var u1=!1;function Yd(){if(u1){var u=hc;if(u!==null)throw u}}function Qd(u,h,m,y){u1=!1;var S=u.updateQueue;fo=!1;var k=S.firstBaseUpdate,F=S.lastBaseUpdate,V=S.shared.pending;if(V!==null){S.shared.pending=null;var Z=V,ye=Z.next;Z.next=null,F===null?k=ye:F.next=ye,F=Z;var $e=u.alternate;$e!==null&&($e=$e.updateQueue,V=$e.lastBaseUpdate,V!==F&&(V===null?$e.firstBaseUpdate=ye:V.next=ye,$e.lastBaseUpdate=Z))}if(k!==null){var Te=S.baseState;F=0,$e=ye=Z=null,V=k;do{var xe=V.lane&-536870913,ve=xe!==V.lane;if(ve?(zt&xe)===xe:(y&xe)===xe){xe!==0&&xe===cc&&(u1=!0),$e!==null&&($e=$e.next={lane:0,tag:V.tag,payload:V.payload,callback:null,next:null});e:{var dt=u,it=V;xe=h;var nn=m;switch(it.tag){case 1:if(dt=it.payload,typeof dt=="function"){Te=dt.call(nn,Te,xe);break e}Te=dt;break e;case 3:dt.flags=dt.flags&-65537|128;case 0:if(dt=it.payload,xe=typeof dt=="function"?dt.call(nn,Te,xe):dt,xe==null)break e;Te=d({},Te,xe);break e;case 2:fo=!0}}xe=V.callback,xe!==null&&(u.flags|=64,ve&&(u.flags|=8192),ve=S.callbacks,ve===null?S.callbacks=[xe]:ve.push(xe))}else ve={lane:xe,tag:V.tag,payload:V.payload,callback:V.callback,next:null},$e===null?(ye=$e=ve,Z=Te):$e=$e.next=ve,F|=xe;if(V=V.next,V===null){if(V=S.shared.pending,V===null)break;ve=V,V=ve.next,ve.next=null,S.lastBaseUpdate=ve,S.shared.pending=null}}while(!0);$e===null&&(Z=Te),S.baseState=Z,S.firstBaseUpdate=ye,S.lastBaseUpdate=$e,k===null&&(S.shared.lanes=0),Co|=F,u.lanes=F,u.memoizedState=Te}}function WC(u,h){if(typeof u!="function")throw Error(s(191,u));u.call(h)}function GC(u,h){var m=u.callbacks;if(m!==null)for(u.callbacks=null,u=0;u<m.length;u++)WC(m[u],h)}var dc=ne(null),cg=ne(0);function HC(u,h){u=Pa,de(cg,u),de(dc,h),Pa=u|h.baseLanes}function c1(){de(cg,Pa),de(dc,dc.current)}function h1(){Pa=cg.current,pe(dc),pe(cg)}var go=0,St=null,en=null,jn=null,hg=!1,fc=!1,Ol=!1,dg=0,Zd=0,pc=null,Cz=0;function Bn(){throw Error(s(321))}function d1(u,h){if(h===null)return!1;for(var m=0;m<h.length&&m<u.length;m++)if(!_r(u[m],h[m]))return!1;return!0}function f1(u,h,m,y,S,k){return go=k,St=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,G.H=u===null||u.memoizedState===null?T$:E$,Ol=!1,k=m(y,S),Ol=!1,fc&&(k=qC(h,m,y,S)),jC(u),k}function jC(u){G.H=xg;var h=en!==null&&en.next!==null;if(go=0,jn=en=St=null,hg=!1,Zd=0,pc=null,h)throw Error(s(300));u===null||gs||(u=u.dependencies,u!==null&&ig(u)&&(gs=!0))}function qC(u,h,m,y){St=u;var S=0;do{if(fc&&(pc=null),Zd=0,fc=!1,25<=S)throw Error(s(301));if(S+=1,jn=en=null,u.updateQueue!=null){var k=u.updateQueue;k.lastEffect=null,k.events=null,k.stores=null,k.memoCache!=null&&(k.memoCache.index=0)}G.H=Rz,k=h(m,y)}while(fc);return k}function $z(){var u=G.H,h=u.useState()[0];return h=typeof h.then=="function"?Jd(h):h,u=u.useState()[0],(en!==null?en.memoizedState:null)!==u&&(St.flags|=1024),h}function p1(){var u=dg!==0;return dg=0,u}function m1(u,h,m){h.updateQueue=u.updateQueue,h.flags&=-2053,u.lanes&=~m}function g1(u){if(hg){for(u=u.memoizedState;u!==null;){var h=u.queue;h!==null&&(h.pending=null),u=u.next}hg=!1}go=0,jn=en=St=null,fc=!1,Zd=dg=0,pc=null}function mr(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return jn===null?St.memoizedState=jn=u:jn=jn.next=u,jn}function qn(){if(en===null){var u=St.alternate;u=u!==null?u.memoizedState:null}else u=en.next;var h=jn===null?St.memoizedState:jn.next;if(h!==null)jn=h,en=u;else{if(u===null)throw St.alternate===null?Error(s(467)):Error(s(310));en=u,u={memoizedState:en.memoizedState,baseState:en.baseState,baseQueue:en.baseQueue,queue:en.queue,next:null},jn===null?St.memoizedState=jn=u:jn=jn.next=u}return jn}function y1(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Jd(u){var h=Zd;return Zd+=1,pc===null&&(pc=[]),u=BC(pc,u,h),h=St,(jn===null?h.memoizedState:jn.next)===null&&(h=h.alternate,G.H=h===null||h.memoizedState===null?T$:E$),u}function fg(u){if(u!==null&&typeof u=="object"){if(typeof u.then=="function")return Jd(u);if(u.$$typeof===I)return Ps(u)}throw Error(s(438,String(u)))}function x1(u){var h=null,m=St.updateQueue;if(m!==null&&(h=m.memoCache),h==null){var y=St.alternate;y!==null&&(y=y.updateQueue,y!==null&&(y=y.memoCache,y!=null&&(h={data:y.data.map(function(S){return S.slice()}),index:0})))}if(h==null&&(h={data:[],index:0}),m===null&&(m=y1(),St.updateQueue=m),m.memoCache=h,m=h.data[h.index],m===void 0)for(m=h.data[h.index]=Array(u),y=0;y<u;y++)m[y]=P;return h.index++,m}function Da(u,h){return typeof h=="function"?h(u):h}function pg(u){var h=qn();return b1(h,en,u)}function b1(u,h,m){var y=u.queue;if(y===null)throw Error(s(311));y.lastRenderedReducer=m;var S=u.baseQueue,k=y.pending;if(k!==null){if(S!==null){var F=S.next;S.next=k.next,k.next=F}h.baseQueue=S=k,y.pending=null}if(k=u.baseState,S===null)u.memoizedState=k;else{h=S.next;var V=F=null,Z=null,ye=h,$e=!1;do{var Te=ye.lane&-536870913;if(Te!==ye.lane?(zt&Te)===Te:(go&Te)===Te){var xe=ye.revertLane;if(xe===0)Z!==null&&(Z=Z.next={lane:0,revertLane:0,action:ye.action,hasEagerState:ye.hasEagerState,eagerState:ye.eagerState,next:null}),Te===cc&&($e=!0);else if((go&xe)===xe){ye=ye.next,xe===cc&&($e=!0);continue}else Te={lane:0,revertLane:ye.revertLane,action:ye.action,hasEagerState:ye.hasEagerState,eagerState:ye.eagerState,next:null},Z===null?(V=Z=Te,F=k):Z=Z.next=Te,St.lanes|=xe,Co|=xe;Te=ye.action,Ol&&m(k,Te),k=ye.hasEagerState?ye.eagerState:m(k,Te)}else xe={lane:Te,revertLane:ye.revertLane,action:ye.action,hasEagerState:ye.hasEagerState,eagerState:ye.eagerState,next:null},Z===null?(V=Z=xe,F=k):Z=Z.next=xe,St.lanes|=Te,Co|=Te;ye=ye.next}while(ye!==null&&ye!==h);if(Z===null?F=k:Z.next=V,!_r(k,u.memoizedState)&&(gs=!0,$e&&(m=hc,m!==null)))throw m;u.memoizedState=k,u.baseState=F,u.baseQueue=Z,y.lastRenderedState=k}return S===null&&(y.lanes=0),[u.memoizedState,y.dispatch]}function v1(u){var h=qn(),m=h.queue;if(m===null)throw Error(s(311));m.lastRenderedReducer=u;var y=m.dispatch,S=m.pending,k=h.memoizedState;if(S!==null){m.pending=null;var F=S=S.next;do k=u(k,F.action),F=F.next;while(F!==S);_r(k,h.memoizedState)||(gs=!0),h.memoizedState=k,h.baseQueue===null&&(h.baseState=k),m.lastRenderedState=k}return[k,y]}function XC(u,h,m){var y=St,S=qn(),k=Wt;if(k){if(m===void 0)throw Error(s(407));m=m()}else m=h();var F=!_r((en||S).memoizedState,m);F&&(S.memoizedState=m,gs=!0),S=S.queue;var V=QC.bind(null,y,S,u);if(ef(2048,8,V,[u]),S.getSnapshot!==h||F||jn!==null&&jn.memoizedState.tag&1){if(y.flags|=2048,mc(9,mg(),YC.bind(null,y,S,m,h),null),dn===null)throw Error(s(349));k||(go&124)!==0||KC(y,h,m)}return m}function KC(u,h,m){u.flags|=16384,u={getSnapshot:h,value:m},h=St.updateQueue,h===null?(h=y1(),St.updateQueue=h,h.stores=[u]):(m=h.stores,m===null?h.stores=[u]:m.push(u))}function YC(u,h,m,y){h.value=m,h.getSnapshot=y,ZC(h)&&JC(u)}function QC(u,h,m){return m(function(){ZC(h)&&JC(u)})}function ZC(u){var h=u.getSnapshot;u=u.value;try{var m=h();return!_r(u,m)}catch{return!0}}function JC(u){var h=ac(u,2);h!==null&&Mr(h,u,2)}function w1(u){var h=mr();if(typeof u=="function"){var m=u;if(u=m(),Ol){as(!0);try{m()}finally{as(!1)}}}return h.memoizedState=h.baseState=u,h.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Da,lastRenderedState:u},h}function e$(u,h,m,y){return u.baseState=m,b1(u,en,typeof y=="function"?y:Da)}function kz(u,h,m,y,S){if(yg(u))throw Error(s(485));if(u=h.action,u!==null){var k={payload:S,action:u,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(F){k.listeners.push(F)}};G.T!==null?m(!0):k.isTransition=!1,y(k),m=h.pending,m===null?(k.next=h.pending=k,t$(h,k)):(k.next=m.next,h.pending=m.next=k)}}function t$(u,h){var m=h.action,y=h.payload,S=u.state;if(h.isTransition){var k=G.T,F={};G.T=F;try{var V=m(S,y),Z=G.S;Z!==null&&Z(F,V),n$(u,h,V)}catch(ye){S1(u,h,ye)}finally{G.T=k}}else try{k=m(S,y),n$(u,h,k)}catch(ye){S1(u,h,ye)}}function n$(u,h,m){m!==null&&typeof m=="object"&&typeof m.then=="function"?m.then(function(y){s$(u,h,y)},function(y){return S1(u,h,y)}):s$(u,h,m)}function s$(u,h,m){h.status="fulfilled",h.value=m,r$(h),u.state=m,h=u.pending,h!==null&&(m=h.next,m===h?u.pending=null:(m=m.next,h.next=m,t$(u,m)))}function S1(u,h,m){var y=u.pending;if(u.pending=null,y!==null){y=y.next;do h.status="rejected",h.reason=m,r$(h),h=h.next;while(h!==y)}u.action=null}function r$(u){u=u.listeners;for(var h=0;h<u.length;h++)(0,u[h])()}function i$(u,h){return h}function a$(u,h){if(Wt){var m=dn.formState;if(m!==null){e:{var y=St;if(Wt){if(Rn){t:{for(var S=Rn,k=Ji;S.nodeType!==8;){if(!k){S=null;break t}if(S=Ii(S.nextSibling),S===null){S=null;break t}}k=S.data,S=k==="F!"||k==="F"?S:null}if(S){Rn=Ii(S.nextSibling),y=S.data==="F!";break e}}Rl(y)}y=!1}y&&(h=m[0])}}return m=mr(),m.memoizedState=m.baseState=h,y={pending:null,lanes:0,dispatch:null,lastRenderedReducer:i$,lastRenderedState:h},m.queue=y,m=k$.bind(null,St,y),y.dispatch=m,y=w1(!1),k=I1.bind(null,St,!1,y.queue),y=mr(),S={state:h,dispatch:null,action:u,pending:null},y.queue=S,m=kz.bind(null,St,S,k,m),S.dispatch=m,y.memoizedState=u,[h,m,!1]}function o$(u){var h=qn();return l$(h,en,u)}function l$(u,h,m){if(h=b1(u,h,i$)[0],u=pg(Da)[0],typeof h=="object"&&h!==null&&typeof h.then=="function")try{var y=Jd(h)}catch(F){throw F===qd?lg:F}else y=h;h=qn();var S=h.queue,k=S.dispatch;return m!==h.memoizedState&&(St.flags|=2048,mc(9,mg(),Nz.bind(null,S,m),null)),[y,k,u]}function Nz(u,h){u.action=h}function u$(u){var h=qn(),m=en;if(m!==null)return l$(h,m,u);qn(),h=h.memoizedState,m=qn();var y=m.queue.dispatch;return m.memoizedState=u,[h,y,!1]}function mc(u,h,m,y){return u={tag:u,create:m,deps:y,inst:h,next:null},h=St.updateQueue,h===null&&(h=y1(),St.updateQueue=h),m=h.lastEffect,m===null?h.lastEffect=u.next=u:(y=m.next,m.next=u,u.next=y,h.lastEffect=u),u}function mg(){return{destroy:void 0,resource:void 0}}function c$(){return qn().memoizedState}function gg(u,h,m,y){var S=mr();y=y===void 0?null:y,St.flags|=u,S.memoizedState=mc(1|h,mg(),m,y)}function ef(u,h,m,y){var S=qn();y=y===void 0?null:y;var k=S.memoizedState.inst;en!==null&&y!==null&&d1(y,en.memoizedState.deps)?S.memoizedState=mc(h,k,m,y):(St.flags|=u,S.memoizedState=mc(1|h,k,m,y))}function h$(u,h){gg(8390656,8,u,h)}function d$(u,h){ef(2048,8,u,h)}function f$(u,h){return ef(4,2,u,h)}function p$(u,h){return ef(4,4,u,h)}function m$(u,h){if(typeof h=="function"){u=u();var m=h(u);return function(){typeof m=="function"?m():h(null)}}if(h!=null)return u=u(),h.current=u,function(){h.current=null}}function g$(u,h,m){m=m!=null?m.concat([u]):null,ef(4,4,m$.bind(null,h,u),m)}function C1(){}function y$(u,h){var m=qn();h=h===void 0?null:h;var y=m.memoizedState;return h!==null&&d1(h,y[1])?y[0]:(m.memoizedState=[u,h],u)}function x$(u,h){var m=qn();h=h===void 0?null:h;var y=m.memoizedState;if(h!==null&&d1(h,y[1]))return y[0];if(y=u(),Ol){as(!0);try{u()}finally{as(!1)}}return m.memoizedState=[y,h],y}function $1(u,h,m){return m===void 0||(go&1073741824)!==0?u.memoizedState=h:(u.memoizedState=m,u=wk(),St.lanes|=u,Co|=u,m)}function b$(u,h,m,y){return _r(m,h)?m:dc.current!==null?(u=$1(u,m,y),_r(u,h)||(gs=!0),u):(go&42)===0?(gs=!0,u.memoizedState=m):(u=wk(),St.lanes|=u,Co|=u,h)}function v$(u,h,m,y,S){var k=te.p;te.p=k!==0&&8>k?k:8;var F=G.T,V={};G.T=V,I1(u,!1,h,m);try{var Z=S(),ye=G.S;if(ye!==null&&ye(V,Z),Z!==null&&typeof Z=="object"&&typeof Z.then=="function"){var $e=Sz(Z,y);tf(u,h,$e,Pr(u))}else tf(u,h,y,Pr(u))}catch(Te){tf(u,h,{then:function(){},status:"rejected",reason:Te},Pr())}finally{te.p=k,G.T=F}}function Iz(){}function k1(u,h,m,y){if(u.tag!==5)throw Error(s(476));var S=w$(u).queue;v$(u,S,h,re,m===null?Iz:function(){return S$(u),m(y)})}function w$(u){var h=u.memoizedState;if(h!==null)return h;h={memoizedState:re,baseState:re,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Da,lastRenderedState:re},next:null};var m={};return h.next={memoizedState:m,baseState:m,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Da,lastRenderedState:m},next:null},u.memoizedState=h,u=u.alternate,u!==null&&(u.memoizedState=h),h}function S$(u){var h=w$(u).next.queue;tf(u,h,{},Pr())}function N1(){return Ps(vf)}function C$(){return qn().memoizedState}function $$(){return qn().memoizedState}function Tz(u){for(var h=u.return;h!==null;){switch(h.tag){case 24:case 3:var m=Pr();u=po(m);var y=mo(h,u,m);y!==null&&(Mr(y,h,m),Kd(y,h,m)),h={cache:n1()},u.payload=h;return}h=h.return}}function Ez(u,h,m){var y=Pr();m={lane:y,revertLane:0,action:m,hasEagerState:!1,eagerState:null,next:null},yg(u)?N$(h,m):(m=j0(u,h,m,y),m!==null&&(Mr(m,u,y),I$(m,h,y)))}function k$(u,h,m){var y=Pr();tf(u,h,m,y)}function tf(u,h,m,y){var S={lane:y,revertLane:0,action:m,hasEagerState:!1,eagerState:null,next:null};if(yg(u))N$(h,S);else{var k=u.alternate;if(u.lanes===0&&(k===null||k.lanes===0)&&(k=h.lastRenderedReducer,k!==null))try{var F=h.lastRenderedState,V=k(F,m);if(S.hasEagerState=!0,S.eagerState=V,_r(V,F))return eg(u,h,S,0),dn===null&&Jm(),!1}catch{}finally{}if(m=j0(u,h,S,y),m!==null)return Mr(m,u,y),I$(m,h,y),!0}return!1}function I1(u,h,m,y){if(y={lane:2,revertLane:iv(),action:y,hasEagerState:!1,eagerState:null,next:null},yg(u)){if(h)throw Error(s(479))}else h=j0(u,m,y,2),h!==null&&Mr(h,u,2)}function yg(u){var h=u.alternate;return u===St||h!==null&&h===St}function N$(u,h){fc=hg=!0;var m=u.pending;m===null?h.next=h:(h.next=m.next,m.next=h),u.pending=h}function I$(u,h,m){if((m&4194048)!==0){var y=h.lanes;y&=u.pendingLanes,m|=y,h.lanes=m,qi(u,m)}}var xg={readContext:Ps,use:fg,useCallback:Bn,useContext:Bn,useEffect:Bn,useImperativeHandle:Bn,useLayoutEffect:Bn,useInsertionEffect:Bn,useMemo:Bn,useReducer:Bn,useRef:Bn,useState:Bn,useDebugValue:Bn,useDeferredValue:Bn,useTransition:Bn,useSyncExternalStore:Bn,useId:Bn,useHostTransitionStatus:Bn,useFormState:Bn,useActionState:Bn,useOptimistic:Bn,useMemoCache:Bn,useCacheRefresh:Bn},T$={readContext:Ps,use:fg,useCallback:function(u,h){return mr().memoizedState=[u,h===void 0?null:h],u},useContext:Ps,useEffect:h$,useImperativeHandle:function(u,h,m){m=m!=null?m.concat([u]):null,gg(4194308,4,m$.bind(null,h,u),m)},useLayoutEffect:function(u,h){return gg(4194308,4,u,h)},useInsertionEffect:function(u,h){gg(4,2,u,h)},useMemo:function(u,h){var m=mr();h=h===void 0?null:h;var y=u();if(Ol){as(!0);try{u()}finally{as(!1)}}return m.memoizedState=[y,h],y},useReducer:function(u,h,m){var y=mr();if(m!==void 0){var S=m(h);if(Ol){as(!0);try{m(h)}finally{as(!1)}}}else S=h;return y.memoizedState=y.baseState=S,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:S},y.queue=u,u=u.dispatch=Ez.bind(null,St,u),[y.memoizedState,u]},useRef:function(u){var h=mr();return u={current:u},h.memoizedState=u},useState:function(u){u=w1(u);var h=u.queue,m=k$.bind(null,St,h);return h.dispatch=m,[u.memoizedState,m]},useDebugValue:C1,useDeferredValue:function(u,h){var m=mr();return $1(m,u,h)},useTransition:function(){var u=w1(!1);return u=v$.bind(null,St,u.queue,!0,!1),mr().memoizedState=u,[!1,u]},useSyncExternalStore:function(u,h,m){var y=St,S=mr();if(Wt){if(m===void 0)throw Error(s(407));m=m()}else{if(m=h(),dn===null)throw Error(s(349));(zt&124)!==0||KC(y,h,m)}S.memoizedState=m;var k={value:m,getSnapshot:h};return S.queue=k,h$(QC.bind(null,y,k,u),[u]),y.flags|=2048,mc(9,mg(),YC.bind(null,y,k,m,h),null),m},useId:function(){var u=mr(),h=dn.identifierPrefix;if(Wt){var m=Ea,y=Ta;m=(y&~(1<<32-Tn(y)-1)).toString(32)+m,h="«"+h+"R"+m,m=dg++,0<m&&(h+="H"+m.toString(32)),h+="»"}else m=Cz++,h="«"+h+"r"+m.toString(32)+"»";return u.memoizedState=h},useHostTransitionStatus:N1,useFormState:a$,useActionState:a$,useOptimistic:function(u){var h=mr();h.memoizedState=h.baseState=u;var m={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return h.queue=m,h=I1.bind(null,St,!0,m),m.dispatch=h,[u,h]},useMemoCache:x1,useCacheRefresh:function(){return mr().memoizedState=Tz.bind(null,St)}},E$={readContext:Ps,use:fg,useCallback:y$,useContext:Ps,useEffect:d$,useImperativeHandle:g$,useInsertionEffect:f$,useLayoutEffect:p$,useMemo:x$,useReducer:pg,useRef:c$,useState:function(){return pg(Da)},useDebugValue:C1,useDeferredValue:function(u,h){var m=qn();return b$(m,en.memoizedState,u,h)},useTransition:function(){var u=pg(Da)[0],h=qn().memoizedState;return[typeof u=="boolean"?u:Jd(u),h]},useSyncExternalStore:XC,useId:C$,useHostTransitionStatus:N1,useFormState:o$,useActionState:o$,useOptimistic:function(u,h){var m=qn();return e$(m,en,u,h)},useMemoCache:x1,useCacheRefresh:$$},Rz={readContext:Ps,use:fg,useCallback:y$,useContext:Ps,useEffect:d$,useImperativeHandle:g$,useInsertionEffect:f$,useLayoutEffect:p$,useMemo:x$,useReducer:v1,useRef:c$,useState:function(){return v1(Da)},useDebugValue:C1,useDeferredValue:function(u,h){var m=qn();return en===null?$1(m,u,h):b$(m,en.memoizedState,u,h)},useTransition:function(){var u=v1(Da)[0],h=qn().memoizedState;return[typeof u=="boolean"?u:Jd(u),h]},useSyncExternalStore:XC,useId:C$,useHostTransitionStatus:N1,useFormState:u$,useActionState:u$,useOptimistic:function(u,h){var m=qn();return en!==null?e$(m,en,u,h):(m.baseState=u,[u,m.queue.dispatch])},useMemoCache:x1,useCacheRefresh:$$},gc=null,nf=0;function bg(u){var h=nf;return nf+=1,gc===null&&(gc=[]),BC(gc,u,h)}function sf(u,h){h=h.props.ref,u.ref=h!==void 0?h:null}function vg(u,h){throw h.$$typeof===f?Error(s(525)):(u=Object.prototype.toString.call(h),Error(s(31,u==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":u)))}function R$(u){var h=u._init;return h(u._payload)}function A$(u){function h(me,le){if(u){var ge=me.deletions;ge===null?(me.deletions=[le],me.flags|=16):ge.push(le)}}function m(me,le){if(!u)return null;for(;le!==null;)h(me,le),le=le.sibling;return null}function y(me){for(var le=new Map;me!==null;)me.key!==null?le.set(me.key,me):le.set(me.index,me),me=me.sibling;return le}function S(me,le){return me=Ia(me,le),me.index=0,me.sibling=null,me}function k(me,le,ge){return me.index=ge,u?(ge=me.alternate,ge!==null?(ge=ge.index,ge<le?(me.flags|=67108866,le):ge):(me.flags|=67108866,le)):(me.flags|=1048576,le)}function F(me){return u&&me.alternate===null&&(me.flags|=67108866),me}function V(me,le,ge,Ie){return le===null||le.tag!==6?(le=X0(ge,me.mode,Ie),le.return=me,le):(le=S(le,ge),le.return=me,le)}function Z(me,le,ge,Ie){var Xe=ge.type;return Xe===x?$e(me,le,ge.props.children,Ie,ge.key):le!==null&&(le.elementType===Xe||typeof Xe=="object"&&Xe!==null&&Xe.$$typeof===L&&R$(Xe)===le.type)?(le=S(le,ge.props),sf(le,ge),le.return=me,le):(le=ng(ge.type,ge.key,ge.props,null,me.mode,Ie),sf(le,ge),le.return=me,le)}function ye(me,le,ge,Ie){return le===null||le.tag!==4||le.stateNode.containerInfo!==ge.containerInfo||le.stateNode.implementation!==ge.implementation?(le=K0(ge,me.mode,Ie),le.return=me,le):(le=S(le,ge.children||[]),le.return=me,le)}function $e(me,le,ge,Ie,Xe){return le===null||le.tag!==7?(le=Nl(ge,me.mode,Ie,Xe),le.return=me,le):(le=S(le,ge),le.return=me,le)}function Te(me,le,ge){if(typeof le=="string"&&le!==""||typeof le=="number"||typeof le=="bigint")return le=X0(""+le,me.mode,ge),le.return=me,le;if(typeof le=="object"&&le!==null){switch(le.$$typeof){case p:return ge=ng(le.type,le.key,le.props,null,me.mode,ge),sf(ge,le),ge.return=me,ge;case g:return le=K0(le,me.mode,ge),le.return=me,le;case L:var Ie=le._init;return le=Ie(le._payload),Te(me,le,ge)}if(Y(le)||H(le))return le=Nl(le,me.mode,ge,null),le.return=me,le;if(typeof le.then=="function")return Te(me,bg(le),ge);if(le.$$typeof===I)return Te(me,ag(me,le),ge);vg(me,le)}return null}function xe(me,le,ge,Ie){var Xe=le!==null?le.key:null;if(typeof ge=="string"&&ge!==""||typeof ge=="number"||typeof ge=="bigint")return Xe!==null?null:V(me,le,""+ge,Ie);if(typeof ge=="object"&&ge!==null){switch(ge.$$typeof){case p:return ge.key===Xe?Z(me,le,ge,Ie):null;case g:return ge.key===Xe?ye(me,le,ge,Ie):null;case L:return Xe=ge._init,ge=Xe(ge._payload),xe(me,le,ge,Ie)}if(Y(ge)||H(ge))return Xe!==null?null:$e(me,le,ge,Ie,null);if(typeof ge.then=="function")return xe(me,le,bg(ge),Ie);if(ge.$$typeof===I)return xe(me,le,ag(me,ge),Ie);vg(me,ge)}return null}function ve(me,le,ge,Ie,Xe){if(typeof Ie=="string"&&Ie!==""||typeof Ie=="number"||typeof Ie=="bigint")return me=me.get(ge)||null,V(le,me,""+Ie,Xe);if(typeof Ie=="object"&&Ie!==null){switch(Ie.$$typeof){case p:return me=me.get(Ie.key===null?ge:Ie.key)||null,Z(le,me,Ie,Xe);case g:return me=me.get(Ie.key===null?ge:Ie.key)||null,ye(le,me,Ie,Xe);case L:var kt=Ie._init;return Ie=kt(Ie._payload),ve(me,le,ge,Ie,Xe)}if(Y(Ie)||H(Ie))return me=me.get(ge)||null,$e(le,me,Ie,Xe,null);if(typeof Ie.then=="function")return ve(me,le,ge,bg(Ie),Xe);if(Ie.$$typeof===I)return ve(me,le,ge,ag(le,Ie),Xe);vg(le,Ie)}return null}function dt(me,le,ge,Ie){for(var Xe=null,kt=null,Je=le,lt=le=0,xs=null;Je!==null&&lt<ge.length;lt++){Je.index>lt?(xs=Je,Je=null):xs=Je.sibling;var Vt=xe(me,Je,ge[lt],Ie);if(Vt===null){Je===null&&(Je=xs);break}u&&Je&&Vt.alternate===null&&h(me,Je),le=k(Vt,le,lt),kt===null?Xe=Vt:kt.sibling=Vt,kt=Vt,Je=xs}if(lt===ge.length)return m(me,Je),Wt&&Tl(me,lt),Xe;if(Je===null){for(;lt<ge.length;lt++)Je=Te(me,ge[lt],Ie),Je!==null&&(le=k(Je,le,lt),kt===null?Xe=Je:kt.sibling=Je,kt=Je);return Wt&&Tl(me,lt),Xe}for(Je=y(Je);lt<ge.length;lt++)xs=ve(Je,me,lt,ge[lt],Ie),xs!==null&&(u&&xs.alternate!==null&&Je.delete(xs.key===null?lt:xs.key),le=k(xs,le,lt),kt===null?Xe=xs:kt.sibling=xs,kt=xs);return u&&Je.forEach(function(Do){return h(me,Do)}),Wt&&Tl(me,lt),Xe}function it(me,le,ge,Ie){if(ge==null)throw Error(s(151));for(var Xe=null,kt=null,Je=le,lt=le=0,xs=null,Vt=ge.next();Je!==null&&!Vt.done;lt++,Vt=ge.next()){Je.index>lt?(xs=Je,Je=null):xs=Je.sibling;var Do=xe(me,Je,Vt.value,Ie);if(Do===null){Je===null&&(Je=xs);break}u&&Je&&Do.alternate===null&&h(me,Je),le=k(Do,le,lt),kt===null?Xe=Do:kt.sibling=Do,kt=Do,Je=xs}if(Vt.done)return m(me,Je),Wt&&Tl(me,lt),Xe;if(Je===null){for(;!Vt.done;lt++,Vt=ge.next())Vt=Te(me,Vt.value,Ie),Vt!==null&&(le=k(Vt,le,lt),kt===null?Xe=Vt:kt.sibling=Vt,kt=Vt);return Wt&&Tl(me,lt),Xe}for(Je=y(Je);!Vt.done;lt++,Vt=ge.next())Vt=ve(Je,me,lt,Vt.value,Ie),Vt!==null&&(u&&Vt.alternate!==null&&Je.delete(Vt.key===null?lt:Vt.key),le=k(Vt,le,lt),kt===null?Xe=Vt:kt.sibling=Vt,kt=Vt);return u&&Je.forEach(function(AL){return h(me,AL)}),Wt&&Tl(me,lt),Xe}function nn(me,le,ge,Ie){if(typeof ge=="object"&&ge!==null&&ge.type===x&&ge.key===null&&(ge=ge.props.children),typeof ge=="object"&&ge!==null){switch(ge.$$typeof){case p:e:{for(var Xe=ge.key;le!==null;){if(le.key===Xe){if(Xe=ge.type,Xe===x){if(le.tag===7){m(me,le.sibling),Ie=S(le,ge.props.children),Ie.return=me,me=Ie;break e}}else if(le.elementType===Xe||typeof Xe=="object"&&Xe!==null&&Xe.$$typeof===L&&R$(Xe)===le.type){m(me,le.sibling),Ie=S(le,ge.props),sf(Ie,ge),Ie.return=me,me=Ie;break e}m(me,le);break}else h(me,le);le=le.sibling}ge.type===x?(Ie=Nl(ge.props.children,me.mode,Ie,ge.key),Ie.return=me,me=Ie):(Ie=ng(ge.type,ge.key,ge.props,null,me.mode,Ie),sf(Ie,ge),Ie.return=me,me=Ie)}return F(me);case g:e:{for(Xe=ge.key;le!==null;){if(le.key===Xe)if(le.tag===4&&le.stateNode.containerInfo===ge.containerInfo&&le.stateNode.implementation===ge.implementation){m(me,le.sibling),Ie=S(le,ge.children||[]),Ie.return=me,me=Ie;break e}else{m(me,le);break}else h(me,le);le=le.sibling}Ie=K0(ge,me.mode,Ie),Ie.return=me,me=Ie}return F(me);case L:return Xe=ge._init,ge=Xe(ge._payload),nn(me,le,ge,Ie)}if(Y(ge))return dt(me,le,ge,Ie);if(H(ge)){if(Xe=H(ge),typeof Xe!="function")throw Error(s(150));return ge=Xe.call(ge),it(me,le,ge,Ie)}if(typeof ge.then=="function")return nn(me,le,bg(ge),Ie);if(ge.$$typeof===I)return nn(me,le,ag(me,ge),Ie);vg(me,ge)}return typeof ge=="string"&&ge!==""||typeof ge=="number"||typeof ge=="bigint"?(ge=""+ge,le!==null&&le.tag===6?(m(me,le.sibling),Ie=S(le,ge),Ie.return=me,me=Ie):(m(me,le),Ie=X0(ge,me.mode,Ie),Ie.return=me,me=Ie),F(me)):m(me,le)}return function(me,le,ge,Ie){try{nf=0;var Xe=nn(me,le,ge,Ie);return gc=null,Xe}catch(Je){if(Je===qd||Je===lg)throw Je;var kt=Or(29,Je,null,me.mode);return kt.lanes=Ie,kt.return=me,kt}finally{}}}var yc=A$(!0),D$=A$(!1),si=ne(null),ea=null;function yo(u){var h=u.alternate;de(ls,ls.current&1),de(si,u),ea===null&&(h===null||dc.current!==null||h.memoizedState!==null)&&(ea=u)}function _$(u){if(u.tag===22){if(de(ls,ls.current),de(si,u),ea===null){var h=u.alternate;h!==null&&h.memoizedState!==null&&(ea=u)}}else xo()}function xo(){de(ls,ls.current),de(si,si.current)}function _a(u){pe(si),ea===u&&(ea=null),pe(ls)}var ls=ne(0);function wg(u){for(var h=u;h!==null;){if(h.tag===13){var m=h.memoizedState;if(m!==null&&(m=m.dehydrated,m===null||m.data==="$?"||yv(m)))return h}else if(h.tag===19&&h.memoizedProps.revealOrder!==void 0){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}function T1(u,h,m,y){h=u.memoizedState,m=m(y,h),m=m==null?h:d({},h,m),u.memoizedState=m,u.lanes===0&&(u.updateQueue.baseState=m)}var E1={enqueueSetState:function(u,h,m){u=u._reactInternals;var y=Pr(),S=po(y);S.payload=h,m!=null&&(S.callback=m),h=mo(u,S,y),h!==null&&(Mr(h,u,y),Kd(h,u,y))},enqueueReplaceState:function(u,h,m){u=u._reactInternals;var y=Pr(),S=po(y);S.tag=1,S.payload=h,m!=null&&(S.callback=m),h=mo(u,S,y),h!==null&&(Mr(h,u,y),Kd(h,u,y))},enqueueForceUpdate:function(u,h){u=u._reactInternals;var m=Pr(),y=po(m);y.tag=2,h!=null&&(y.callback=h),h=mo(u,y,m),h!==null&&(Mr(h,u,m),Kd(h,u,m))}};function O$(u,h,m,y,S,k,F){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(y,k,F):h.prototype&&h.prototype.isPureReactComponent?!Md(m,y)||!Md(S,k):!0}function F$(u,h,m,y){u=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(m,y),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(m,y),h.state!==u&&E1.enqueueReplaceState(h,h.state,null)}function Fl(u,h){var m=h;if("ref"in h){m={};for(var y in h)y!=="ref"&&(m[y]=h[y])}if(u=u.defaultProps){m===h&&(m=d({},m));for(var S in u)m[S]===void 0&&(m[S]=u[S])}return m}var Sg=typeof reportError=="function"?reportError:function(u){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var h=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof u=="object"&&u!==null&&typeof u.message=="string"?String(u.message):String(u),error:u});if(!window.dispatchEvent(h))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",u);return}console.error(u)};function z$(u){Sg(u)}function L$(u){console.error(u)}function P$(u){Sg(u)}function Cg(u,h){try{var m=u.onUncaughtError;m(h.value,{componentStack:h.stack})}catch(y){setTimeout(function(){throw y})}}function M$(u,h,m){try{var y=u.onCaughtError;y(m.value,{componentStack:m.stack,errorBoundary:h.tag===1?h.stateNode:null})}catch(S){setTimeout(function(){throw S})}}function R1(u,h,m){return m=po(m),m.tag=3,m.payload={element:null},m.callback=function(){Cg(u,h)},m}function B$(u){return u=po(u),u.tag=3,u}function V$(u,h,m,y){var S=m.type.getDerivedStateFromError;if(typeof S=="function"){var k=y.value;u.payload=function(){return S(k)},u.callback=function(){M$(h,m,y)}}var F=m.stateNode;F!==null&&typeof F.componentDidCatch=="function"&&(u.callback=function(){M$(h,m,y),typeof S!="function"&&($o===null?$o=new Set([this]):$o.add(this));var V=y.stack;this.componentDidCatch(y.value,{componentStack:V!==null?V:""})})}function Az(u,h,m,y,S){if(m.flags|=32768,y!==null&&typeof y=="object"&&typeof y.then=="function"){if(h=m.alternate,h!==null&&Gd(h,m,S,!0),m=si.current,m!==null){switch(m.tag){case 13:return ea===null?ev():m.alternate===null&&An===0&&(An=3),m.flags&=-257,m.flags|=65536,m.lanes=S,y===i1?m.flags|=16384:(h=m.updateQueue,h===null?m.updateQueue=new Set([y]):h.add(y),nv(u,y,S)),!1;case 22:return m.flags|=65536,y===i1?m.flags|=16384:(h=m.updateQueue,h===null?(h={transitions:null,markerInstances:null,retryQueue:new Set([y])},m.updateQueue=h):(m=h.retryQueue,m===null?h.retryQueue=new Set([y]):m.add(y)),nv(u,y,S)),!1}throw Error(s(435,m.tag))}return nv(u,y,S),ev(),!1}if(Wt)return h=si.current,h!==null?((h.flags&65536)===0&&(h.flags|=256),h.flags|=65536,h.lanes=S,y!==Z0&&(u=Error(s(422),{cause:y}),Wd(Jr(u,m)))):(y!==Z0&&(h=Error(s(423),{cause:y}),Wd(Jr(h,m))),u=u.current.alternate,u.flags|=65536,S&=-S,u.lanes|=S,y=Jr(y,m),S=R1(u.stateNode,y,S),l1(u,S),An!==4&&(An=2)),!1;var k=Error(s(520),{cause:y});if(k=Jr(k,m),hf===null?hf=[k]:hf.push(k),An!==4&&(An=2),h===null)return!0;y=Jr(y,m),m=h;do{switch(m.tag){case 3:return m.flags|=65536,u=S&-S,m.lanes|=u,u=R1(m.stateNode,y,u),l1(m,u),!1;case 1:if(h=m.type,k=m.stateNode,(m.flags&128)===0&&(typeof h.getDerivedStateFromError=="function"||k!==null&&typeof k.componentDidCatch=="function"&&($o===null||!$o.has(k))))return m.flags|=65536,S&=-S,m.lanes|=S,S=B$(S),V$(S,u,m,y),l1(m,S),!1}m=m.return}while(m!==null);return!1}var U$=Error(s(461)),gs=!1;function Is(u,h,m,y){h.child=u===null?D$(h,null,m,y):yc(h,u.child,m,y)}function W$(u,h,m,y,S){m=m.render;var k=h.ref;if("ref"in y){var F={};for(var V in y)V!=="ref"&&(F[V]=y[V])}else F=y;return Dl(h),y=f1(u,h,m,F,k,S),V=p1(),u!==null&&!gs?(m1(u,h,S),Oa(u,h,S)):(Wt&&V&&Y0(h),h.flags|=1,Is(u,h,y,S),h.child)}function G$(u,h,m,y,S){if(u===null){var k=m.type;return typeof k=="function"&&!q0(k)&&k.defaultProps===void 0&&m.compare===null?(h.tag=15,h.type=k,H$(u,h,k,y,S)):(u=ng(m.type,null,y,h,h.mode,S),u.ref=h.ref,u.return=h,h.child=u)}if(k=u.child,!P1(u,S)){var F=k.memoizedProps;if(m=m.compare,m=m!==null?m:Md,m(F,y)&&u.ref===h.ref)return Oa(u,h,S)}return h.flags|=1,u=Ia(k,y),u.ref=h.ref,u.return=h,h.child=u}function H$(u,h,m,y,S){if(u!==null){var k=u.memoizedProps;if(Md(k,y)&&u.ref===h.ref)if(gs=!1,h.pendingProps=y=k,P1(u,S))(u.flags&131072)!==0&&(gs=!0);else return h.lanes=u.lanes,Oa(u,h,S)}return A1(u,h,m,y,S)}function j$(u,h,m){var y=h.pendingProps,S=y.children,k=u!==null?u.memoizedState:null;if(y.mode==="hidden"){if((h.flags&128)!==0){if(y=k!==null?k.baseLanes|m:m,u!==null){for(S=h.child=u.child,k=0;S!==null;)k=k|S.lanes|S.childLanes,S=S.sibling;h.childLanes=k&~y}else h.childLanes=0,h.child=null;return q$(u,h,y,m)}if((m&536870912)!==0)h.memoizedState={baseLanes:0,cachePool:null},u!==null&&og(h,k!==null?k.cachePool:null),k!==null?HC(h,k):c1(),_$(h);else return h.lanes=h.childLanes=536870912,q$(u,h,k!==null?k.baseLanes|m:m,m)}else k!==null?(og(h,k.cachePool),HC(h,k),xo(),h.memoizedState=null):(u!==null&&og(h,null),c1(),xo());return Is(u,h,S,m),h.child}function q$(u,h,m,y){var S=r1();return S=S===null?null:{parent:os._currentValue,pool:S},h.memoizedState={baseLanes:m,cachePool:S},u!==null&&og(h,null),c1(),_$(h),u!==null&&Gd(u,h,y,!0),null}function $g(u,h){var m=h.ref;if(m===null)u!==null&&u.ref!==null&&(h.flags|=4194816);else{if(typeof m!="function"&&typeof m!="object")throw Error(s(284));(u===null||u.ref!==m)&&(h.flags|=4194816)}}function A1(u,h,m,y,S){return Dl(h),m=f1(u,h,m,y,void 0,S),y=p1(),u!==null&&!gs?(m1(u,h,S),Oa(u,h,S)):(Wt&&y&&Y0(h),h.flags|=1,Is(u,h,m,S),h.child)}function X$(u,h,m,y,S,k){return Dl(h),h.updateQueue=null,m=qC(h,y,m,S),jC(u),y=p1(),u!==null&&!gs?(m1(u,h,k),Oa(u,h,k)):(Wt&&y&&Y0(h),h.flags|=1,Is(u,h,m,k),h.child)}function K$(u,h,m,y,S){if(Dl(h),h.stateNode===null){var k=oc,F=m.contextType;typeof F=="object"&&F!==null&&(k=Ps(F)),k=new m(y,k),h.memoizedState=k.state!==null&&k.state!==void 0?k.state:null,k.updater=E1,h.stateNode=k,k._reactInternals=h,k=h.stateNode,k.props=y,k.state=h.memoizedState,k.refs={},a1(h),F=m.contextType,k.context=typeof F=="object"&&F!==null?Ps(F):oc,k.state=h.memoizedState,F=m.getDerivedStateFromProps,typeof F=="function"&&(T1(h,m,F,y),k.state=h.memoizedState),typeof m.getDerivedStateFromProps=="function"||typeof k.getSnapshotBeforeUpdate=="function"||typeof k.UNSAFE_componentWillMount!="function"&&typeof k.componentWillMount!="function"||(F=k.state,typeof k.componentWillMount=="function"&&k.componentWillMount(),typeof k.UNSAFE_componentWillMount=="function"&&k.UNSAFE_componentWillMount(),F!==k.state&&E1.enqueueReplaceState(k,k.state,null),Qd(h,y,k,S),Yd(),k.state=h.memoizedState),typeof k.componentDidMount=="function"&&(h.flags|=4194308),y=!0}else if(u===null){k=h.stateNode;var V=h.memoizedProps,Z=Fl(m,V);k.props=Z;var ye=k.context,$e=m.contextType;F=oc,typeof $e=="object"&&$e!==null&&(F=Ps($e));var Te=m.getDerivedStateFromProps;$e=typeof Te=="function"||typeof k.getSnapshotBeforeUpdate=="function",V=h.pendingProps!==V,$e||typeof k.UNSAFE_componentWillReceiveProps!="function"&&typeof k.componentWillReceiveProps!="function"||(V||ye!==F)&&F$(h,k,y,F),fo=!1;var xe=h.memoizedState;k.state=xe,Qd(h,y,k,S),Yd(),ye=h.memoizedState,V||xe!==ye||fo?(typeof Te=="function"&&(T1(h,m,Te,y),ye=h.memoizedState),(Z=fo||O$(h,m,Z,y,xe,ye,F))?($e||typeof k.UNSAFE_componentWillMount!="function"&&typeof k.componentWillMount!="function"||(typeof k.componentWillMount=="function"&&k.componentWillMount(),typeof k.UNSAFE_componentWillMount=="function"&&k.UNSAFE_componentWillMount()),typeof k.componentDidMount=="function"&&(h.flags|=4194308)):(typeof k.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=y,h.memoizedState=ye),k.props=y,k.state=ye,k.context=F,y=Z):(typeof k.componentDidMount=="function"&&(h.flags|=4194308),y=!1)}else{k=h.stateNode,o1(u,h),F=h.memoizedProps,$e=Fl(m,F),k.props=$e,Te=h.pendingProps,xe=k.context,ye=m.contextType,Z=oc,typeof ye=="object"&&ye!==null&&(Z=Ps(ye)),V=m.getDerivedStateFromProps,(ye=typeof V=="function"||typeof k.getSnapshotBeforeUpdate=="function")||typeof k.UNSAFE_componentWillReceiveProps!="function"&&typeof k.componentWillReceiveProps!="function"||(F!==Te||xe!==Z)&&F$(h,k,y,Z),fo=!1,xe=h.memoizedState,k.state=xe,Qd(h,y,k,S),Yd();var ve=h.memoizedState;F!==Te||xe!==ve||fo||u!==null&&u.dependencies!==null&&ig(u.dependencies)?(typeof V=="function"&&(T1(h,m,V,y),ve=h.memoizedState),($e=fo||O$(h,m,$e,y,xe,ve,Z)||u!==null&&u.dependencies!==null&&ig(u.dependencies))?(ye||typeof k.UNSAFE_componentWillUpdate!="function"&&typeof k.componentWillUpdate!="function"||(typeof k.componentWillUpdate=="function"&&k.componentWillUpdate(y,ve,Z),typeof k.UNSAFE_componentWillUpdate=="function"&&k.UNSAFE_componentWillUpdate(y,ve,Z)),typeof k.componentDidUpdate=="function"&&(h.flags|=4),typeof k.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof k.componentDidUpdate!="function"||F===u.memoizedProps&&xe===u.memoizedState||(h.flags|=4),typeof k.getSnapshotBeforeUpdate!="function"||F===u.memoizedProps&&xe===u.memoizedState||(h.flags|=1024),h.memoizedProps=y,h.memoizedState=ve),k.props=y,k.state=ve,k.context=Z,y=$e):(typeof k.componentDidUpdate!="function"||F===u.memoizedProps&&xe===u.memoizedState||(h.flags|=4),typeof k.getSnapshotBeforeUpdate!="function"||F===u.memoizedProps&&xe===u.memoizedState||(h.flags|=1024),y=!1)}return k=y,$g(u,h),y=(h.flags&128)!==0,k||y?(k=h.stateNode,m=y&&typeof m.getDerivedStateFromError!="function"?null:k.render(),h.flags|=1,u!==null&&y?(h.child=yc(h,u.child,null,S),h.child=yc(h,null,m,S)):Is(u,h,m,S),h.memoizedState=k.state,u=h.child):u=Oa(u,h,S),u}function Y$(u,h,m,y){return Ud(),h.flags|=256,Is(u,h,m,y),h.child}var D1={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function _1(u){return{baseLanes:u,cachePool:LC()}}function O1(u,h,m){return u=u!==null?u.childLanes&~m:0,h&&(u|=ri),u}function Q$(u,h,m){var y=h.pendingProps,S=!1,k=(h.flags&128)!==0,F;if((F=k)||(F=u!==null&&u.memoizedState===null?!1:(ls.current&2)!==0),F&&(S=!0,h.flags&=-129),F=(h.flags&32)!==0,h.flags&=-33,u===null){if(Wt){if(S?yo(h):xo(),Wt){var V=Rn,Z;if(Z=V){e:{for(Z=V,V=Ji;Z.nodeType!==8;){if(!V){V=null;break e}if(Z=Ii(Z.nextSibling),Z===null){V=null;break e}}V=Z}V!==null?(h.memoizedState={dehydrated:V,treeContext:Il!==null?{id:Ta,overflow:Ea}:null,retryLane:536870912,hydrationErrors:null},Z=Or(18,null,null,0),Z.stateNode=V,Z.return=h,h.child=Z,tr=h,Rn=null,Z=!0):Z=!1}Z||Rl(h)}if(V=h.memoizedState,V!==null&&(V=V.dehydrated,V!==null))return yv(V)?h.lanes=32:h.lanes=536870912,null;_a(h)}return V=y.children,y=y.fallback,S?(xo(),S=h.mode,V=kg({mode:"hidden",children:V},S),y=Nl(y,S,m,null),V.return=h,y.return=h,V.sibling=y,h.child=V,S=h.child,S.memoizedState=_1(m),S.childLanes=O1(u,F,m),h.memoizedState=D1,y):(yo(h),F1(h,V))}if(Z=u.memoizedState,Z!==null&&(V=Z.dehydrated,V!==null)){if(k)h.flags&256?(yo(h),h.flags&=-257,h=z1(u,h,m)):h.memoizedState!==null?(xo(),h.child=u.child,h.flags|=128,h=null):(xo(),S=y.fallback,V=h.mode,y=kg({mode:"visible",children:y.children},V),S=Nl(S,V,m,null),S.flags|=2,y.return=h,S.return=h,y.sibling=S,h.child=y,yc(h,u.child,null,m),y=h.child,y.memoizedState=_1(m),y.childLanes=O1(u,F,m),h.memoizedState=D1,h=S);else if(yo(h),yv(V)){if(F=V.nextSibling&&V.nextSibling.dataset,F)var ye=F.dgst;F=ye,y=Error(s(419)),y.stack="",y.digest=F,Wd({value:y,source:null,stack:null}),h=z1(u,h,m)}else if(gs||Gd(u,h,m,!1),F=(m&u.childLanes)!==0,gs||F){if(F=dn,F!==null&&(y=m&-m,y=(y&42)!==0?1:cl(y),y=(y&(F.suspendedLanes|m))!==0?0:y,y!==0&&y!==Z.retryLane))throw Z.retryLane=y,ac(u,y),Mr(F,u,y),U$;V.data==="$?"||ev(),h=z1(u,h,m)}else V.data==="$?"?(h.flags|=192,h.child=u.child,h=null):(u=Z.treeContext,Rn=Ii(V.nextSibling),tr=h,Wt=!0,El=null,Ji=!1,u!==null&&(ti[ni++]=Ta,ti[ni++]=Ea,ti[ni++]=Il,Ta=u.id,Ea=u.overflow,Il=h),h=F1(h,y.children),h.flags|=4096);return h}return S?(xo(),S=y.fallback,V=h.mode,Z=u.child,ye=Z.sibling,y=Ia(Z,{mode:"hidden",children:y.children}),y.subtreeFlags=Z.subtreeFlags&65011712,ye!==null?S=Ia(ye,S):(S=Nl(S,V,m,null),S.flags|=2),S.return=h,y.return=h,y.sibling=S,h.child=y,y=S,S=h.child,V=u.child.memoizedState,V===null?V=_1(m):(Z=V.cachePool,Z!==null?(ye=os._currentValue,Z=Z.parent!==ye?{parent:ye,pool:ye}:Z):Z=LC(),V={baseLanes:V.baseLanes|m,cachePool:Z}),S.memoizedState=V,S.childLanes=O1(u,F,m),h.memoizedState=D1,y):(yo(h),m=u.child,u=m.sibling,m=Ia(m,{mode:"visible",children:y.children}),m.return=h,m.sibling=null,u!==null&&(F=h.deletions,F===null?(h.deletions=[u],h.flags|=16):F.push(u)),h.child=m,h.memoizedState=null,m)}function F1(u,h){return h=kg({mode:"visible",children:h},u.mode),h.return=u,u.child=h}function kg(u,h){return u=Or(22,u,null,h),u.lanes=0,u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},u}function z1(u,h,m){return yc(h,u.child,null,m),u=F1(h,h.pendingProps.children),u.flags|=2,h.memoizedState=null,u}function Z$(u,h,m){u.lanes|=h;var y=u.alternate;y!==null&&(y.lanes|=h),e1(u.return,h,m)}function L1(u,h,m,y,S){var k=u.memoizedState;k===null?u.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:y,tail:m,tailMode:S}:(k.isBackwards=h,k.rendering=null,k.renderingStartTime=0,k.last=y,k.tail=m,k.tailMode=S)}function J$(u,h,m){var y=h.pendingProps,S=y.revealOrder,k=y.tail;if(Is(u,h,y.children,m),y=ls.current,(y&2)!==0)y=y&1|2,h.flags|=128;else{if(u!==null&&(u.flags&128)!==0)e:for(u=h.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&Z$(u,m,h);else if(u.tag===19)Z$(u,m,h);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===h)break e;for(;u.sibling===null;){if(u.return===null||u.return===h)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}y&=1}switch(de(ls,y),S){case"forwards":for(m=h.child,S=null;m!==null;)u=m.alternate,u!==null&&wg(u)===null&&(S=m),m=m.sibling;m=S,m===null?(S=h.child,h.child=null):(S=m.sibling,m.sibling=null),L1(h,!1,S,m,k);break;case"backwards":for(m=null,S=h.child,h.child=null;S!==null;){if(u=S.alternate,u!==null&&wg(u)===null){h.child=S;break}u=S.sibling,S.sibling=m,m=S,S=u}L1(h,!0,m,null,k);break;case"together":L1(h,!1,null,null,void 0);break;default:h.memoizedState=null}return h.child}function Oa(u,h,m){if(u!==null&&(h.dependencies=u.dependencies),Co|=h.lanes,(m&h.childLanes)===0)if(u!==null){if(Gd(u,h,m,!1),(m&h.childLanes)===0)return null}else return null;if(u!==null&&h.child!==u.child)throw Error(s(153));if(h.child!==null){for(u=h.child,m=Ia(u,u.pendingProps),h.child=m,m.return=h;u.sibling!==null;)u=u.sibling,m=m.sibling=Ia(u,u.pendingProps),m.return=h;m.sibling=null}return h.child}function P1(u,h){return(u.lanes&h)!==0?!0:(u=u.dependencies,!!(u!==null&&ig(u)))}function Dz(u,h,m){switch(h.tag){case 3:Le(h,h.stateNode.containerInfo),ho(h,os,u.memoizedState.cache),Ud();break;case 27:case 5:at(h);break;case 4:Le(h,h.stateNode.containerInfo);break;case 10:ho(h,h.type,h.memoizedProps.value);break;case 13:var y=h.memoizedState;if(y!==null)return y.dehydrated!==null?(yo(h),h.flags|=128,null):(m&h.child.childLanes)!==0?Q$(u,h,m):(yo(h),u=Oa(u,h,m),u!==null?u.sibling:null);yo(h);break;case 19:var S=(u.flags&128)!==0;if(y=(m&h.childLanes)!==0,y||(Gd(u,h,m,!1),y=(m&h.childLanes)!==0),S){if(y)return J$(u,h,m);h.flags|=128}if(S=h.memoizedState,S!==null&&(S.rendering=null,S.tail=null,S.lastEffect=null),de(ls,ls.current),y)break;return null;case 22:case 23:return h.lanes=0,j$(u,h,m);case 24:ho(h,os,u.memoizedState.cache)}return Oa(u,h,m)}function ek(u,h,m){if(u!==null)if(u.memoizedProps!==h.pendingProps)gs=!0;else{if(!P1(u,m)&&(h.flags&128)===0)return gs=!1,Dz(u,h,m);gs=(u.flags&131072)!==0}else gs=!1,Wt&&(h.flags&1048576)!==0&&RC(h,rg,h.index);switch(h.lanes=0,h.tag){case 16:e:{u=h.pendingProps;var y=h.elementType,S=y._init;if(y=S(y._payload),h.type=y,typeof y=="function")q0(y)?(u=Fl(y,u),h.tag=1,h=K$(null,h,y,u,m)):(h.tag=0,h=A1(null,h,y,u,m));else{if(y!=null){if(S=y.$$typeof,S===N){h.tag=11,h=W$(null,h,y,u,m);break e}else if(S===O){h.tag=14,h=G$(null,h,y,u,m);break e}}throw h=ee(y)||y,Error(s(306,h,""))}}return h;case 0:return A1(u,h,h.type,h.pendingProps,m);case 1:return y=h.type,S=Fl(y,h.pendingProps),K$(u,h,y,S,m);case 3:e:{if(Le(h,h.stateNode.containerInfo),u===null)throw Error(s(387));y=h.pendingProps;var k=h.memoizedState;S=k.element,o1(u,h),Qd(h,y,null,m);var F=h.memoizedState;if(y=F.cache,ho(h,os,y),y!==k.cache&&t1(h,[os],m,!0),Yd(),y=F.element,k.isDehydrated)if(k={element:y,isDehydrated:!1,cache:F.cache},h.updateQueue.baseState=k,h.memoizedState=k,h.flags&256){h=Y$(u,h,y,m);break e}else if(y!==S){S=Jr(Error(s(424)),h),Wd(S),h=Y$(u,h,y,m);break e}else{switch(u=h.stateNode.containerInfo,u.nodeType){case 9:u=u.body;break;default:u=u.nodeName==="HTML"?u.ownerDocument.body:u}for(Rn=Ii(u.firstChild),tr=h,Wt=!0,El=null,Ji=!0,m=D$(h,null,y,m),h.child=m;m;)m.flags=m.flags&-3|4096,m=m.sibling}else{if(Ud(),y===S){h=Oa(u,h,m);break e}Is(u,h,y,m)}h=h.child}return h;case 26:return $g(u,h),u===null?(m=rN(h.type,null,h.pendingProps,null))?h.memoizedState=m:Wt||(m=h.type,u=h.pendingProps,y=Mg(Ne.current).createElement(m),y[wn]=h,y[Fs]=u,Es(y,m,u),Pn(y),h.stateNode=y):h.memoizedState=rN(h.type,u.memoizedProps,h.pendingProps,u.memoizedState),null;case 27:return at(h),u===null&&Wt&&(y=h.stateNode=tN(h.type,h.pendingProps,Ne.current),tr=h,Ji=!0,S=Rn,Io(h.type)?(xv=S,Rn=Ii(y.firstChild)):Rn=S),Is(u,h,h.pendingProps.children,m),$g(u,h),u===null&&(h.flags|=4194304),h.child;case 5:return u===null&&Wt&&((S=y=Rn)&&(y=aL(y,h.type,h.pendingProps,Ji),y!==null?(h.stateNode=y,tr=h,Rn=Ii(y.firstChild),Ji=!1,S=!0):S=!1),S||Rl(h)),at(h),S=h.type,k=h.pendingProps,F=u!==null?u.memoizedProps:null,y=k.children,pv(S,k)?y=null:F!==null&&pv(S,F)&&(h.flags|=32),h.memoizedState!==null&&(S=f1(u,h,$z,null,null,m),vf._currentValue=S),$g(u,h),Is(u,h,y,m),h.child;case 6:return u===null&&Wt&&((u=m=Rn)&&(m=oL(m,h.pendingProps,Ji),m!==null?(h.stateNode=m,tr=h,Rn=null,u=!0):u=!1),u||Rl(h)),null;case 13:return Q$(u,h,m);case 4:return Le(h,h.stateNode.containerInfo),y=h.pendingProps,u===null?h.child=yc(h,null,y,m):Is(u,h,y,m),h.child;case 11:return W$(u,h,h.type,h.pendingProps,m);case 7:return Is(u,h,h.pendingProps,m),h.child;case 8:return Is(u,h,h.pendingProps.children,m),h.child;case 12:return Is(u,h,h.pendingProps.children,m),h.child;case 10:return y=h.pendingProps,ho(h,h.type,y.value),Is(u,h,y.children,m),h.child;case 9:return S=h.type._context,y=h.pendingProps.children,Dl(h),S=Ps(S),y=y(S),h.flags|=1,Is(u,h,y,m),h.child;case 14:return G$(u,h,h.type,h.pendingProps,m);case 15:return H$(u,h,h.type,h.pendingProps,m);case 19:return J$(u,h,m);case 31:return y=h.pendingProps,m=h.mode,y={mode:y.mode,children:y.children},u===null?(m=kg(y,m),m.ref=h.ref,h.child=m,m.return=h,h=m):(m=Ia(u.child,y),m.ref=h.ref,h.child=m,m.return=h,h=m),h;case 22:return j$(u,h,m);case 24:return Dl(h),y=Ps(os),u===null?(S=r1(),S===null&&(S=dn,k=n1(),S.pooledCache=k,k.refCount++,k!==null&&(S.pooledCacheLanes|=m),S=k),h.memoizedState={parent:y,cache:S},a1(h),ho(h,os,S)):((u.lanes&m)!==0&&(o1(u,h),Qd(h,null,null,m),Yd()),S=u.memoizedState,k=h.memoizedState,S.parent!==y?(S={parent:y,cache:y},h.memoizedState=S,h.lanes===0&&(h.memoizedState=h.updateQueue.baseState=S),ho(h,os,y)):(y=k.cache,ho(h,os,y),y!==S.cache&&t1(h,[os],m,!0))),Is(u,h,h.pendingProps.children,m),h.child;case 29:throw h.pendingProps}throw Error(s(156,h.tag))}function Fa(u){u.flags|=4}function tk(u,h){if(h.type!=="stylesheet"||(h.state.loading&4)!==0)u.flags&=-16777217;else if(u.flags|=16777216,!uN(h)){if(h=si.current,h!==null&&((zt&4194048)===zt?ea!==null:(zt&62914560)!==zt&&(zt&536870912)===0||h!==ea))throw Xd=i1,PC;u.flags|=8192}}function Ng(u,h){h!==null&&(u.flags|=4),u.flags&16384&&(h=u.tag!==22?ro():536870912,u.lanes|=h,wc|=h)}function rf(u,h){if(!Wt)switch(u.tailMode){case"hidden":h=u.tail;for(var m=null;h!==null;)h.alternate!==null&&(m=h),h=h.sibling;m===null?u.tail=null:m.sibling=null;break;case"collapsed":m=u.tail;for(var y=null;m!==null;)m.alternate!==null&&(y=m),m=m.sibling;y===null?h||u.tail===null?u.tail=null:u.tail.sibling=null:y.sibling=null}}function Cn(u){var h=u.alternate!==null&&u.alternate.child===u.child,m=0,y=0;if(h)for(var S=u.child;S!==null;)m|=S.lanes|S.childLanes,y|=S.subtreeFlags&65011712,y|=S.flags&65011712,S.return=u,S=S.sibling;else for(S=u.child;S!==null;)m|=S.lanes|S.childLanes,y|=S.subtreeFlags,y|=S.flags,S.return=u,S=S.sibling;return u.subtreeFlags|=y,u.childLanes=m,h}function _z(u,h,m){var y=h.pendingProps;switch(Q0(h),h.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Cn(h),null;case 1:return Cn(h),null;case 3:return m=h.stateNode,y=null,u!==null&&(y=u.memoizedState.cache),h.memoizedState.cache!==y&&(h.flags|=2048),Aa(os),Ge(),m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null),(u===null||u.child===null)&&(Vd(h)?Fa(h):u===null||u.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,_C())),Cn(h),null;case 26:return m=h.memoizedState,u===null?(Fa(h),m!==null?(Cn(h),tk(h,m)):(Cn(h),h.flags&=-16777217)):m?m!==u.memoizedState?(Fa(h),Cn(h),tk(h,m)):(Cn(h),h.flags&=-16777217):(u.memoizedProps!==y&&Fa(h),Cn(h),h.flags&=-16777217),null;case 27:nt(h),m=Ne.current;var S=h.type;if(u!==null&&h.stateNode!=null)u.memoizedProps!==y&&Fa(h);else{if(!y){if(h.stateNode===null)throw Error(s(166));return Cn(h),null}u=we.current,Vd(h)?AC(h):(u=tN(S,y,m),h.stateNode=u,Fa(h))}return Cn(h),null;case 5:if(nt(h),m=h.type,u!==null&&h.stateNode!=null)u.memoizedProps!==y&&Fa(h);else{if(!y){if(h.stateNode===null)throw Error(s(166));return Cn(h),null}if(u=we.current,Vd(h))AC(h);else{switch(S=Mg(Ne.current),u){case 1:u=S.createElementNS("http://www.w3.org/2000/svg",m);break;case 2:u=S.createElementNS("http://www.w3.org/1998/Math/MathML",m);break;default:switch(m){case"svg":u=S.createElementNS("http://www.w3.org/2000/svg",m);break;case"math":u=S.createElementNS("http://www.w3.org/1998/Math/MathML",m);break;case"script":u=S.createElement("div"),u.innerHTML="<script><\/script>",u=u.removeChild(u.firstChild);break;case"select":u=typeof y.is=="string"?S.createElement("select",{is:y.is}):S.createElement("select"),y.multiple?u.multiple=!0:y.size&&(u.size=y.size);break;default:u=typeof y.is=="string"?S.createElement(m,{is:y.is}):S.createElement(m)}}u[wn]=h,u[Fs]=y;e:for(S=h.child;S!==null;){if(S.tag===5||S.tag===6)u.appendChild(S.stateNode);else if(S.tag!==4&&S.tag!==27&&S.child!==null){S.child.return=S,S=S.child;continue}if(S===h)break e;for(;S.sibling===null;){if(S.return===null||S.return===h)break e;S=S.return}S.sibling.return=S.return,S=S.sibling}h.stateNode=u;e:switch(Es(u,m,y),m){case"button":case"input":case"select":case"textarea":u=!!y.autoFocus;break e;case"img":u=!0;break e;default:u=!1}u&&Fa(h)}}return Cn(h),h.flags&=-16777217,null;case 6:if(u&&h.stateNode!=null)u.memoizedProps!==y&&Fa(h);else{if(typeof y!="string"&&h.stateNode===null)throw Error(s(166));if(u=Ne.current,Vd(h)){if(u=h.stateNode,m=h.memoizedProps,y=null,S=tr,S!==null)switch(S.tag){case 27:case 5:y=S.memoizedProps}u[wn]=h,u=!!(u.nodeValue===m||y!==null&&y.suppressHydrationWarning===!0||Xk(u.nodeValue,m)),u||Rl(h)}else u=Mg(u).createTextNode(y),u[wn]=h,h.stateNode=u}return Cn(h),null;case 13:if(y=h.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(S=Vd(h),y!==null&&y.dehydrated!==null){if(u===null){if(!S)throw Error(s(318));if(S=h.memoizedState,S=S!==null?S.dehydrated:null,!S)throw Error(s(317));S[wn]=h}else Ud(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;Cn(h),S=!1}else S=_C(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=S),S=!0;if(!S)return h.flags&256?(_a(h),h):(_a(h),null)}if(_a(h),(h.flags&128)!==0)return h.lanes=m,h;if(m=y!==null,u=u!==null&&u.memoizedState!==null,m){y=h.child,S=null,y.alternate!==null&&y.alternate.memoizedState!==null&&y.alternate.memoizedState.cachePool!==null&&(S=y.alternate.memoizedState.cachePool.pool);var k=null;y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(k=y.memoizedState.cachePool.pool),k!==S&&(y.flags|=2048)}return m!==u&&m&&(h.child.flags|=8192),Ng(h,h.updateQueue),Cn(h),null;case 4:return Ge(),u===null&&uv(h.stateNode.containerInfo),Cn(h),null;case 10:return Aa(h.type),Cn(h),null;case 19:if(pe(ls),S=h.memoizedState,S===null)return Cn(h),null;if(y=(h.flags&128)!==0,k=S.rendering,k===null)if(y)rf(S,!1);else{if(An!==0||u!==null&&(u.flags&128)!==0)for(u=h.child;u!==null;){if(k=wg(u),k!==null){for(h.flags|=128,rf(S,!1),u=k.updateQueue,h.updateQueue=u,Ng(h,u),h.subtreeFlags=0,u=m,m=h.child;m!==null;)EC(m,u),m=m.sibling;return de(ls,ls.current&1|2),h.child}u=u.sibling}S.tail!==null&&$t()>Eg&&(h.flags|=128,y=!0,rf(S,!1),h.lanes=4194304)}else{if(!y)if(u=wg(k),u!==null){if(h.flags|=128,y=!0,u=u.updateQueue,h.updateQueue=u,Ng(h,u),rf(S,!0),S.tail===null&&S.tailMode==="hidden"&&!k.alternate&&!Wt)return Cn(h),null}else 2*$t()-S.renderingStartTime>Eg&&m!==536870912&&(h.flags|=128,y=!0,rf(S,!1),h.lanes=4194304);S.isBackwards?(k.sibling=h.child,h.child=k):(u=S.last,u!==null?u.sibling=k:h.child=k,S.last=k)}return S.tail!==null?(h=S.tail,S.rendering=h,S.tail=h.sibling,S.renderingStartTime=$t(),h.sibling=null,u=ls.current,de(ls,y?u&1|2:u&1),h):(Cn(h),null);case 22:case 23:return _a(h),h1(),y=h.memoizedState!==null,u!==null?u.memoizedState!==null!==y&&(h.flags|=8192):y&&(h.flags|=8192),y?(m&536870912)!==0&&(h.flags&128)===0&&(Cn(h),h.subtreeFlags&6&&(h.flags|=8192)):Cn(h),m=h.updateQueue,m!==null&&Ng(h,m.retryQueue),m=null,u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(m=u.memoizedState.cachePool.pool),y=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(y=h.memoizedState.cachePool.pool),y!==m&&(h.flags|=2048),u!==null&&pe(_l),null;case 24:return m=null,u!==null&&(m=u.memoizedState.cache),h.memoizedState.cache!==m&&(h.flags|=2048),Aa(os),Cn(h),null;case 25:return null;case 30:return null}throw Error(s(156,h.tag))}function Oz(u,h){switch(Q0(h),h.tag){case 1:return u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 3:return Aa(os),Ge(),u=h.flags,(u&65536)!==0&&(u&128)===0?(h.flags=u&-65537|128,h):null;case 26:case 27:case 5:return nt(h),null;case 13:if(_a(h),u=h.memoizedState,u!==null&&u.dehydrated!==null){if(h.alternate===null)throw Error(s(340));Ud()}return u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 19:return pe(ls),null;case 4:return Ge(),null;case 10:return Aa(h.type),null;case 22:case 23:return _a(h),h1(),u!==null&&pe(_l),u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 24:return Aa(os),null;case 25:return null;default:return null}}function nk(u,h){switch(Q0(h),h.tag){case 3:Aa(os),Ge();break;case 26:case 27:case 5:nt(h);break;case 4:Ge();break;case 13:_a(h);break;case 19:pe(ls);break;case 10:Aa(h.type);break;case 22:case 23:_a(h),h1(),u!==null&&pe(_l);break;case 24:Aa(os)}}function af(u,h){try{var m=h.updateQueue,y=m!==null?m.lastEffect:null;if(y!==null){var S=y.next;m=S;do{if((m.tag&u)===u){y=void 0;var k=m.create,F=m.inst;y=k(),F.destroy=y}m=m.next}while(m!==S)}}catch(V){an(h,h.return,V)}}function bo(u,h,m){try{var y=h.updateQueue,S=y!==null?y.lastEffect:null;if(S!==null){var k=S.next;y=k;do{if((y.tag&u)===u){var F=y.inst,V=F.destroy;if(V!==void 0){F.destroy=void 0,S=h;var Z=m,ye=V;try{ye()}catch($e){an(S,Z,$e)}}}y=y.next}while(y!==k)}}catch($e){an(h,h.return,$e)}}function sk(u){var h=u.updateQueue;if(h!==null){var m=u.stateNode;try{GC(h,m)}catch(y){an(u,u.return,y)}}}function rk(u,h,m){m.props=Fl(u.type,u.memoizedProps),m.state=u.memoizedState;try{m.componentWillUnmount()}catch(y){an(u,h,y)}}function of(u,h){try{var m=u.ref;if(m!==null){switch(u.tag){case 26:case 27:case 5:var y=u.stateNode;break;case 30:y=u.stateNode;break;default:y=u.stateNode}typeof m=="function"?u.refCleanup=m(y):m.current=y}}catch(S){an(u,h,S)}}function ta(u,h){var m=u.ref,y=u.refCleanup;if(m!==null)if(typeof y=="function")try{y()}catch(S){an(u,h,S)}finally{u.refCleanup=null,u=u.alternate,u!=null&&(u.refCleanup=null)}else if(typeof m=="function")try{m(null)}catch(S){an(u,h,S)}else m.current=null}function ik(u){var h=u.type,m=u.memoizedProps,y=u.stateNode;try{e:switch(h){case"button":case"input":case"select":case"textarea":m.autoFocus&&y.focus();break e;case"img":m.src?y.src=m.src:m.srcSet&&(y.srcset=m.srcSet)}}catch(S){an(u,u.return,S)}}function M1(u,h,m){try{var y=u.stateNode;tL(y,u.type,m,h),y[Fs]=h}catch(S){an(u,u.return,S)}}function ak(u){return u.tag===5||u.tag===3||u.tag===26||u.tag===27&&Io(u.type)||u.tag===4}function B1(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||ak(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.tag===27&&Io(u.type)||u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function V1(u,h,m){var y=u.tag;if(y===5||y===6)u=u.stateNode,h?(m.nodeType===9?m.body:m.nodeName==="HTML"?m.ownerDocument.body:m).insertBefore(u,h):(h=m.nodeType===9?m.body:m.nodeName==="HTML"?m.ownerDocument.body:m,h.appendChild(u),m=m._reactRootContainer,m!=null||h.onclick!==null||(h.onclick=Pg));else if(y!==4&&(y===27&&Io(u.type)&&(m=u.stateNode,h=null),u=u.child,u!==null))for(V1(u,h,m),u=u.sibling;u!==null;)V1(u,h,m),u=u.sibling}function Ig(u,h,m){var y=u.tag;if(y===5||y===6)u=u.stateNode,h?m.insertBefore(u,h):m.appendChild(u);else if(y!==4&&(y===27&&Io(u.type)&&(m=u.stateNode),u=u.child,u!==null))for(Ig(u,h,m),u=u.sibling;u!==null;)Ig(u,h,m),u=u.sibling}function ok(u){var h=u.stateNode,m=u.memoizedProps;try{for(var y=u.type,S=h.attributes;S.length;)h.removeAttributeNode(S[0]);Es(h,y,m),h[wn]=u,h[Fs]=m}catch(k){an(u,u.return,k)}}var za=!1,Vn=!1,U1=!1,lk=typeof WeakSet=="function"?WeakSet:Set,ys=null;function Fz(u,h){if(u=u.containerInfo,dv=Hg,u=bC(u),B0(u)){if("selectionStart"in u)var m={start:u.selectionStart,end:u.selectionEnd};else e:{m=(m=u.ownerDocument)&&m.defaultView||window;var y=m.getSelection&&m.getSelection();if(y&&y.rangeCount!==0){m=y.anchorNode;var S=y.anchorOffset,k=y.focusNode;y=y.focusOffset;try{m.nodeType,k.nodeType}catch{m=null;break e}var F=0,V=-1,Z=-1,ye=0,$e=0,Te=u,xe=null;t:for(;;){for(var ve;Te!==m||S!==0&&Te.nodeType!==3||(V=F+S),Te!==k||y!==0&&Te.nodeType!==3||(Z=F+y),Te.nodeType===3&&(F+=Te.nodeValue.length),(ve=Te.firstChild)!==null;)xe=Te,Te=ve;for(;;){if(Te===u)break t;if(xe===m&&++ye===S&&(V=F),xe===k&&++$e===y&&(Z=F),(ve=Te.nextSibling)!==null)break;Te=xe,xe=Te.parentNode}Te=ve}m=V===-1||Z===-1?null:{start:V,end:Z}}else m=null}m=m||{start:0,end:0}}else m=null;for(fv={focusedElem:u,selectionRange:m},Hg=!1,ys=h;ys!==null;)if(h=ys,u=h.child,(h.subtreeFlags&1024)!==0&&u!==null)u.return=h,ys=u;else for(;ys!==null;){switch(h=ys,k=h.alternate,u=h.flags,h.tag){case 0:break;case 11:case 15:break;case 1:if((u&1024)!==0&&k!==null){u=void 0,m=h,S=k.memoizedProps,k=k.memoizedState,y=m.stateNode;try{var dt=Fl(m.type,S,m.elementType===m.type);u=y.getSnapshotBeforeUpdate(dt,k),y.__reactInternalSnapshotBeforeUpdate=u}catch(it){an(m,m.return,it)}}break;case 3:if((u&1024)!==0){if(u=h.stateNode.containerInfo,m=u.nodeType,m===9)gv(u);else if(m===1)switch(u.nodeName){case"HEAD":case"HTML":case"BODY":gv(u);break;default:u.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((u&1024)!==0)throw Error(s(163))}if(u=h.sibling,u!==null){u.return=h.return,ys=u;break}ys=h.return}}function uk(u,h,m){var y=m.flags;switch(m.tag){case 0:case 11:case 15:vo(u,m),y&4&&af(5,m);break;case 1:if(vo(u,m),y&4)if(u=m.stateNode,h===null)try{u.componentDidMount()}catch(F){an(m,m.return,F)}else{var S=Fl(m.type,h.memoizedProps);h=h.memoizedState;try{u.componentDidUpdate(S,h,u.__reactInternalSnapshotBeforeUpdate)}catch(F){an(m,m.return,F)}}y&64&&sk(m),y&512&&of(m,m.return);break;case 3:if(vo(u,m),y&64&&(u=m.updateQueue,u!==null)){if(h=null,m.child!==null)switch(m.child.tag){case 27:case 5:h=m.child.stateNode;break;case 1:h=m.child.stateNode}try{GC(u,h)}catch(F){an(m,m.return,F)}}break;case 27:h===null&&y&4&&ok(m);case 26:case 5:vo(u,m),h===null&&y&4&&ik(m),y&512&&of(m,m.return);break;case 12:vo(u,m);break;case 13:vo(u,m),y&4&&dk(u,m),y&64&&(u=m.memoizedState,u!==null&&(u=u.dehydrated,u!==null&&(m=Gz.bind(null,m),lL(u,m))));break;case 22:if(y=m.memoizedState!==null||za,!y){h=h!==null&&h.memoizedState!==null||Vn,S=za;var k=Vn;za=y,(Vn=h)&&!k?wo(u,m,(m.subtreeFlags&8772)!==0):vo(u,m),za=S,Vn=k}break;case 30:break;default:vo(u,m)}}function ck(u){var h=u.alternate;h!==null&&(u.alternate=null,ck(h)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(h=u.stateNode,h!==null&&kd(h)),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}var yn=null,gr=!1;function La(u,h,m){for(m=m.child;m!==null;)hk(u,h,m),m=m.sibling}function hk(u,h,m){if(hn&&typeof hn.onCommitFiberUnmount=="function")try{hn.onCommitFiberUnmount(is,m)}catch{}switch(m.tag){case 26:Vn||ta(m,h),La(u,h,m),m.memoizedState?m.memoizedState.count--:m.stateNode&&(m=m.stateNode,m.parentNode.removeChild(m));break;case 27:Vn||ta(m,h);var y=yn,S=gr;Io(m.type)&&(yn=m.stateNode,gr=!1),La(u,h,m),gf(m.stateNode),yn=y,gr=S;break;case 5:Vn||ta(m,h);case 6:if(y=yn,S=gr,yn=null,La(u,h,m),yn=y,gr=S,yn!==null)if(gr)try{(yn.nodeType===9?yn.body:yn.nodeName==="HTML"?yn.ownerDocument.body:yn).removeChild(m.stateNode)}catch(k){an(m,h,k)}else try{yn.removeChild(m.stateNode)}catch(k){an(m,h,k)}break;case 18:yn!==null&&(gr?(u=yn,Jk(u.nodeType===9?u.body:u.nodeName==="HTML"?u.ownerDocument.body:u,m.stateNode),$f(u)):Jk(yn,m.stateNode));break;case 4:y=yn,S=gr,yn=m.stateNode.containerInfo,gr=!0,La(u,h,m),yn=y,gr=S;break;case 0:case 11:case 14:case 15:Vn||bo(2,m,h),Vn||bo(4,m,h),La(u,h,m);break;case 1:Vn||(ta(m,h),y=m.stateNode,typeof y.componentWillUnmount=="function"&&rk(m,h,y)),La(u,h,m);break;case 21:La(u,h,m);break;case 22:Vn=(y=Vn)||m.memoizedState!==null,La(u,h,m),Vn=y;break;default:La(u,h,m)}}function dk(u,h){if(h.memoizedState===null&&(u=h.alternate,u!==null&&(u=u.memoizedState,u!==null&&(u=u.dehydrated,u!==null))))try{$f(u)}catch(m){an(h,h.return,m)}}function zz(u){switch(u.tag){case 13:case 19:var h=u.stateNode;return h===null&&(h=u.stateNode=new lk),h;case 22:return u=u.stateNode,h=u._retryCache,h===null&&(h=u._retryCache=new lk),h;default:throw Error(s(435,u.tag))}}function W1(u,h){var m=zz(u);h.forEach(function(y){var S=Hz.bind(null,u,y);m.has(y)||(m.add(y),y.then(S,S))})}function Fr(u,h){var m=h.deletions;if(m!==null)for(var y=0;y<m.length;y++){var S=m[y],k=u,F=h,V=F;e:for(;V!==null;){switch(V.tag){case 27:if(Io(V.type)){yn=V.stateNode,gr=!1;break e}break;case 5:yn=V.stateNode,gr=!1;break e;case 3:case 4:yn=V.stateNode.containerInfo,gr=!0;break e}V=V.return}if(yn===null)throw Error(s(160));hk(k,F,S),yn=null,gr=!1,k=S.alternate,k!==null&&(k.return=null),S.return=null}if(h.subtreeFlags&13878)for(h=h.child;h!==null;)fk(h,u),h=h.sibling}var Ni=null;function fk(u,h){var m=u.alternate,y=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:Fr(h,u),zr(u),y&4&&(bo(3,u,u.return),af(3,u),bo(5,u,u.return));break;case 1:Fr(h,u),zr(u),y&512&&(Vn||m===null||ta(m,m.return)),y&64&&za&&(u=u.updateQueue,u!==null&&(y=u.callbacks,y!==null&&(m=u.shared.hiddenCallbacks,u.shared.hiddenCallbacks=m===null?y:m.concat(y))));break;case 26:var S=Ni;if(Fr(h,u),zr(u),y&512&&(Vn||m===null||ta(m,m.return)),y&4){var k=m!==null?m.memoizedState:null;if(y=u.memoizedState,m===null)if(y===null)if(u.stateNode===null){e:{y=u.type,m=u.memoizedProps,S=S.ownerDocument||S;t:switch(y){case"title":k=S.getElementsByTagName("title")[0],(!k||k[Sa]||k[wn]||k.namespaceURI==="http://www.w3.org/2000/svg"||k.hasAttribute("itemprop"))&&(k=S.createElement(y),S.head.insertBefore(k,S.querySelector("head > title"))),Es(k,y,m),k[wn]=u,Pn(k),y=k;break e;case"link":var F=oN("link","href",S).get(y+(m.href||""));if(F){for(var V=0;V<F.length;V++)if(k=F[V],k.getAttribute("href")===(m.href==null||m.href===""?null:m.href)&&k.getAttribute("rel")===(m.rel==null?null:m.rel)&&k.getAttribute("title")===(m.title==null?null:m.title)&&k.getAttribute("crossorigin")===(m.crossOrigin==null?null:m.crossOrigin)){F.splice(V,1);break t}}k=S.createElement(y),Es(k,y,m),S.head.appendChild(k);break;case"meta":if(F=oN("meta","content",S).get(y+(m.content||""))){for(V=0;V<F.length;V++)if(k=F[V],k.getAttribute("content")===(m.content==null?null:""+m.content)&&k.getAttribute("name")===(m.name==null?null:m.name)&&k.getAttribute("property")===(m.property==null?null:m.property)&&k.getAttribute("http-equiv")===(m.httpEquiv==null?null:m.httpEquiv)&&k.getAttribute("charset")===(m.charSet==null?null:m.charSet)){F.splice(V,1);break t}}k=S.createElement(y),Es(k,y,m),S.head.appendChild(k);break;default:throw Error(s(468,y))}k[wn]=u,Pn(k),y=k}u.stateNode=y}else lN(S,u.type,u.stateNode);else u.stateNode=aN(S,y,u.memoizedProps);else k!==y?(k===null?m.stateNode!==null&&(m=m.stateNode,m.parentNode.removeChild(m)):k.count--,y===null?lN(S,u.type,u.stateNode):aN(S,y,u.memoizedProps)):y===null&&u.stateNode!==null&&M1(u,u.memoizedProps,m.memoizedProps)}break;case 27:Fr(h,u),zr(u),y&512&&(Vn||m===null||ta(m,m.return)),m!==null&&y&4&&M1(u,u.memoizedProps,m.memoizedProps);break;case 5:if(Fr(h,u),zr(u),y&512&&(Vn||m===null||ta(m,m.return)),u.flags&32){S=u.stateNode;try{$a(S,"")}catch(ve){an(u,u.return,ve)}}y&4&&u.stateNode!=null&&(S=u.memoizedProps,M1(u,S,m!==null?m.memoizedProps:S)),y&1024&&(U1=!0);break;case 6:if(Fr(h,u),zr(u),y&4){if(u.stateNode===null)throw Error(s(162));y=u.memoizedProps,m=u.stateNode;try{m.nodeValue=y}catch(ve){an(u,u.return,ve)}}break;case 3:if(Ug=null,S=Ni,Ni=Bg(h.containerInfo),Fr(h,u),Ni=S,zr(u),y&4&&m!==null&&m.memoizedState.isDehydrated)try{$f(h.containerInfo)}catch(ve){an(u,u.return,ve)}U1&&(U1=!1,pk(u));break;case 4:y=Ni,Ni=Bg(u.stateNode.containerInfo),Fr(h,u),zr(u),Ni=y;break;case 12:Fr(h,u),zr(u);break;case 13:Fr(h,u),zr(u),u.child.flags&8192&&u.memoizedState!==null!=(m!==null&&m.memoizedState!==null)&&(K1=$t()),y&4&&(y=u.updateQueue,y!==null&&(u.updateQueue=null,W1(u,y)));break;case 22:S=u.memoizedState!==null;var Z=m!==null&&m.memoizedState!==null,ye=za,$e=Vn;if(za=ye||S,Vn=$e||Z,Fr(h,u),Vn=$e,za=ye,zr(u),y&8192)e:for(h=u.stateNode,h._visibility=S?h._visibility&-2:h._visibility|1,S&&(m===null||Z||za||Vn||zl(u)),m=null,h=u;;){if(h.tag===5||h.tag===26){if(m===null){Z=m=h;try{if(k=Z.stateNode,S)F=k.style,typeof F.setProperty=="function"?F.setProperty("display","none","important"):F.display="none";else{V=Z.stateNode;var Te=Z.memoizedProps.style,xe=Te!=null&&Te.hasOwnProperty("display")?Te.display:null;V.style.display=xe==null||typeof xe=="boolean"?"":(""+xe).trim()}}catch(ve){an(Z,Z.return,ve)}}}else if(h.tag===6){if(m===null){Z=h;try{Z.stateNode.nodeValue=S?"":Z.memoizedProps}catch(ve){an(Z,Z.return,ve)}}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===u)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===u)break e;for(;h.sibling===null;){if(h.return===null||h.return===u)break e;m===h&&(m=null),h=h.return}m===h&&(m=null),h.sibling.return=h.return,h=h.sibling}y&4&&(y=u.updateQueue,y!==null&&(m=y.retryQueue,m!==null&&(y.retryQueue=null,W1(u,m))));break;case 19:Fr(h,u),zr(u),y&4&&(y=u.updateQueue,y!==null&&(u.updateQueue=null,W1(u,y)));break;case 30:break;case 21:break;default:Fr(h,u),zr(u)}}function zr(u){var h=u.flags;if(h&2){try{for(var m,y=u.return;y!==null;){if(ak(y)){m=y;break}y=y.return}if(m==null)throw Error(s(160));switch(m.tag){case 27:var S=m.stateNode,k=B1(u);Ig(u,k,S);break;case 5:var F=m.stateNode;m.flags&32&&($a(F,""),m.flags&=-33);var V=B1(u);Ig(u,V,F);break;case 3:case 4:var Z=m.stateNode.containerInfo,ye=B1(u);V1(u,ye,Z);break;default:throw Error(s(161))}}catch($e){an(u,u.return,$e)}u.flags&=-3}h&4096&&(u.flags&=-4097)}function pk(u){if(u.subtreeFlags&1024)for(u=u.child;u!==null;){var h=u;pk(h),h.tag===5&&h.flags&1024&&h.stateNode.reset(),u=u.sibling}}function vo(u,h){if(h.subtreeFlags&8772)for(h=h.child;h!==null;)uk(u,h.alternate,h),h=h.sibling}function zl(u){for(u=u.child;u!==null;){var h=u;switch(h.tag){case 0:case 11:case 14:case 15:bo(4,h,h.return),zl(h);break;case 1:ta(h,h.return);var m=h.stateNode;typeof m.componentWillUnmount=="function"&&rk(h,h.return,m),zl(h);break;case 27:gf(h.stateNode);case 26:case 5:ta(h,h.return),zl(h);break;case 22:h.memoizedState===null&&zl(h);break;case 30:zl(h);break;default:zl(h)}u=u.sibling}}function wo(u,h,m){for(m=m&&(h.subtreeFlags&8772)!==0,h=h.child;h!==null;){var y=h.alternate,S=u,k=h,F=k.flags;switch(k.tag){case 0:case 11:case 15:wo(S,k,m),af(4,k);break;case 1:if(wo(S,k,m),y=k,S=y.stateNode,typeof S.componentDidMount=="function")try{S.componentDidMount()}catch(ye){an(y,y.return,ye)}if(y=k,S=y.updateQueue,S!==null){var V=y.stateNode;try{var Z=S.shared.hiddenCallbacks;if(Z!==null)for(S.shared.hiddenCallbacks=null,S=0;S<Z.length;S++)WC(Z[S],V)}catch(ye){an(y,y.return,ye)}}m&&F&64&&sk(k),of(k,k.return);break;case 27:ok(k);case 26:case 5:wo(S,k,m),m&&y===null&&F&4&&ik(k),of(k,k.return);break;case 12:wo(S,k,m);break;case 13:wo(S,k,m),m&&F&4&&dk(S,k);break;case 22:k.memoizedState===null&&wo(S,k,m),of(k,k.return);break;case 30:break;default:wo(S,k,m)}h=h.sibling}}function G1(u,h){var m=null;u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(m=u.memoizedState.cachePool.pool),u=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(u=h.memoizedState.cachePool.pool),u!==m&&(u!=null&&u.refCount++,m!=null&&Hd(m))}function H1(u,h){u=null,h.alternate!==null&&(u=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==u&&(h.refCount++,u!=null&&Hd(u))}function na(u,h,m,y){if(h.subtreeFlags&10256)for(h=h.child;h!==null;)mk(u,h,m,y),h=h.sibling}function mk(u,h,m,y){var S=h.flags;switch(h.tag){case 0:case 11:case 15:na(u,h,m,y),S&2048&&af(9,h);break;case 1:na(u,h,m,y);break;case 3:na(u,h,m,y),S&2048&&(u=null,h.alternate!==null&&(u=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==u&&(h.refCount++,u!=null&&Hd(u)));break;case 12:if(S&2048){na(u,h,m,y),u=h.stateNode;try{var k=h.memoizedProps,F=k.id,V=k.onPostCommit;typeof V=="function"&&V(F,h.alternate===null?"mount":"update",u.passiveEffectDuration,-0)}catch(Z){an(h,h.return,Z)}}else na(u,h,m,y);break;case 13:na(u,h,m,y);break;case 23:break;case 22:k=h.stateNode,F=h.alternate,h.memoizedState!==null?k._visibility&2?na(u,h,m,y):lf(u,h):k._visibility&2?na(u,h,m,y):(k._visibility|=2,xc(u,h,m,y,(h.subtreeFlags&10256)!==0)),S&2048&&G1(F,h);break;case 24:na(u,h,m,y),S&2048&&H1(h.alternate,h);break;default:na(u,h,m,y)}}function xc(u,h,m,y,S){for(S=S&&(h.subtreeFlags&10256)!==0,h=h.child;h!==null;){var k=u,F=h,V=m,Z=y,ye=F.flags;switch(F.tag){case 0:case 11:case 15:xc(k,F,V,Z,S),af(8,F);break;case 23:break;case 22:var $e=F.stateNode;F.memoizedState!==null?$e._visibility&2?xc(k,F,V,Z,S):lf(k,F):($e._visibility|=2,xc(k,F,V,Z,S)),S&&ye&2048&&G1(F.alternate,F);break;case 24:xc(k,F,V,Z,S),S&&ye&2048&&H1(F.alternate,F);break;default:xc(k,F,V,Z,S)}h=h.sibling}}function lf(u,h){if(h.subtreeFlags&10256)for(h=h.child;h!==null;){var m=u,y=h,S=y.flags;switch(y.tag){case 22:lf(m,y),S&2048&&G1(y.alternate,y);break;case 24:lf(m,y),S&2048&&H1(y.alternate,y);break;default:lf(m,y)}h=h.sibling}}var uf=8192;function bc(u){if(u.subtreeFlags&uf)for(u=u.child;u!==null;)gk(u),u=u.sibling}function gk(u){switch(u.tag){case 26:bc(u),u.flags&uf&&u.memoizedState!==null&&wL(Ni,u.memoizedState,u.memoizedProps);break;case 5:bc(u);break;case 3:case 4:var h=Ni;Ni=Bg(u.stateNode.containerInfo),bc(u),Ni=h;break;case 22:u.memoizedState===null&&(h=u.alternate,h!==null&&h.memoizedState!==null?(h=uf,uf=16777216,bc(u),uf=h):bc(u));break;default:bc(u)}}function yk(u){var h=u.alternate;if(h!==null&&(u=h.child,u!==null)){h.child=null;do h=u.sibling,u.sibling=null,u=h;while(u!==null)}}function cf(u){var h=u.deletions;if((u.flags&16)!==0){if(h!==null)for(var m=0;m<h.length;m++){var y=h[m];ys=y,bk(y,u)}yk(u)}if(u.subtreeFlags&10256)for(u=u.child;u!==null;)xk(u),u=u.sibling}function xk(u){switch(u.tag){case 0:case 11:case 15:cf(u),u.flags&2048&&bo(9,u,u.return);break;case 3:cf(u);break;case 12:cf(u);break;case 22:var h=u.stateNode;u.memoizedState!==null&&h._visibility&2&&(u.return===null||u.return.tag!==13)?(h._visibility&=-3,Tg(u)):cf(u);break;default:cf(u)}}function Tg(u){var h=u.deletions;if((u.flags&16)!==0){if(h!==null)for(var m=0;m<h.length;m++){var y=h[m];ys=y,bk(y,u)}yk(u)}for(u=u.child;u!==null;){switch(h=u,h.tag){case 0:case 11:case 15:bo(8,h,h.return),Tg(h);break;case 22:m=h.stateNode,m._visibility&2&&(m._visibility&=-3,Tg(h));break;default:Tg(h)}u=u.sibling}}function bk(u,h){for(;ys!==null;){var m=ys;switch(m.tag){case 0:case 11:case 15:bo(8,m,h);break;case 23:case 22:if(m.memoizedState!==null&&m.memoizedState.cachePool!==null){var y=m.memoizedState.cachePool.pool;y!=null&&y.refCount++}break;case 24:Hd(m.memoizedState.cache)}if(y=m.child,y!==null)y.return=m,ys=y;else e:for(m=u;ys!==null;){y=ys;var S=y.sibling,k=y.return;if(ck(y),y===m){ys=null;break e}if(S!==null){S.return=k,ys=S;break e}ys=k}}}var Lz={getCacheForType:function(u){var h=Ps(os),m=h.data.get(u);return m===void 0&&(m=u(),h.data.set(u,m)),m}},Pz=typeof WeakMap=="function"?WeakMap:Map,Xt=0,dn=null,Nt=null,zt=0,Kt=0,Lr=null,So=!1,vc=!1,j1=!1,Pa=0,An=0,Co=0,Ll=0,q1=0,ri=0,wc=0,hf=null,yr=null,X1=!1,K1=0,Eg=1/0,Rg=null,$o=null,Ts=0,ko=null,Sc=null,Cc=0,Y1=0,Q1=null,vk=null,df=0,Z1=null;function Pr(){if((Xt&2)!==0&&zt!==0)return zt&-zt;if(G.T!==null){var u=cc;return u!==0?u:iv()}return hl()}function wk(){ri===0&&(ri=(zt&536870912)===0||Wt?ji():536870912);var u=si.current;return u!==null&&(u.flags|=32),ri}function Mr(u,h,m){(u===dn&&(Kt===2||Kt===9)||u.cancelPendingCommit!==null)&&($c(u,0),No(u,zt,ri,!1)),io(u,m),((Xt&2)===0||u!==dn)&&(u===dn&&((Xt&2)===0&&(Ll|=m),An===4&&No(u,zt,ri,!1)),sa(u))}function Sk(u,h,m){if((Xt&6)!==0)throw Error(s(327));var y=!m&&(h&124)===0&&(h&u.expiredLanes)===0||so(u,h),S=y?Vz(u,h):tv(u,h,!0),k=y;do{if(S===0){vc&&!y&&No(u,h,0,!1);break}else{if(m=u.current.alternate,k&&!Mz(m)){S=tv(u,h,!1),k=!1;continue}if(S===2){if(k=h,u.errorRecoveryDisabledLanes&k)var F=0;else F=u.pendingLanes&-536870913,F=F!==0?F:F&536870912?536870912:0;if(F!==0){h=F;e:{var V=u;S=hf;var Z=V.current.memoizedState.isDehydrated;if(Z&&($c(V,F).flags|=256),F=tv(V,F,!1),F!==2){if(j1&&!Z){V.errorRecoveryDisabledLanes|=k,Ll|=k,S=4;break e}k=yr,yr=S,k!==null&&(yr===null?yr=k:yr.push.apply(yr,k))}S=F}if(k=!1,S!==2)continue}}if(S===1){$c(u,0),No(u,h,0,!0);break}e:{switch(y=u,k=S,k){case 0:case 1:throw Error(s(345));case 4:if((h&4194048)!==h)break;case 6:No(y,h,ri,!So);break e;case 2:yr=null;break;case 3:case 5:break;default:throw Error(s(329))}if((h&62914560)===h&&(S=K1+300-$t(),10<S)){if(No(y,h,ri,!So),Lu(y,0,!0)!==0)break e;y.timeoutHandle=Qk(Ck.bind(null,y,m,yr,Rg,X1,h,ri,Ll,wc,So,k,2,-0,0),S);break e}Ck(y,m,yr,Rg,X1,h,ri,Ll,wc,So,k,0,-0,0)}}break}while(!0);sa(u)}function Ck(u,h,m,y,S,k,F,V,Z,ye,$e,Te,xe,ve){if(u.timeoutHandle=-1,Te=h.subtreeFlags,(Te&8192||(Te&16785408)===16785408)&&(bf={stylesheets:null,count:0,unsuspend:vL},gk(h),Te=SL(),Te!==null)){u.cancelPendingCommit=Te(Rk.bind(null,u,h,k,m,y,S,F,V,Z,$e,1,xe,ve)),No(u,k,F,!ye);return}Rk(u,h,k,m,y,S,F,V,Z)}function Mz(u){for(var h=u;;){var m=h.tag;if((m===0||m===11||m===15)&&h.flags&16384&&(m=h.updateQueue,m!==null&&(m=m.stores,m!==null)))for(var y=0;y<m.length;y++){var S=m[y],k=S.getSnapshot;S=S.value;try{if(!_r(k(),S))return!1}catch{return!1}}if(m=h.child,h.subtreeFlags&16384&&m!==null)m.return=h,h=m;else{if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function No(u,h,m,y){h&=~q1,h&=~Ll,u.suspendedLanes|=h,u.pingedLanes&=~h,y&&(u.warmLanes|=h),y=u.expirationTimes;for(var S=h;0<S;){var k=31-Tn(S),F=1<<k;y[k]=-1,S&=~F}m!==0&&$d(u,m,h)}function Ag(){return(Xt&6)===0?(ff(0),!1):!0}function J1(){if(Nt!==null){if(Kt===0)var u=Nt.return;else u=Nt,Ra=Al=null,g1(u),gc=null,nf=0,u=Nt;for(;u!==null;)nk(u.alternate,u),u=u.return;Nt=null}}function $c(u,h){var m=u.timeoutHandle;m!==-1&&(u.timeoutHandle=-1,sL(m)),m=u.cancelPendingCommit,m!==null&&(u.cancelPendingCommit=null,m()),J1(),dn=u,Nt=m=Ia(u.current,null),zt=h,Kt=0,Lr=null,So=!1,vc=so(u,h),j1=!1,wc=ri=q1=Ll=Co=An=0,yr=hf=null,X1=!1,(h&8)!==0&&(h|=h&32);var y=u.entangledLanes;if(y!==0)for(u=u.entanglements,y&=h;0<y;){var S=31-Tn(y),k=1<<S;h|=u[S],y&=~k}return Pa=h,Jm(),m}function $k(u,h){St=null,G.H=xg,h===qd||h===lg?(h=VC(),Kt=3):h===PC?(h=VC(),Kt=4):Kt=h===U$?8:h!==null&&typeof h=="object"&&typeof h.then=="function"?6:1,Lr=h,Nt===null&&(An=1,Cg(u,Jr(h,u.current)))}function kk(){var u=G.H;return G.H=xg,u===null?xg:u}function Nk(){var u=G.A;return G.A=Lz,u}function ev(){An=4,So||(zt&4194048)!==zt&&si.current!==null||(vc=!0),(Co&134217727)===0&&(Ll&134217727)===0||dn===null||No(dn,zt,ri,!1)}function tv(u,h,m){var y=Xt;Xt|=2;var S=kk(),k=Nk();(dn!==u||zt!==h)&&(Rg=null,$c(u,h)),h=!1;var F=An;e:do try{if(Kt!==0&&Nt!==null){var V=Nt,Z=Lr;switch(Kt){case 8:J1(),F=6;break e;case 3:case 2:case 9:case 6:si.current===null&&(h=!0);var ye=Kt;if(Kt=0,Lr=null,kc(u,V,Z,ye),m&&vc){F=0;break e}break;default:ye=Kt,Kt=0,Lr=null,kc(u,V,Z,ye)}}Bz(),F=An;break}catch($e){$k(u,$e)}while(!0);return h&&u.shellSuspendCounter++,Ra=Al=null,Xt=y,G.H=S,G.A=k,Nt===null&&(dn=null,zt=0,Jm()),F}function Bz(){for(;Nt!==null;)Ik(Nt)}function Vz(u,h){var m=Xt;Xt|=2;var y=kk(),S=Nk();dn!==u||zt!==h?(Rg=null,Eg=$t()+500,$c(u,h)):vc=so(u,h);e:do try{if(Kt!==0&&Nt!==null){h=Nt;var k=Lr;t:switch(Kt){case 1:Kt=0,Lr=null,kc(u,h,k,1);break;case 2:case 9:if(MC(k)){Kt=0,Lr=null,Tk(h);break}h=function(){Kt!==2&&Kt!==9||dn!==u||(Kt=7),sa(u)},k.then(h,h);break e;case 3:Kt=7;break e;case 4:Kt=5;break e;case 7:MC(k)?(Kt=0,Lr=null,Tk(h)):(Kt=0,Lr=null,kc(u,h,k,7));break;case 5:var F=null;switch(Nt.tag){case 26:F=Nt.memoizedState;case 5:case 27:var V=Nt;if(!F||uN(F)){Kt=0,Lr=null;var Z=V.sibling;if(Z!==null)Nt=Z;else{var ye=V.return;ye!==null?(Nt=ye,Dg(ye)):Nt=null}break t}}Kt=0,Lr=null,kc(u,h,k,5);break;case 6:Kt=0,Lr=null,kc(u,h,k,6);break;case 8:J1(),An=6;break e;default:throw Error(s(462))}}Uz();break}catch($e){$k(u,$e)}while(!0);return Ra=Al=null,G.H=y,G.A=S,Xt=m,Nt!==null?0:(dn=null,zt=0,Jm(),An)}function Uz(){for(;Nt!==null&&!Bt();)Ik(Nt)}function Ik(u){var h=ek(u.alternate,u,Pa);u.memoizedProps=u.pendingProps,h===null?Dg(u):Nt=h}function Tk(u){var h=u,m=h.alternate;switch(h.tag){case 15:case 0:h=X$(m,h,h.pendingProps,h.type,void 0,zt);break;case 11:h=X$(m,h,h.pendingProps,h.type.render,h.ref,zt);break;case 5:g1(h);default:nk(m,h),h=Nt=EC(h,Pa),h=ek(m,h,Pa)}u.memoizedProps=u.pendingProps,h===null?Dg(u):Nt=h}function kc(u,h,m,y){Ra=Al=null,g1(h),gc=null,nf=0;var S=h.return;try{if(Az(u,S,h,m,zt)){An=1,Cg(u,Jr(m,u.current)),Nt=null;return}}catch(k){if(S!==null)throw Nt=S,k;An=1,Cg(u,Jr(m,u.current)),Nt=null;return}h.flags&32768?(Wt||y===1?u=!0:vc||(zt&536870912)!==0?u=!1:(So=u=!0,(y===2||y===9||y===3||y===6)&&(y=si.current,y!==null&&y.tag===13&&(y.flags|=16384))),Ek(h,u)):Dg(h)}function Dg(u){var h=u;do{if((h.flags&32768)!==0){Ek(h,So);return}u=h.return;var m=_z(h.alternate,h,Pa);if(m!==null){Nt=m;return}if(h=h.sibling,h!==null){Nt=h;return}Nt=h=u}while(h!==null);An===0&&(An=5)}function Ek(u,h){do{var m=Oz(u.alternate,u);if(m!==null){m.flags&=32767,Nt=m;return}if(m=u.return,m!==null&&(m.flags|=32768,m.subtreeFlags=0,m.deletions=null),!h&&(u=u.sibling,u!==null)){Nt=u;return}Nt=u=m}while(u!==null);An=6,Nt=null}function Rk(u,h,m,y,S,k,F,V,Z){u.cancelPendingCommit=null;do _g();while(Ts!==0);if((Xt&6)!==0)throw Error(s(327));if(h!==null){if(h===u.current)throw Error(s(177));if(k=h.lanes|h.childLanes,k|=H0,Cd(u,m,k,F,V,Z),u===dn&&(Nt=dn=null,zt=0),Sc=h,ko=u,Cc=m,Y1=k,Q1=S,vk=y,(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?(u.callbackNode=null,u.callbackPriority=0,jz(Os,function(){return Fk(),null})):(u.callbackNode=null,u.callbackPriority=0),y=(h.flags&13878)!==0,(h.subtreeFlags&13878)!==0||y){y=G.T,G.T=null,S=te.p,te.p=2,F=Xt,Xt|=4;try{Fz(u,h,m)}finally{Xt=F,te.p=S,G.T=y}}Ts=1,Ak(),Dk(),_k()}}function Ak(){if(Ts===1){Ts=0;var u=ko,h=Sc,m=(h.flags&13878)!==0;if((h.subtreeFlags&13878)!==0||m){m=G.T,G.T=null;var y=te.p;te.p=2;var S=Xt;Xt|=4;try{fk(h,u);var k=fv,F=bC(u.containerInfo),V=k.focusedElem,Z=k.selectionRange;if(F!==V&&V&&V.ownerDocument&&xC(V.ownerDocument.documentElement,V)){if(Z!==null&&B0(V)){var ye=Z.start,$e=Z.end;if($e===void 0&&($e=ye),"selectionStart"in V)V.selectionStart=ye,V.selectionEnd=Math.min($e,V.value.length);else{var Te=V.ownerDocument||document,xe=Te&&Te.defaultView||window;if(xe.getSelection){var ve=xe.getSelection(),dt=V.textContent.length,it=Math.min(Z.start,dt),nn=Z.end===void 0?it:Math.min(Z.end,dt);!ve.extend&&it>nn&&(F=nn,nn=it,it=F);var me=yC(V,it),le=yC(V,nn);if(me&&le&&(ve.rangeCount!==1||ve.anchorNode!==me.node||ve.anchorOffset!==me.offset||ve.focusNode!==le.node||ve.focusOffset!==le.offset)){var ge=Te.createRange();ge.setStart(me.node,me.offset),ve.removeAllRanges(),it>nn?(ve.addRange(ge),ve.extend(le.node,le.offset)):(ge.setEnd(le.node,le.offset),ve.addRange(ge))}}}}for(Te=[],ve=V;ve=ve.parentNode;)ve.nodeType===1&&Te.push({element:ve,left:ve.scrollLeft,top:ve.scrollTop});for(typeof V.focus=="function"&&V.focus(),V=0;V<Te.length;V++){var Ie=Te[V];Ie.element.scrollLeft=Ie.left,Ie.element.scrollTop=Ie.top}}Hg=!!dv,fv=dv=null}finally{Xt=S,te.p=y,G.T=m}}u.current=h,Ts=2}}function Dk(){if(Ts===2){Ts=0;var u=ko,h=Sc,m=(h.flags&8772)!==0;if((h.subtreeFlags&8772)!==0||m){m=G.T,G.T=null;var y=te.p;te.p=2;var S=Xt;Xt|=4;try{uk(u,h.alternate,h)}finally{Xt=S,te.p=y,G.T=m}}Ts=3}}function _k(){if(Ts===4||Ts===3){Ts=0,Pt();var u=ko,h=Sc,m=Cc,y=vk;(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?Ts=5:(Ts=0,Sc=ko=null,Ok(u,u.pendingLanes));var S=u.pendingLanes;if(S===0&&($o=null),Mu(m),h=h.stateNode,hn&&typeof hn.onCommitFiberRoot=="function")try{hn.onCommitFiberRoot(is,h,void 0,(h.current.flags&128)===128)}catch{}if(y!==null){h=G.T,S=te.p,te.p=2,G.T=null;try{for(var k=u.onRecoverableError,F=0;F<y.length;F++){var V=y[F];k(V.value,{componentStack:V.stack})}}finally{G.T=h,te.p=S}}(Cc&3)!==0&&_g(),sa(u),S=u.pendingLanes,(m&4194090)!==0&&(S&42)!==0?u===Z1?df++:(df=0,Z1=u):df=0,ff(0)}}function Ok(u,h){(u.pooledCacheLanes&=h)===0&&(h=u.pooledCache,h!=null&&(u.pooledCache=null,Hd(h)))}function _g(u){return Ak(),Dk(),_k(),Fk()}function Fk(){if(Ts!==5)return!1;var u=ko,h=Y1;Y1=0;var m=Mu(Cc),y=G.T,S=te.p;try{te.p=32>m?32:m,G.T=null,m=Q1,Q1=null;var k=ko,F=Cc;if(Ts=0,Sc=ko=null,Cc=0,(Xt&6)!==0)throw Error(s(331));var V=Xt;if(Xt|=4,xk(k.current),mk(k,k.current,F,m),Xt=V,ff(0,!1),hn&&typeof hn.onPostCommitFiberRoot=="function")try{hn.onPostCommitFiberRoot(is,k)}catch{}return!0}finally{te.p=S,G.T=y,Ok(u,h)}}function zk(u,h,m){h=Jr(m,h),h=R1(u.stateNode,h,2),u=mo(u,h,2),u!==null&&(io(u,2),sa(u))}function an(u,h,m){if(u.tag===3)zk(u,u,m);else for(;h!==null;){if(h.tag===3){zk(h,u,m);break}else if(h.tag===1){var y=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof y.componentDidCatch=="function"&&($o===null||!$o.has(y))){u=Jr(m,u),m=B$(2),y=mo(h,m,2),y!==null&&(V$(m,y,h,u),io(y,2),sa(y));break}}h=h.return}}function nv(u,h,m){var y=u.pingCache;if(y===null){y=u.pingCache=new Pz;var S=new Set;y.set(h,S)}else S=y.get(h),S===void 0&&(S=new Set,y.set(h,S));S.has(m)||(j1=!0,S.add(m),u=Wz.bind(null,u,h,m),h.then(u,u))}function Wz(u,h,m){var y=u.pingCache;y!==null&&y.delete(h),u.pingedLanes|=u.suspendedLanes&m,u.warmLanes&=~m,dn===u&&(zt&m)===m&&(An===4||An===3&&(zt&62914560)===zt&&300>$t()-K1?(Xt&2)===0&&$c(u,0):q1|=m,wc===zt&&(wc=0)),sa(u)}function Lk(u,h){h===0&&(h=ro()),u=ac(u,h),u!==null&&(io(u,h),sa(u))}function Gz(u){var h=u.memoizedState,m=0;h!==null&&(m=h.retryLane),Lk(u,m)}function Hz(u,h){var m=0;switch(u.tag){case 13:var y=u.stateNode,S=u.memoizedState;S!==null&&(m=S.retryLane);break;case 19:y=u.stateNode;break;case 22:y=u.stateNode._retryCache;break;default:throw Error(s(314))}y!==null&&y.delete(h),Lk(u,m)}function jz(u,h){return st(u,h)}var Og=null,Nc=null,sv=!1,Fg=!1,rv=!1,Pl=0;function sa(u){u!==Nc&&u.next===null&&(Nc===null?Og=Nc=u:Nc=Nc.next=u),Fg=!0,sv||(sv=!0,Xz())}function ff(u,h){if(!rv&&Fg){rv=!0;do for(var m=!1,y=Og;y!==null;){if(u!==0){var S=y.pendingLanes;if(S===0)var k=0;else{var F=y.suspendedLanes,V=y.pingedLanes;k=(1<<31-Tn(42|u)+1)-1,k&=S&~(F&~V),k=k&201326741?k&201326741|1:k?k|2:0}k!==0&&(m=!0,Vk(y,k))}else k=zt,k=Lu(y,y===dn?k:0,y.cancelPendingCommit!==null||y.timeoutHandle!==-1),(k&3)===0||so(y,k)||(m=!0,Vk(y,k));y=y.next}while(m);rv=!1}}function qz(){Pk()}function Pk(){Fg=sv=!1;var u=0;Pl!==0&&(nL()&&(u=Pl),Pl=0);for(var h=$t(),m=null,y=Og;y!==null;){var S=y.next,k=Mk(y,h);k===0?(y.next=null,m===null?Og=S:m.next=S,S===null&&(Nc=m)):(m=y,(u!==0||(k&3)!==0)&&(Fg=!0)),y=S}ff(u)}function Mk(u,h){for(var m=u.suspendedLanes,y=u.pingedLanes,S=u.expirationTimes,k=u.pendingLanes&-62914561;0<k;){var F=31-Tn(k),V=1<<F,Z=S[F];Z===-1?((V&m)===0||(V&y)!==0)&&(S[F]=Sd(V,h)):Z<=h&&(u.expiredLanes|=V),k&=~V}if(h=dn,m=zt,m=Lu(u,u===h?m:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),y=u.callbackNode,m===0||u===h&&(Kt===2||Kt===9)||u.cancelPendingCommit!==null)return y!==null&&y!==null&&gt(y),u.callbackNode=null,u.callbackPriority=0;if((m&3)===0||so(u,m)){if(h=m&-m,h===u.callbackPriority)return h;switch(y!==null&&gt(y),Mu(m)){case 2:case 8:m=gn;break;case 32:m=Os;break;case 268435456:m=Rr;break;default:m=Os}return y=Bk.bind(null,u),m=st(m,y),u.callbackPriority=h,u.callbackNode=m,h}return y!==null&&y!==null&&gt(y),u.callbackPriority=2,u.callbackNode=null,2}function Bk(u,h){if(Ts!==0&&Ts!==5)return u.callbackNode=null,u.callbackPriority=0,null;var m=u.callbackNode;if(_g()&&u.callbackNode!==m)return null;var y=zt;return y=Lu(u,u===dn?y:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),y===0?null:(Sk(u,y,h),Mk(u,$t()),u.callbackNode!=null&&u.callbackNode===m?Bk.bind(null,u):null)}function Vk(u,h){if(_g())return null;Sk(u,h,!0)}function Xz(){rL(function(){(Xt&6)!==0?st(Ys,qz):Pk()})}function iv(){return Pl===0&&(Pl=ji()),Pl}function Uk(u){return u==null||typeof u=="symbol"||typeof u=="boolean"?null:typeof u=="function"?u:Ku(""+u)}function Wk(u,h){var m=h.ownerDocument.createElement("input");return m.name=h.name,m.value=h.value,u.id&&m.setAttribute("form",u.id),h.parentNode.insertBefore(m,h),u=new FormData(u),m.parentNode.removeChild(m),u}function Kz(u,h,m,y,S){if(h==="submit"&&m&&m.stateNode===S){var k=Uk((S[Fs]||null).action),F=y.submitter;F&&(h=(h=F[Fs]||null)?Uk(h.formAction):F.getAttribute("formAction"),h!==null&&(k=h,F=null));var V=new Sl("action","action",null,y,S);u.push({event:V,listeners:[{instance:null,listener:function(){if(y.defaultPrevented){if(Pl!==0){var Z=F?Wk(S,F):new FormData(S);k1(m,{pending:!0,data:Z,method:S.method,action:k},null,Z)}}else typeof k=="function"&&(V.preventDefault(),Z=F?Wk(S,F):new FormData(S),k1(m,{pending:!0,data:Z,method:S.method,action:k},k,Z))},currentTarget:S}]})}}for(var av=0;av<G0.length;av++){var ov=G0[av],Yz=ov.toLowerCase(),Qz=ov[0].toUpperCase()+ov.slice(1);ki(Yz,"on"+Qz)}ki(SC,"onAnimationEnd"),ki(CC,"onAnimationIteration"),ki($C,"onAnimationStart"),ki("dblclick","onDoubleClick"),ki("focusin","onFocus"),ki("focusout","onBlur"),ki(pz,"onTransitionRun"),ki(mz,"onTransitionStart"),ki(gz,"onTransitionCancel"),ki(kC,"onTransitionEnd"),ps("onMouseEnter",["mouseout","mouseover"]),ps("onMouseLeave",["mouseout","mouseover"]),ps("onPointerEnter",["pointerout","pointerover"]),ps("onPointerLeave",["pointerout","pointerover"]),Qi("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Qi("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Qi("onBeforeInput",["compositionend","keypress","textInput","paste"]),Qi("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Qi("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Qi("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var pf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Zz=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(pf));function Gk(u,h){h=(h&4)!==0;for(var m=0;m<u.length;m++){var y=u[m],S=y.event;y=y.listeners;e:{var k=void 0;if(h)for(var F=y.length-1;0<=F;F--){var V=y[F],Z=V.instance,ye=V.currentTarget;if(V=V.listener,Z!==k&&S.isPropagationStopped())break e;k=V,S.currentTarget=ye;try{k(S)}catch($e){Sg($e)}S.currentTarget=null,k=Z}else for(F=0;F<y.length;F++){if(V=y[F],Z=V.instance,ye=V.currentTarget,V=V.listener,Z!==k&&S.isPropagationStopped())break e;k=V,S.currentTarget=ye;try{k(S)}catch($e){Sg($e)}S.currentTarget=null,k=Z}}}}function It(u,h){var m=h[Si];m===void 0&&(m=h[Si]=new Set);var y=u+"__bubble";m.has(y)||(Hk(h,u,2,!1),m.add(y))}function lv(u,h,m){var y=0;h&&(y|=4),Hk(m,u,y,h)}var zg="_reactListening"+Math.random().toString(36).slice(2);function uv(u){if(!u[zg]){u[zg]=!0,Vu.forEach(function(m){m!=="selectionchange"&&(Zz.has(m)||lv(m,!1,u),lv(m,!0,u))});var h=u.nodeType===9?u:u.ownerDocument;h===null||h[zg]||(h[zg]=!0,lv("selectionchange",!1,h))}}function Hk(u,h,m,y){switch(mN(h)){case 2:var S=kL;break;case 8:S=NL;break;default:S=Cv}m=S.bind(null,h,m,u),S=void 0,!Yu||h!=="touchstart"&&h!=="touchmove"&&h!=="wheel"||(S=!0),y?S!==void 0?u.addEventListener(h,m,{capture:!0,passive:S}):u.addEventListener(h,m,!0):S!==void 0?u.addEventListener(h,m,{passive:S}):u.addEventListener(h,m,!1)}function cv(u,h,m,y,S){var k=y;if((h&1)===0&&(h&2)===0&&y!==null)e:for(;;){if(y===null)return;var F=y.tag;if(F===3||F===4){var V=y.stateNode.containerInfo;if(V===S)break;if(F===4)for(F=y.return;F!==null;){var Z=F.tag;if((Z===3||Z===4)&&F.stateNode.containerInfo===S)return;F=F.return}for(;V!==null;){if(F=Ci(V),F===null)return;if(Z=F.tag,Z===5||Z===6||Z===26||Z===27){y=k=F;continue e}V=V.parentNode}}y=y.return}Wm(function(){var ye=k,$e=Ad(m),Te=[];e:{var xe=NC.get(u);if(xe!==void 0){var ve=Sl,dt=u;switch(u){case"keypress":if(vl(m)===0)break e;case"keydown":case"keyup":ve=A0;break;case"focusin":dt="focus",ve=Od;break;case"focusout":dt="blur",ve=Od;break;case"beforeblur":case"afterblur":ve=Od;break;case"click":if(m.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ve=Hm;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ve=Ju;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ve=_0;break;case SC:case CC:case $C:ve=$0;break;case kC:ve=O0;break;case"scroll":case"scrollend":ve=S0;break;case"wheel":ve=z0;break;case"copy":case"cut":case"paste":ve=Fd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ve=Xm;break;case"toggle":case"beforetoggle":ve=Ym}var it=(h&4)!==0,nn=!it&&(u==="scroll"||u==="scrollend"),me=it?xe!==null?xe+"Capture":null:xe;it=[];for(var le=ye,ge;le!==null;){var Ie=le;if(ge=Ie.stateNode,Ie=Ie.tag,Ie!==5&&Ie!==26&&Ie!==27||ge===null||me===null||(Ie=bl(le,me),Ie!=null&&it.push(mf(le,Ie,ge))),nn)break;le=le.return}0<it.length&&(xe=new ve(xe,dt,null,m,$e),Te.push({event:xe,listeners:it}))}}if((h&7)===0){e:{if(xe=u==="mouseover"||u==="pointerover",ve=u==="mouseout"||u==="pointerout",xe&&m!==Rd&&(dt=m.relatedTarget||m.fromElement)&&(Ci(dt)||dt[zs]))break e;if((ve||xe)&&(xe=$e.window===$e?$e:(xe=$e.ownerDocument)?xe.defaultView||xe.parentWindow:window,ve?(dt=m.relatedTarget||m.toElement,ve=ye,dt=dt?Ci(dt):null,dt!==null&&(nn=i(dt),it=dt.tag,dt!==nn||it!==5&&it!==27&&it!==6)&&(dt=null)):(ve=null,dt=ye),ve!==dt)){if(it=Hm,Ie="onMouseLeave",me="onMouseEnter",le="mouse",(u==="pointerout"||u==="pointerover")&&(it=Xm,Ie="onPointerLeave",me="onPointerEnter",le="pointer"),nn=ve==null?xe:Yi(ve),ge=dt==null?xe:Yi(dt),xe=new it(Ie,le+"leave",ve,m,$e),xe.target=nn,xe.relatedTarget=ge,Ie=null,Ci($e)===ye&&(it=new it(me,le+"enter",dt,m,$e),it.target=ge,it.relatedTarget=nn,Ie=it),nn=Ie,ve&&dt)t:{for(it=ve,me=dt,le=0,ge=it;ge;ge=Ic(ge))le++;for(ge=0,Ie=me;Ie;Ie=Ic(Ie))ge++;for(;0<le-ge;)it=Ic(it),le--;for(;0<ge-le;)me=Ic(me),ge--;for(;le--;){if(it===me||me!==null&&it===me.alternate)break t;it=Ic(it),me=Ic(me)}it=null}else it=null;ve!==null&&jk(Te,xe,ve,it,!1),dt!==null&&nn!==null&&jk(Te,nn,dt,it,!0)}}e:{if(xe=ye?Yi(ye):window,ve=xe.nodeName&&xe.nodeName.toLowerCase(),ve==="select"||ve==="input"&&xe.type==="file")var Xe=er;else if(Ve(xe))if(Ns)Xe=nc;else{Xe=P0;var kt=L0}else ve=xe.nodeName,!ve||ve.toLowerCase()!=="input"||xe.type!=="checkbox"&&xe.type!=="radio"?ye&&Xu(ye.elementType)&&(Xe=er):Xe=M0;if(Xe&&(Xe=Xe(u,ye))){rt(Te,Xe,m,$e);break e}kt&&kt(u,xe,ye),u==="focusout"&&ye&&xe.type==="number"&&ye.memoizedProps.value!=null&&qu(xe,"number",xe.value)}switch(kt=ye?Yi(ye):window,u){case"focusin":(Ve(kt)||kt.contentEditable==="true")&&(sc=kt,V0=ye,Bd=null);break;case"focusout":Bd=V0=sc=null;break;case"mousedown":U0=!0;break;case"contextmenu":case"mouseup":case"dragend":U0=!1,vC(Te,m,$e);break;case"selectionchange":if(fz)break;case"keydown":case"keyup":vC(Te,m,$e)}var Je;if(T)e:{switch(u){case"compositionstart":var lt="onCompositionStart";break e;case"compositionend":lt="onCompositionEnd";break e;case"compositionupdate":lt="onCompositionUpdate";break e}lt=void 0}else Re?oe(u,m)&&(lt="onCompositionEnd"):u==="keydown"&&m.keyCode===229&&(lt="onCompositionStart");lt&&(j&&m.locale!=="ko"&&(Re||lt!=="onCompositionStart"?lt==="onCompositionEnd"&&Re&&(Je=Gm()):(fr=$e,Js="value"in fr?fr.value:fr.textContent,Re=!0)),kt=Lg(ye,lt),0<kt.length&&(lt=new Ld(lt,u,null,m,$e),Te.push({event:lt,listeners:kt}),Je?lt.data=Je:(Je=be(m),Je!==null&&(lt.data=Je)))),(Je=M?Fe(u,m):ot(u,m))&&(lt=Lg(ye,"onBeforeInput"),0<lt.length&&(kt=new Ld("onBeforeInput","beforeinput",null,m,$e),Te.push({event:kt,listeners:lt}),kt.data=Je)),Kz(Te,u,ye,m,$e)}Gk(Te,h)})}function mf(u,h,m){return{instance:u,listener:h,currentTarget:m}}function Lg(u,h){for(var m=h+"Capture",y=[];u!==null;){var S=u,k=S.stateNode;if(S=S.tag,S!==5&&S!==26&&S!==27||k===null||(S=bl(u,m),S!=null&&y.unshift(mf(u,S,k)),S=bl(u,h),S!=null&&y.push(mf(u,S,k))),u.tag===3)return y;u=u.return}return[]}function Ic(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5&&u.tag!==27);return u||null}function jk(u,h,m,y,S){for(var k=h._reactName,F=[];m!==null&&m!==y;){var V=m,Z=V.alternate,ye=V.stateNode;if(V=V.tag,Z!==null&&Z===y)break;V!==5&&V!==26&&V!==27||ye===null||(Z=ye,S?(ye=bl(m,k),ye!=null&&F.unshift(mf(m,ye,Z))):S||(ye=bl(m,k),ye!=null&&F.push(mf(m,ye,Z)))),m=m.return}F.length!==0&&u.push({event:h,listeners:F})}var Jz=/\r\n?/g,eL=/\u0000|\uFFFD/g;function qk(u){return(typeof u=="string"?u:""+u).replace(Jz,`
`).replace(eL,"")}function Xk(u,h){return h=qk(h),qk(u)===h}function Pg(){}function tn(u,h,m,y,S,k){switch(m){case"children":typeof y=="string"?h==="body"||h==="textarea"&&y===""||$a(u,y):(typeof y=="number"||typeof y=="bigint")&&h!=="body"&&$a(u,""+y);break;case"className":oo(u,"class",y);break;case"tabIndex":oo(u,"tabindex",y);break;case"dir":case"role":case"viewBox":case"width":case"height":oo(u,m,y);break;case"style":Ed(u,y,k);break;case"data":if(h!=="object"){oo(u,"data",y);break}case"src":case"href":if(y===""&&(h!=="a"||m!=="href")){u.removeAttribute(m);break}if(y==null||typeof y=="function"||typeof y=="symbol"||typeof y=="boolean"){u.removeAttribute(m);break}y=Ku(""+y),u.setAttribute(m,y);break;case"action":case"formAction":if(typeof y=="function"){u.setAttribute(m,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof k=="function"&&(m==="formAction"?(h!=="input"&&tn(u,h,"name",S.name,S,null),tn(u,h,"formEncType",S.formEncType,S,null),tn(u,h,"formMethod",S.formMethod,S,null),tn(u,h,"formTarget",S.formTarget,S,null)):(tn(u,h,"encType",S.encType,S,null),tn(u,h,"method",S.method,S,null),tn(u,h,"target",S.target,S,null)));if(y==null||typeof y=="symbol"||typeof y=="boolean"){u.removeAttribute(m);break}y=Ku(""+y),u.setAttribute(m,y);break;case"onClick":y!=null&&(u.onclick=Pg);break;case"onScroll":y!=null&&It("scroll",u);break;case"onScrollEnd":y!=null&&It("scrollend",u);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(s(61));if(m=y.__html,m!=null){if(S.children!=null)throw Error(s(60));u.innerHTML=m}}break;case"multiple":u.multiple=y&&typeof y!="function"&&typeof y!="symbol";break;case"muted":u.muted=y&&typeof y!="function"&&typeof y!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(y==null||typeof y=="function"||typeof y=="boolean"||typeof y=="symbol"){u.removeAttribute("xlink:href");break}m=Ku(""+y),u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",m);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":y!=null&&typeof y!="function"&&typeof y!="symbol"?u.setAttribute(m,""+y):u.removeAttribute(m);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":y&&typeof y!="function"&&typeof y!="symbol"?u.setAttribute(m,""):u.removeAttribute(m);break;case"capture":case"download":y===!0?u.setAttribute(m,""):y!==!1&&y!=null&&typeof y!="function"&&typeof y!="symbol"?u.setAttribute(m,y):u.removeAttribute(m);break;case"cols":case"rows":case"size":case"span":y!=null&&typeof y!="function"&&typeof y!="symbol"&&!isNaN(y)&&1<=y?u.setAttribute(m,y):u.removeAttribute(m);break;case"rowSpan":case"start":y==null||typeof y=="function"||typeof y=="symbol"||isNaN(y)?u.removeAttribute(m):u.setAttribute(m,y);break;case"popover":It("beforetoggle",u),It("toggle",u),dl(u,"popover",y);break;case"xlinkActuate":Hn(u,"http://www.w3.org/1999/xlink","xlink:actuate",y);break;case"xlinkArcrole":Hn(u,"http://www.w3.org/1999/xlink","xlink:arcrole",y);break;case"xlinkRole":Hn(u,"http://www.w3.org/1999/xlink","xlink:role",y);break;case"xlinkShow":Hn(u,"http://www.w3.org/1999/xlink","xlink:show",y);break;case"xlinkTitle":Hn(u,"http://www.w3.org/1999/xlink","xlink:title",y);break;case"xlinkType":Hn(u,"http://www.w3.org/1999/xlink","xlink:type",y);break;case"xmlBase":Hn(u,"http://www.w3.org/XML/1998/namespace","xml:base",y);break;case"xmlLang":Hn(u,"http://www.w3.org/XML/1998/namespace","xml:lang",y);break;case"xmlSpace":Hn(u,"http://www.w3.org/XML/1998/namespace","xml:space",y);break;case"is":dl(u,"is",y);break;case"innerText":case"textContent":break;default:(!(2<m.length)||m[0]!=="o"&&m[0]!=="O"||m[1]!=="n"&&m[1]!=="N")&&(m=xl.get(m)||m,dl(u,m,y))}}function hv(u,h,m,y,S,k){switch(m){case"style":Ed(u,y,k);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(s(61));if(m=y.__html,m!=null){if(S.children!=null)throw Error(s(60));u.innerHTML=m}}break;case"children":typeof y=="string"?$a(u,y):(typeof y=="number"||typeof y=="bigint")&&$a(u,""+y);break;case"onScroll":y!=null&&It("scroll",u);break;case"onScrollEnd":y!=null&&It("scrollend",u);break;case"onClick":y!=null&&(u.onclick=Pg);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Uu.hasOwnProperty(m))e:{if(m[0]==="o"&&m[1]==="n"&&(S=m.endsWith("Capture"),h=m.slice(2,S?m.length-7:void 0),k=u[Fs]||null,k=k!=null?k[m]:null,typeof k=="function"&&u.removeEventListener(h,k,S),typeof y=="function")){typeof k!="function"&&k!==null&&(m in u?u[m]=null:u.hasAttribute(m)&&u.removeAttribute(m)),u.addEventListener(h,y,S);break e}m in u?u[m]=y:y===!0?u.setAttribute(m,""):dl(u,m,y)}}}function Es(u,h,m){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":It("error",u),It("load",u);var y=!1,S=!1,k;for(k in m)if(m.hasOwnProperty(k)){var F=m[k];if(F!=null)switch(k){case"src":y=!0;break;case"srcSet":S=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,h));default:tn(u,h,k,F,m,null)}}S&&tn(u,h,"srcSet",m.srcSet,m,null),y&&tn(u,h,"src",m.src,m,null);return;case"input":It("invalid",u);var V=k=F=S=null,Z=null,ye=null;for(y in m)if(m.hasOwnProperty(y)){var $e=m[y];if($e!=null)switch(y){case"name":S=$e;break;case"type":F=$e;break;case"checked":Z=$e;break;case"defaultChecked":ye=$e;break;case"value":k=$e;break;case"defaultValue":V=$e;break;case"children":case"dangerouslySetInnerHTML":if($e!=null)throw Error(s(137,h));break;default:tn(u,h,y,$e,m,null)}}gl(u,k,V,Z,ye,F,S,!1),pl(u);return;case"select":It("invalid",u),y=F=k=null;for(S in m)if(m.hasOwnProperty(S)&&(V=m[S],V!=null))switch(S){case"value":k=V;break;case"defaultValue":F=V;break;case"multiple":y=V;default:tn(u,h,S,V,m,null)}h=k,m=F,u.multiple=!!y,h!=null?Ca(u,!!y,h,!1):m!=null&&Ca(u,!!y,m,!0);return;case"textarea":It("invalid",u),k=S=y=null;for(F in m)if(m.hasOwnProperty(F)&&(V=m[F],V!=null))switch(F){case"value":y=V;break;case"defaultValue":S=V;break;case"children":k=V;break;case"dangerouslySetInnerHTML":if(V!=null)throw Error(s(91));break;default:tn(u,h,F,V,m,null)}Bm(u,y,S,k),pl(u);return;case"option":for(Z in m)if(m.hasOwnProperty(Z)&&(y=m[Z],y!=null))switch(Z){case"selected":u.selected=y&&typeof y!="function"&&typeof y!="symbol";break;default:tn(u,h,Z,y,m,null)}return;case"dialog":It("beforetoggle",u),It("toggle",u),It("cancel",u),It("close",u);break;case"iframe":case"object":It("load",u);break;case"video":case"audio":for(y=0;y<pf.length;y++)It(pf[y],u);break;case"image":It("error",u),It("load",u);break;case"details":It("toggle",u);break;case"embed":case"source":case"link":It("error",u),It("load",u);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(ye in m)if(m.hasOwnProperty(ye)&&(y=m[ye],y!=null))switch(ye){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,h));default:tn(u,h,ye,y,m,null)}return;default:if(Xu(h)){for($e in m)m.hasOwnProperty($e)&&(y=m[$e],y!==void 0&&hv(u,h,$e,y,m,void 0));return}}for(V in m)m.hasOwnProperty(V)&&(y=m[V],y!=null&&tn(u,h,V,y,m,null))}function tL(u,h,m,y){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var S=null,k=null,F=null,V=null,Z=null,ye=null,$e=null;for(ve in m){var Te=m[ve];if(m.hasOwnProperty(ve)&&Te!=null)switch(ve){case"checked":break;case"value":break;case"defaultValue":Z=Te;default:y.hasOwnProperty(ve)||tn(u,h,ve,null,y,Te)}}for(var xe in y){var ve=y[xe];if(Te=m[xe],y.hasOwnProperty(xe)&&(ve!=null||Te!=null))switch(xe){case"type":k=ve;break;case"name":S=ve;break;case"checked":ye=ve;break;case"defaultChecked":$e=ve;break;case"value":F=ve;break;case"defaultValue":V=ve;break;case"children":case"dangerouslySetInnerHTML":if(ve!=null)throw Error(s(137,h));break;default:ve!==Te&&tn(u,h,xe,ve,y,Te)}}ju(u,F,V,Z,ye,$e,k,S);return;case"select":ve=F=V=xe=null;for(k in m)if(Z=m[k],m.hasOwnProperty(k)&&Z!=null)switch(k){case"value":break;case"multiple":ve=Z;default:y.hasOwnProperty(k)||tn(u,h,k,null,y,Z)}for(S in y)if(k=y[S],Z=m[S],y.hasOwnProperty(S)&&(k!=null||Z!=null))switch(S){case"value":xe=k;break;case"defaultValue":V=k;break;case"multiple":F=k;default:k!==Z&&tn(u,h,S,k,y,Z)}h=V,m=F,y=ve,xe!=null?Ca(u,!!m,xe,!1):!!y!=!!m&&(h!=null?Ca(u,!!m,h,!0):Ca(u,!!m,m?[]:"",!1));return;case"textarea":ve=xe=null;for(V in m)if(S=m[V],m.hasOwnProperty(V)&&S!=null&&!y.hasOwnProperty(V))switch(V){case"value":break;case"children":break;default:tn(u,h,V,null,y,S)}for(F in y)if(S=y[F],k=m[F],y.hasOwnProperty(F)&&(S!=null||k!=null))switch(F){case"value":xe=S;break;case"defaultValue":ve=S;break;case"children":break;case"dangerouslySetInnerHTML":if(S!=null)throw Error(s(91));break;default:S!==k&&tn(u,h,F,S,y,k)}Mm(u,xe,ve);return;case"option":for(var dt in m)if(xe=m[dt],m.hasOwnProperty(dt)&&xe!=null&&!y.hasOwnProperty(dt))switch(dt){case"selected":u.selected=!1;break;default:tn(u,h,dt,null,y,xe)}for(Z in y)if(xe=y[Z],ve=m[Z],y.hasOwnProperty(Z)&&xe!==ve&&(xe!=null||ve!=null))switch(Z){case"selected":u.selected=xe&&typeof xe!="function"&&typeof xe!="symbol";break;default:tn(u,h,Z,xe,y,ve)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var it in m)xe=m[it],m.hasOwnProperty(it)&&xe!=null&&!y.hasOwnProperty(it)&&tn(u,h,it,null,y,xe);for(ye in y)if(xe=y[ye],ve=m[ye],y.hasOwnProperty(ye)&&xe!==ve&&(xe!=null||ve!=null))switch(ye){case"children":case"dangerouslySetInnerHTML":if(xe!=null)throw Error(s(137,h));break;default:tn(u,h,ye,xe,y,ve)}return;default:if(Xu(h)){for(var nn in m)xe=m[nn],m.hasOwnProperty(nn)&&xe!==void 0&&!y.hasOwnProperty(nn)&&hv(u,h,nn,void 0,y,xe);for($e in y)xe=y[$e],ve=m[$e],!y.hasOwnProperty($e)||xe===ve||xe===void 0&&ve===void 0||hv(u,h,$e,xe,y,ve);return}}for(var me in m)xe=m[me],m.hasOwnProperty(me)&&xe!=null&&!y.hasOwnProperty(me)&&tn(u,h,me,null,y,xe);for(Te in y)xe=y[Te],ve=m[Te],!y.hasOwnProperty(Te)||xe===ve||xe==null&&ve==null||tn(u,h,Te,xe,y,ve)}var dv=null,fv=null;function Mg(u){return u.nodeType===9?u:u.ownerDocument}function Kk(u){switch(u){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function Yk(u,h){if(u===0)switch(h){case"svg":return 1;case"math":return 2;default:return 0}return u===1&&h==="foreignObject"?0:u}function pv(u,h){return u==="textarea"||u==="noscript"||typeof h.children=="string"||typeof h.children=="number"||typeof h.children=="bigint"||typeof h.dangerouslySetInnerHTML=="object"&&h.dangerouslySetInnerHTML!==null&&h.dangerouslySetInnerHTML.__html!=null}var mv=null;function nL(){var u=window.event;return u&&u.type==="popstate"?u===mv?!1:(mv=u,!0):(mv=null,!1)}var Qk=typeof setTimeout=="function"?setTimeout:void 0,sL=typeof clearTimeout=="function"?clearTimeout:void 0,Zk=typeof Promise=="function"?Promise:void 0,rL=typeof queueMicrotask=="function"?queueMicrotask:typeof Zk<"u"?function(u){return Zk.resolve(null).then(u).catch(iL)}:Qk;function iL(u){setTimeout(function(){throw u})}function Io(u){return u==="head"}function Jk(u,h){var m=h,y=0,S=0;do{var k=m.nextSibling;if(u.removeChild(m),k&&k.nodeType===8)if(m=k.data,m==="/$"){if(0<y&&8>y){m=y;var F=u.ownerDocument;if(m&1&&gf(F.documentElement),m&2&&gf(F.body),m&4)for(m=F.head,gf(m),F=m.firstChild;F;){var V=F.nextSibling,Z=F.nodeName;F[Sa]||Z==="SCRIPT"||Z==="STYLE"||Z==="LINK"&&F.rel.toLowerCase()==="stylesheet"||m.removeChild(F),F=V}}if(S===0){u.removeChild(k),$f(h);return}S--}else m==="$"||m==="$?"||m==="$!"?S++:y=m.charCodeAt(0)-48;else y=0;m=k}while(m);$f(h)}function gv(u){var h=u.firstChild;for(h&&h.nodeType===10&&(h=h.nextSibling);h;){var m=h;switch(h=h.nextSibling,m.nodeName){case"HTML":case"HEAD":case"BODY":gv(m),kd(m);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(m.rel.toLowerCase()==="stylesheet")continue}u.removeChild(m)}}function aL(u,h,m,y){for(;u.nodeType===1;){var S=m;if(u.nodeName.toLowerCase()!==h.toLowerCase()){if(!y&&(u.nodeName!=="INPUT"||u.type!=="hidden"))break}else if(y){if(!u[Sa])switch(h){case"meta":if(!u.hasAttribute("itemprop"))break;return u;case"link":if(k=u.getAttribute("rel"),k==="stylesheet"&&u.hasAttribute("data-precedence"))break;if(k!==S.rel||u.getAttribute("href")!==(S.href==null||S.href===""?null:S.href)||u.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin)||u.getAttribute("title")!==(S.title==null?null:S.title))break;return u;case"style":if(u.hasAttribute("data-precedence"))break;return u;case"script":if(k=u.getAttribute("src"),(k!==(S.src==null?null:S.src)||u.getAttribute("type")!==(S.type==null?null:S.type)||u.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin))&&k&&u.hasAttribute("async")&&!u.hasAttribute("itemprop"))break;return u;default:return u}}else if(h==="input"&&u.type==="hidden"){var k=S.name==null?null:""+S.name;if(S.type==="hidden"&&u.getAttribute("name")===k)return u}else return u;if(u=Ii(u.nextSibling),u===null)break}return null}function oL(u,h,m){if(h==="")return null;for(;u.nodeType!==3;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!m||(u=Ii(u.nextSibling),u===null))return null;return u}function yv(u){return u.data==="$!"||u.data==="$?"&&u.ownerDocument.readyState==="complete"}function lL(u,h){var m=u.ownerDocument;if(u.data!=="$?"||m.readyState==="complete")h();else{var y=function(){h(),m.removeEventListener("DOMContentLoaded",y)};m.addEventListener("DOMContentLoaded",y),u._reactRetry=y}}function Ii(u){for(;u!=null;u=u.nextSibling){var h=u.nodeType;if(h===1||h===3)break;if(h===8){if(h=u.data,h==="$"||h==="$!"||h==="$?"||h==="F!"||h==="F")break;if(h==="/$")return null}}return u}var xv=null;function eN(u){u=u.previousSibling;for(var h=0;u;){if(u.nodeType===8){var m=u.data;if(m==="$"||m==="$!"||m==="$?"){if(h===0)return u;h--}else m==="/$"&&h++}u=u.previousSibling}return null}function tN(u,h,m){switch(h=Mg(m),u){case"html":if(u=h.documentElement,!u)throw Error(s(452));return u;case"head":if(u=h.head,!u)throw Error(s(453));return u;case"body":if(u=h.body,!u)throw Error(s(454));return u;default:throw Error(s(451))}}function gf(u){for(var h=u.attributes;h.length;)u.removeAttributeNode(h[0]);kd(u)}var ii=new Map,nN=new Set;function Bg(u){return typeof u.getRootNode=="function"?u.getRootNode():u.nodeType===9?u:u.ownerDocument}var Ma=te.d;te.d={f:uL,r:cL,D:hL,C:dL,L:fL,m:pL,X:gL,S:mL,M:yL};function uL(){var u=Ma.f(),h=Ag();return u||h}function cL(u){var h=Ki(u);h!==null&&h.tag===5&&h.type==="form"?S$(h):Ma.r(u)}var Tc=typeof document>"u"?null:document;function sN(u,h,m){var y=Tc;if(y&&typeof h=="string"&&h){var S=Zs(h);S='link[rel="'+u+'"][href="'+S+'"]',typeof m=="string"&&(S+='[crossorigin="'+m+'"]'),nN.has(S)||(nN.add(S),u={rel:u,crossOrigin:m,href:h},y.querySelector(S)===null&&(h=y.createElement("link"),Es(h,"link",u),Pn(h),y.head.appendChild(h)))}}function hL(u){Ma.D(u),sN("dns-prefetch",u,null)}function dL(u,h){Ma.C(u,h),sN("preconnect",u,h)}function fL(u,h,m){Ma.L(u,h,m);var y=Tc;if(y&&u&&h){var S='link[rel="preload"][as="'+Zs(h)+'"]';h==="image"&&m&&m.imageSrcSet?(S+='[imagesrcset="'+Zs(m.imageSrcSet)+'"]',typeof m.imageSizes=="string"&&(S+='[imagesizes="'+Zs(m.imageSizes)+'"]')):S+='[href="'+Zs(u)+'"]';var k=S;switch(h){case"style":k=Ec(u);break;case"script":k=Rc(u)}ii.has(k)||(u=d({rel:"preload",href:h==="image"&&m&&m.imageSrcSet?void 0:u,as:h},m),ii.set(k,u),y.querySelector(S)!==null||h==="style"&&y.querySelector(yf(k))||h==="script"&&y.querySelector(xf(k))||(h=y.createElement("link"),Es(h,"link",u),Pn(h),y.head.appendChild(h)))}}function pL(u,h){Ma.m(u,h);var m=Tc;if(m&&u){var y=h&&typeof h.as=="string"?h.as:"script",S='link[rel="modulepreload"][as="'+Zs(y)+'"][href="'+Zs(u)+'"]',k=S;switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":k=Rc(u)}if(!ii.has(k)&&(u=d({rel:"modulepreload",href:u},h),ii.set(k,u),m.querySelector(S)===null)){switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(m.querySelector(xf(k)))return}y=m.createElement("link"),Es(y,"link",u),Pn(y),m.head.appendChild(y)}}}function mL(u,h,m){Ma.S(u,h,m);var y=Tc;if(y&&u){var S=Yr(y).hoistableStyles,k=Ec(u);h=h||"default";var F=S.get(k);if(!F){var V={loading:0,preload:null};if(F=y.querySelector(yf(k)))V.loading=5;else{u=d({rel:"stylesheet",href:u,"data-precedence":h},m),(m=ii.get(k))&&bv(u,m);var Z=F=y.createElement("link");Pn(Z),Es(Z,"link",u),Z._p=new Promise(function(ye,$e){Z.onload=ye,Z.onerror=$e}),Z.addEventListener("load",function(){V.loading|=1}),Z.addEventListener("error",function(){V.loading|=2}),V.loading|=4,Vg(F,h,y)}F={type:"stylesheet",instance:F,count:1,state:V},S.set(k,F)}}}function gL(u,h){Ma.X(u,h);var m=Tc;if(m&&u){var y=Yr(m).hoistableScripts,S=Rc(u),k=y.get(S);k||(k=m.querySelector(xf(S)),k||(u=d({src:u,async:!0},h),(h=ii.get(S))&&vv(u,h),k=m.createElement("script"),Pn(k),Es(k,"link",u),m.head.appendChild(k)),k={type:"script",instance:k,count:1,state:null},y.set(S,k))}}function yL(u,h){Ma.M(u,h);var m=Tc;if(m&&u){var y=Yr(m).hoistableScripts,S=Rc(u),k=y.get(S);k||(k=m.querySelector(xf(S)),k||(u=d({src:u,async:!0,type:"module"},h),(h=ii.get(S))&&vv(u,h),k=m.createElement("script"),Pn(k),Es(k,"link",u),m.head.appendChild(k)),k={type:"script",instance:k,count:1,state:null},y.set(S,k))}}function rN(u,h,m,y){var S=(S=Ne.current)?Bg(S):null;if(!S)throw Error(s(446));switch(u){case"meta":case"title":return null;case"style":return typeof m.precedence=="string"&&typeof m.href=="string"?(h=Ec(m.href),m=Yr(S).hoistableStyles,y=m.get(h),y||(y={type:"style",instance:null,count:0,state:null},m.set(h,y)),y):{type:"void",instance:null,count:0,state:null};case"link":if(m.rel==="stylesheet"&&typeof m.href=="string"&&typeof m.precedence=="string"){u=Ec(m.href);var k=Yr(S).hoistableStyles,F=k.get(u);if(F||(S=S.ownerDocument||S,F={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},k.set(u,F),(k=S.querySelector(yf(u)))&&!k._p&&(F.instance=k,F.state.loading=5),ii.has(u)||(m={rel:"preload",as:"style",href:m.href,crossOrigin:m.crossOrigin,integrity:m.integrity,media:m.media,hrefLang:m.hrefLang,referrerPolicy:m.referrerPolicy},ii.set(u,m),k||xL(S,u,m,F.state))),h&&y===null)throw Error(s(528,""));return F}if(h&&y!==null)throw Error(s(529,""));return null;case"script":return h=m.async,m=m.src,typeof m=="string"&&h&&typeof h!="function"&&typeof h!="symbol"?(h=Rc(m),m=Yr(S).hoistableScripts,y=m.get(h),y||(y={type:"script",instance:null,count:0,state:null},m.set(h,y)),y):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,u))}}function Ec(u){return'href="'+Zs(u)+'"'}function yf(u){return'link[rel="stylesheet"]['+u+"]"}function iN(u){return d({},u,{"data-precedence":u.precedence,precedence:null})}function xL(u,h,m,y){u.querySelector('link[rel="preload"][as="style"]['+h+"]")?y.loading=1:(h=u.createElement("link"),y.preload=h,h.addEventListener("load",function(){return y.loading|=1}),h.addEventListener("error",function(){return y.loading|=2}),Es(h,"link",m),Pn(h),u.head.appendChild(h))}function Rc(u){return'[src="'+Zs(u)+'"]'}function xf(u){return"script[async]"+u}function aN(u,h,m){if(h.count++,h.instance===null)switch(h.type){case"style":var y=u.querySelector('style[data-href~="'+Zs(m.href)+'"]');if(y)return h.instance=y,Pn(y),y;var S=d({},m,{"data-href":m.href,"data-precedence":m.precedence,href:null,precedence:null});return y=(u.ownerDocument||u).createElement("style"),Pn(y),Es(y,"style",S),Vg(y,m.precedence,u),h.instance=y;case"stylesheet":S=Ec(m.href);var k=u.querySelector(yf(S));if(k)return h.state.loading|=4,h.instance=k,Pn(k),k;y=iN(m),(S=ii.get(S))&&bv(y,S),k=(u.ownerDocument||u).createElement("link"),Pn(k);var F=k;return F._p=new Promise(function(V,Z){F.onload=V,F.onerror=Z}),Es(k,"link",y),h.state.loading|=4,Vg(k,m.precedence,u),h.instance=k;case"script":return k=Rc(m.src),(S=u.querySelector(xf(k)))?(h.instance=S,Pn(S),S):(y=m,(S=ii.get(k))&&(y=d({},m),vv(y,S)),u=u.ownerDocument||u,S=u.createElement("script"),Pn(S),Es(S,"link",y),u.head.appendChild(S),h.instance=S);case"void":return null;default:throw Error(s(443,h.type))}else h.type==="stylesheet"&&(h.state.loading&4)===0&&(y=h.instance,h.state.loading|=4,Vg(y,m.precedence,u));return h.instance}function Vg(u,h,m){for(var y=m.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),S=y.length?y[y.length-1]:null,k=S,F=0;F<y.length;F++){var V=y[F];if(V.dataset.precedence===h)k=V;else if(k!==S)break}k?k.parentNode.insertBefore(u,k.nextSibling):(h=m.nodeType===9?m.head:m,h.insertBefore(u,h.firstChild))}function bv(u,h){u.crossOrigin==null&&(u.crossOrigin=h.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=h.referrerPolicy),u.title==null&&(u.title=h.title)}function vv(u,h){u.crossOrigin==null&&(u.crossOrigin=h.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=h.referrerPolicy),u.integrity==null&&(u.integrity=h.integrity)}var Ug=null;function oN(u,h,m){if(Ug===null){var y=new Map,S=Ug=new Map;S.set(m,y)}else S=Ug,y=S.get(m),y||(y=new Map,S.set(m,y));if(y.has(u))return y;for(y.set(u,null),m=m.getElementsByTagName(u),S=0;S<m.length;S++){var k=m[S];if(!(k[Sa]||k[wn]||u==="link"&&k.getAttribute("rel")==="stylesheet")&&k.namespaceURI!=="http://www.w3.org/2000/svg"){var F=k.getAttribute(h)||"";F=u+F;var V=y.get(F);V?V.push(k):y.set(F,[k])}}return y}function lN(u,h,m){u=u.ownerDocument||u,u.head.insertBefore(m,h==="title"?u.querySelector("head > title"):null)}function bL(u,h,m){if(m===1||h.itemProp!=null)return!1;switch(u){case"meta":case"title":return!0;case"style":if(typeof h.precedence!="string"||typeof h.href!="string"||h.href==="")break;return!0;case"link":if(typeof h.rel!="string"||typeof h.href!="string"||h.href===""||h.onLoad||h.onError)break;switch(h.rel){case"stylesheet":return u=h.disabled,typeof h.precedence=="string"&&u==null;default:return!0}case"script":if(h.async&&typeof h.async!="function"&&typeof h.async!="symbol"&&!h.onLoad&&!h.onError&&h.src&&typeof h.src=="string")return!0}return!1}function uN(u){return!(u.type==="stylesheet"&&(u.state.loading&3)===0)}var bf=null;function vL(){}function wL(u,h,m){if(bf===null)throw Error(s(475));var y=bf;if(h.type==="stylesheet"&&(typeof m.media!="string"||matchMedia(m.media).matches!==!1)&&(h.state.loading&4)===0){if(h.instance===null){var S=Ec(m.href),k=u.querySelector(yf(S));if(k){u=k._p,u!==null&&typeof u=="object"&&typeof u.then=="function"&&(y.count++,y=Wg.bind(y),u.then(y,y)),h.state.loading|=4,h.instance=k,Pn(k);return}k=u.ownerDocument||u,m=iN(m),(S=ii.get(S))&&bv(m,S),k=k.createElement("link"),Pn(k);var F=k;F._p=new Promise(function(V,Z){F.onload=V,F.onerror=Z}),Es(k,"link",m),h.instance=k}y.stylesheets===null&&(y.stylesheets=new Map),y.stylesheets.set(h,u),(u=h.state.preload)&&(h.state.loading&3)===0&&(y.count++,h=Wg.bind(y),u.addEventListener("load",h),u.addEventListener("error",h))}}function SL(){if(bf===null)throw Error(s(475));var u=bf;return u.stylesheets&&u.count===0&&wv(u,u.stylesheets),0<u.count?function(h){var m=setTimeout(function(){if(u.stylesheets&&wv(u,u.stylesheets),u.unsuspend){var y=u.unsuspend;u.unsuspend=null,y()}},6e4);return u.unsuspend=h,function(){u.unsuspend=null,clearTimeout(m)}}:null}function Wg(){if(this.count--,this.count===0){if(this.stylesheets)wv(this,this.stylesheets);else if(this.unsuspend){var u=this.unsuspend;this.unsuspend=null,u()}}}var Gg=null;function wv(u,h){u.stylesheets=null,u.unsuspend!==null&&(u.count++,Gg=new Map,h.forEach(CL,u),Gg=null,Wg.call(u))}function CL(u,h){if(!(h.state.loading&4)){var m=Gg.get(u);if(m)var y=m.get(null);else{m=new Map,Gg.set(u,m);for(var S=u.querySelectorAll("link[data-precedence],style[data-precedence]"),k=0;k<S.length;k++){var F=S[k];(F.nodeName==="LINK"||F.getAttribute("media")!=="not all")&&(m.set(F.dataset.precedence,F),y=F)}y&&m.set(null,y)}S=h.instance,F=S.getAttribute("data-precedence"),k=m.get(F)||y,k===y&&m.set(null,S),m.set(F,S),this.count++,y=Wg.bind(this),S.addEventListener("load",y),S.addEventListener("error",y),k?k.parentNode.insertBefore(S,k.nextSibling):(u=u.nodeType===9?u.head:u,u.insertBefore(S,u.firstChild)),h.state.loading|=4}}var vf={$$typeof:I,Provider:null,Consumer:null,_currentValue:re,_currentValue2:re,_threadCount:0};function $L(u,h,m,y,S,k,F,V){this.tag=1,this.containerInfo=u,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Pu(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Pu(0),this.hiddenUpdates=Pu(null),this.identifierPrefix=y,this.onUncaughtError=S,this.onCaughtError=k,this.onRecoverableError=F,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=V,this.incompleteTransitions=new Map}function cN(u,h,m,y,S,k,F,V,Z,ye,$e,Te){return u=new $L(u,h,m,F,V,Z,ye,Te),h=1,k===!0&&(h|=24),k=Or(3,null,null,h),u.current=k,k.stateNode=u,h=n1(),h.refCount++,u.pooledCache=h,h.refCount++,k.memoizedState={element:y,isDehydrated:m,cache:h},a1(k),u}function hN(u){return u?(u=oc,u):oc}function dN(u,h,m,y,S,k){S=hN(S),y.context===null?y.context=S:y.pendingContext=S,y=po(h),y.payload={element:m},k=k===void 0?null:k,k!==null&&(y.callback=k),m=mo(u,y,h),m!==null&&(Mr(m,u,h),Kd(m,u,h))}function fN(u,h){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var m=u.retryLane;u.retryLane=m!==0&&m<h?m:h}}function Sv(u,h){fN(u,h),(u=u.alternate)&&fN(u,h)}function pN(u){if(u.tag===13){var h=ac(u,67108864);h!==null&&Mr(h,u,67108864),Sv(u,67108864)}}var Hg=!0;function kL(u,h,m,y){var S=G.T;G.T=null;var k=te.p;try{te.p=2,Cv(u,h,m,y)}finally{te.p=k,G.T=S}}function NL(u,h,m,y){var S=G.T;G.T=null;var k=te.p;try{te.p=8,Cv(u,h,m,y)}finally{te.p=k,G.T=S}}function Cv(u,h,m,y){if(Hg){var S=$v(y);if(S===null)cv(u,h,y,jg,m),gN(u,y);else if(TL(S,u,h,m,y))y.stopPropagation();else if(gN(u,y),h&4&&-1<IL.indexOf(u)){for(;S!==null;){var k=Ki(S);if(k!==null)switch(k.tag){case 3:if(k=k.stateNode,k.current.memoizedState.isDehydrated){var F=Kr(k.pendingLanes);if(F!==0){var V=k;for(V.pendingLanes|=2,V.entangledLanes|=2;F;){var Z=1<<31-Tn(F);V.entanglements[1]|=Z,F&=~Z}sa(k),(Xt&6)===0&&(Eg=$t()+500,ff(0))}}break;case 13:V=ac(k,2),V!==null&&Mr(V,k,2),Ag(),Sv(k,2)}if(k=$v(y),k===null&&cv(u,h,y,jg,m),k===S)break;S=k}S!==null&&y.stopPropagation()}else cv(u,h,y,null,m)}}function $v(u){return u=Ad(u),kv(u)}var jg=null;function kv(u){if(jg=null,u=Ci(u),u!==null){var h=i(u);if(h===null)u=null;else{var m=h.tag;if(m===13){if(u=a(h),u!==null)return u;u=null}else if(m===3){if(h.stateNode.current.memoizedState.isDehydrated)return h.tag===3?h.stateNode.containerInfo:null;u=null}else h!==u&&(u=null)}}return jg=u,null}function mN(u){switch(u){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Ht()){case Ys:return 2;case gn:return 8;case Os:case rs:return 32;case Rr:return 268435456;default:return 32}default:return 32}}var Nv=!1,To=null,Eo=null,Ro=null,wf=new Map,Sf=new Map,Ao=[],IL="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function gN(u,h){switch(u){case"focusin":case"focusout":To=null;break;case"dragenter":case"dragleave":Eo=null;break;case"mouseover":case"mouseout":Ro=null;break;case"pointerover":case"pointerout":wf.delete(h.pointerId);break;case"gotpointercapture":case"lostpointercapture":Sf.delete(h.pointerId)}}function Cf(u,h,m,y,S,k){return u===null||u.nativeEvent!==k?(u={blockedOn:h,domEventName:m,eventSystemFlags:y,nativeEvent:k,targetContainers:[S]},h!==null&&(h=Ki(h),h!==null&&pN(h)),u):(u.eventSystemFlags|=y,h=u.targetContainers,S!==null&&h.indexOf(S)===-1&&h.push(S),u)}function TL(u,h,m,y,S){switch(h){case"focusin":return To=Cf(To,u,h,m,y,S),!0;case"dragenter":return Eo=Cf(Eo,u,h,m,y,S),!0;case"mouseover":return Ro=Cf(Ro,u,h,m,y,S),!0;case"pointerover":var k=S.pointerId;return wf.set(k,Cf(wf.get(k)||null,u,h,m,y,S)),!0;case"gotpointercapture":return k=S.pointerId,Sf.set(k,Cf(Sf.get(k)||null,u,h,m,y,S)),!0}return!1}function yN(u){var h=Ci(u.target);if(h!==null){var m=i(h);if(m!==null){if(h=m.tag,h===13){if(h=a(m),h!==null){u.blockedOn=h,Bu(u.priority,function(){if(m.tag===13){var y=Pr();y=cl(y);var S=ac(m,y);S!==null&&Mr(S,m,y),Sv(m,y)}});return}}else if(h===3&&m.stateNode.current.memoizedState.isDehydrated){u.blockedOn=m.tag===3?m.stateNode.containerInfo:null;return}}}u.blockedOn=null}function qg(u){if(u.blockedOn!==null)return!1;for(var h=u.targetContainers;0<h.length;){var m=$v(u.nativeEvent);if(m===null){m=u.nativeEvent;var y=new m.constructor(m.type,m);Rd=y,m.target.dispatchEvent(y),Rd=null}else return h=Ki(m),h!==null&&pN(h),u.blockedOn=m,!1;h.shift()}return!0}function xN(u,h,m){qg(u)&&m.delete(h)}function EL(){Nv=!1,To!==null&&qg(To)&&(To=null),Eo!==null&&qg(Eo)&&(Eo=null),Ro!==null&&qg(Ro)&&(Ro=null),wf.forEach(xN),Sf.forEach(xN)}function Xg(u,h){u.blockedOn===h&&(u.blockedOn=null,Nv||(Nv=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,EL)))}var Kg=null;function bN(u){Kg!==u&&(Kg=u,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Kg===u&&(Kg=null);for(var h=0;h<u.length;h+=3){var m=u[h],y=u[h+1],S=u[h+2];if(typeof y!="function"){if(kv(y||m)===null)continue;break}var k=Ki(m);k!==null&&(u.splice(h,3),h-=3,k1(k,{pending:!0,data:S,method:m.method,action:y},y,S))}}))}function $f(u){function h(Z){return Xg(Z,u)}To!==null&&Xg(To,u),Eo!==null&&Xg(Eo,u),Ro!==null&&Xg(Ro,u),wf.forEach(h),Sf.forEach(h);for(var m=0;m<Ao.length;m++){var y=Ao[m];y.blockedOn===u&&(y.blockedOn=null)}for(;0<Ao.length&&(m=Ao[0],m.blockedOn===null);)yN(m),m.blockedOn===null&&Ao.shift();if(m=(u.ownerDocument||u).$$reactFormReplay,m!=null)for(y=0;y<m.length;y+=3){var S=m[y],k=m[y+1],F=S[Fs]||null;if(typeof k=="function")F||bN(m);else if(F){var V=null;if(k&&k.hasAttribute("formAction")){if(S=k,F=k[Fs]||null)V=F.formAction;else if(kv(S)!==null)continue}else V=F.action;typeof V=="function"?m[y+1]=V:(m.splice(y,3),y-=3),bN(m)}}}function Iv(u){this._internalRoot=u}Yg.prototype.render=Iv.prototype.render=function(u){var h=this._internalRoot;if(h===null)throw Error(s(409));var m=h.current,y=Pr();dN(m,y,u,h,null,null)},Yg.prototype.unmount=Iv.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var h=u.containerInfo;dN(u.current,2,null,u,null,null),Ag(),h[zs]=null}};function Yg(u){this._internalRoot=u}Yg.prototype.unstable_scheduleHydration=function(u){if(u){var h=hl();u={blockedOn:null,target:u,priority:h};for(var m=0;m<Ao.length&&h!==0&&h<Ao[m].priority;m++);Ao.splice(m,0,u),m===0&&yN(u)}};var vN=e.version;if(vN!=="19.1.0")throw Error(s(527,vN,"19.1.0"));te.findDOMNode=function(u){var h=u._reactInternals;if(h===void 0)throw typeof u.render=="function"?Error(s(188)):(u=Object.keys(u).join(","),Error(s(268,u)));return u=l(h),u=u!==null?c(u):null,u=u===null?null:u.stateNode,u};var RL={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:G,reconcilerVersion:"19.1.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Qg=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Qg.isDisabled&&Qg.supportsFiber)try{is=Qg.inject(RL),hn=Qg}catch{}}return Nf.createRoot=function(u,h){if(!r(u))throw Error(s(299));var m=!1,y="",S=z$,k=L$,F=P$,V=null;return h!=null&&(h.unstable_strictMode===!0&&(m=!0),h.identifierPrefix!==void 0&&(y=h.identifierPrefix),h.onUncaughtError!==void 0&&(S=h.onUncaughtError),h.onCaughtError!==void 0&&(k=h.onCaughtError),h.onRecoverableError!==void 0&&(F=h.onRecoverableError),h.unstable_transitionCallbacks!==void 0&&(V=h.unstable_transitionCallbacks)),h=cN(u,1,!1,null,null,m,y,S,k,F,V,null),u[zs]=h.current,uv(u),new Iv(h)},Nf.hydrateRoot=function(u,h,m){if(!r(u))throw Error(s(299));var y=!1,S="",k=z$,F=L$,V=P$,Z=null,ye=null;return m!=null&&(m.unstable_strictMode===!0&&(y=!0),m.identifierPrefix!==void 0&&(S=m.identifierPrefix),m.onUncaughtError!==void 0&&(k=m.onUncaughtError),m.onCaughtError!==void 0&&(F=m.onCaughtError),m.onRecoverableError!==void 0&&(V=m.onRecoverableError),m.unstable_transitionCallbacks!==void 0&&(Z=m.unstable_transitionCallbacks),m.formState!==void 0&&(ye=m.formState)),h=cN(u,1,!0,h,m??null,y,S,k,F,V,Z,ye),h.context=hN(null),m=h.current,y=Pr(),y=cl(y),S=po(y),S.callback=null,mo(m,S,y),m=y,h.current.lanes=m,io(h,m),sa(h),u[zs]=h.current,uv(u),new Yg(h)},Nf.version="19.1.0",Nf}var AN;function UL(){if(AN)return Rv.exports;AN=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),Rv.exports=VL(),Rv.exports}var WL=UL(),fy={exports:{}},GL=fy.exports,DN;function HL(){return DN||(DN=1,function(n,e){(function(s,r){n.exports=r(ox())})(GL,function(t){return function(s){var r={};function i(a){if(r[a])return r[a].exports;var o=r[a]={i:a,l:!1,exports:{}};return s[a].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=s,i.c=r,i.d=function(a,o,l){i.o(a,o)||Object.defineProperty(a,o,{enumerable:!0,get:l})},i.r=function(a){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})},i.t=function(a,o){if(o&1&&(a=i(a)),o&8||o&4&&typeof a=="object"&&a&&a.__esModule)return a;var l=Object.create(null);if(i.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:a}),o&2&&typeof a!="string")for(var c in a)i.d(l,c,(function(d){return a[d]}).bind(null,c));return l},i.n=function(a){var o=a&&a.__esModule?function(){return a.default}:function(){return a};return i.d(o,"a",o),o},i.o=function(a,o){return Object.prototype.hasOwnProperty.call(a,o)},i.p="",i(i.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(s,r,i){i.r(r);var a=i("react"),o=function(){var p=function(g,x){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,v){b.__proto__=v}||function(b,v){for(var w in v)v.hasOwnProperty(w)&&(b[w]=v[w])},p(g,x)};return function(g,x){p(g,x);function b(){this.constructor=g}g.prototype=x===null?Object.create(x):(b.prototype=x.prototype,new b)}}(),l=function(){return l=Object.assign||function(p){for(var g,x=1,b=arguments.length;x<b;x++){g=arguments[x];for(var v in g)Object.prototype.hasOwnProperty.call(g,v)&&(p[v]=g[v])}return p},l.apply(this,arguments)},c=function(p,g){var x={};for(var b in p)Object.prototype.hasOwnProperty.call(p,b)&&g.indexOf(b)<0&&(x[b]=p[b]);if(p!=null&&typeof Object.getOwnPropertySymbols=="function")for(var v=0,b=Object.getOwnPropertySymbols(p);v<b.length;v++)g.indexOf(b[v])<0&&Object.prototype.propertyIsEnumerable.call(p,b[v])&&(x[b[v]]=p[b[v]]);return x};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(g){var x=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return x?new Promise(function(b,v){x.call(navigator,g,b,v)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function d(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var f=function(p){o(g,p);function g(x){var b=p.call(this,x)||this;return b.canvas=null,b.ctx=null,b.requestUserMediaId=0,b.unmounted=!1,b.state={hasUserMedia:!1},b}return g.prototype.componentDidMount=function(){var x=this,b=x.state,v=x.props;if(this.unmounted=!1,!d()){v.onUserMediaError("getUserMedia not supported");return}b.hasUserMedia||this.requestUserMedia(),v.children&&typeof v.children!="function"&&console.warn("children must be a function")},g.prototype.componentDidUpdate=function(x){var b=this.props;if(!d()){b.onUserMediaError("getUserMedia not supported");return}var v=JSON.stringify(x.audioConstraints)!==JSON.stringify(b.audioConstraints),w=JSON.stringify(x.videoConstraints)!==JSON.stringify(b.videoConstraints),$=x.minScreenshotWidth!==b.minScreenshotWidth,I=x.minScreenshotHeight!==b.minScreenshotHeight;(w||$||I)&&(this.canvas=null,this.ctx=null),(v||w)&&(this.stopAndCleanup(),this.requestUserMedia())},g.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},g.stopMediaStream=function(x){x&&(x.getVideoTracks&&x.getAudioTracks?(x.getVideoTracks().map(function(b){x.removeTrack(b),b.stop()}),x.getAudioTracks().map(function(b){x.removeTrack(b),b.stop()})):x.stop())},g.prototype.stopAndCleanup=function(){var x=this.state;x.hasUserMedia&&(g.stopMediaStream(this.stream),x.src&&window.URL.revokeObjectURL(x.src))},g.prototype.getScreenshot=function(x){var b=this,v=b.state,w=b.props;if(!v.hasUserMedia)return null;var $=this.getCanvas(x);return $&&$.toDataURL(w.screenshotFormat,w.screenshotQuality)},g.prototype.getCanvas=function(x){var b=this,v=b.state,w=b.props;if(!this.video||!v.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var $=this.video.videoWidth,I=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var N=$/I;$=w.minScreenshotWidth||this.video.clientWidth,I=$/N,w.minScreenshotHeight&&I<w.minScreenshotHeight&&(I=w.minScreenshotHeight,$=I*N)}this.canvas=document.createElement("canvas"),this.canvas.width=x?.width||$,this.canvas.height=x?.height||I,this.ctx=this.canvas.getContext("2d")}var E=this,D=E.ctx,O=E.canvas;return D&&O&&(O.width=x?.width||O.width,O.height=x?.height||O.height,w.mirrored&&(D.translate(O.width,0),D.scale(-1,1)),D.imageSmoothingEnabled=w.imageSmoothing,D.drawImage(this.video,0,0,x?.width||O.width,x?.height||O.height),w.mirrored&&(D.scale(-1,1),D.translate(-O.width,0))),O},g.prototype.requestUserMedia=function(){var x=this,b=this.props,v=function(I,N){var E={video:typeof N<"u"?N:!0};b.audio&&(E.audio=typeof I<"u"?I:!0),x.requestUserMediaId++;var D=x.requestUserMediaId;navigator.mediaDevices.getUserMedia(E).then(function(O){x.unmounted||D!==x.requestUserMediaId?g.stopMediaStream(O):x.handleUserMedia(null,O)}).catch(function(O){x.handleUserMedia(O)})};if("mediaDevices"in navigator)v(b.audioConstraints,b.videoConstraints);else{var w=function(I){return{optional:[{sourceId:I}]}},$=function(I){var N=I.deviceId;return typeof N=="string"?N:Array.isArray(N)&&N.length>0?N[0]:typeof N=="object"&&N.ideal?N.ideal:null};MediaStreamTrack.getSources(function(I){var N=null,E=null;I.forEach(function(L){L.kind==="audio"?N=L.id:L.kind==="video"&&(E=L.id)});var D=$(b.audioConstraints);D&&(N=D);var O=$(b.videoConstraints);O&&(E=O),v(w(N),w(E))})}},g.prototype.handleUserMedia=function(x,b){var v=this.props;if(x||!b){this.setState({hasUserMedia:!1}),v.onUserMediaError(x);return}this.stream=b;try{this.video&&(this.video.srcObject=b),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(b)})}v.onUserMedia(b)},g.prototype.render=function(){var x=this,b=this,v=b.state,w=b.props,$=w.audio;w.forceScreenshotSourceSize;var I=w.disablePictureInPicture;w.onUserMedia,w.onUserMediaError,w.screenshotFormat,w.screenshotQuality,w.minScreenshotWidth,w.minScreenshotHeight,w.audioConstraints,w.videoConstraints,w.imageSmoothing;var N=w.mirrored,E=w.style,D=E===void 0?{}:E,O=w.children,L=c(w,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),z=N?l(l({},D),{transform:(D.transform||"")+" scaleX(-1)"}):D,P={getScreenshot:this.getScreenshot.bind(this)};return a.createElement(a.Fragment,null,a.createElement("video",l({autoPlay:!0,disablePictureInPicture:I,src:v.src,muted:!$,playsInline:!0,ref:function(_){x.video=_},style:z},L)),O&&O(P))},g.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},g}(a.Component);r.default=f},react:function(s,r){s.exports=t}}).default})}(fy)),fy.exports}var jL=HL();const qL=bE(jL);function XL({webcamRef:n,canvasRef:e}){return Ga.jsxs("div",{className:"camera-container",children:[Ga.jsx(qL,{ref:n,mirrored:!0,width:640,height:480,className:"camera-video"}),Ga.jsx("canvas",{ref:e,width:640,height:480,className:"camera-canvas"})]})}var Ov={},_N;function KL(){return _N||(_N=1,(function(){var n;function e(C){var T=0;return function(){return T<C.length?{done:!1,value:C[T++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(C,T,A){return C==Array.prototype||C==Object.prototype||(C[T]=A.value),C};function s(C){C=[typeof globalThis=="object"&&globalThis,C,typeof window=="object"&&window,typeof self=="object"&&self,typeof wN=="object"&&wN];for(var T=0;T<C.length;++T){var A=C[T];if(A&&A.Math==Math)return A}throw Error("Cannot find global object")}var r=s(this);function i(C,T){if(T)e:{var A=r;C=C.split(".");for(var M=0;M<C.length-1;M++){var j=C[M];if(!(j in A))break e;A=A[j]}C=C[C.length-1],M=A[C],T=T(M),T!=M&&T!=null&&t(A,C,{configurable:!0,writable:!0,value:T})}}i("Symbol",function(C){function T(K){if(this instanceof T)throw new TypeError("Symbol is not a constructor");return new A(M+(K||"")+"_"+j++,K)}function A(K,X){this.h=K,t(this,"description",{configurable:!0,writable:!0,value:X})}if(C)return C;A.prototype.toString=function(){return this.h};var M="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",j=0;return T}),i("Symbol.iterator",function(C){if(C)return C;C=Symbol("Symbol.iterator");for(var T="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),A=0;A<T.length;A++){var M=r[T[A]];typeof M=="function"&&typeof M.prototype[C]!="function"&&t(M.prototype,C,{configurable:!0,writable:!0,value:function(){return a(e(this))}})}return C});function a(C){return C={next:C},C[Symbol.iterator]=function(){return this},C}function o(C){var T=typeof Symbol<"u"&&Symbol.iterator&&C[Symbol.iterator];return T?T.call(C):{next:e(C)}}function l(C){if(!(C instanceof Array)){C=o(C);for(var T,A=[];!(T=C.next()).done;)A.push(T.value);C=A}return C}var c=typeof Object.assign=="function"?Object.assign:function(C,T){for(var A=1;A<arguments.length;A++){var M=arguments[A];if(M)for(var j in M)Object.prototype.hasOwnProperty.call(M,j)&&(C[j]=M[j])}return C};i("Object.assign",function(C){return C||c});var d=typeof Object.create=="function"?Object.create:function(C){function T(){}return T.prototype=C,new T},f;if(typeof Object.setPrototypeOf=="function")f=Object.setPrototypeOf;else{var p;e:{var g={a:!0},x={};try{x.__proto__=g,p=x.a;break e}catch{}p=!1}f=p?function(C,T){if(C.__proto__=T,C.__proto__!==T)throw new TypeError(C+" is not extensible");return C}:null}var b=f;function v(C,T){if(C.prototype=d(T.prototype),C.prototype.constructor=C,b)b(C,T);else for(var A in T)if(A!="prototype")if(Object.defineProperties){var M=Object.getOwnPropertyDescriptor(T,A);M&&Object.defineProperty(C,A,M)}else C[A]=T[A];C.za=T.prototype}function w(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function $(C){if(C.m)throw new TypeError("Generator is already running");C.m=!0}w.prototype.u=function(C){this.i=C};function I(C,T){C.l={ma:T,na:!0},C.h=C.s||C.v}w.prototype.return=function(C){this.l={return:C},this.h=this.v};function N(C,T,A){return C.h=A,{value:T}}function E(C){this.h=new w,this.i=C}function D(C,T){$(C.h);var A=C.h.j;return A?O(C,"return"in A?A.return:function(M){return{value:M,done:!0}},T,C.h.return):(C.h.return(T),L(C))}function O(C,T,A,M){try{var j=T.call(C.h.j,A);if(!(j instanceof Object))throw new TypeError("Iterator result "+j+" is not an object");if(!j.done)return C.h.m=!1,j;var K=j.value}catch(X){return C.h.j=null,I(C.h,X),L(C)}return C.h.j=null,M.call(C.h,K),L(C)}function L(C){for(;C.h.h;)try{var T=C.i(C.h);if(T)return C.h.m=!1,{value:T.value,done:!1}}catch(A){C.h.i=void 0,I(C.h,A)}if(C.h.m=!1,C.h.l){if(T=C.h.l,C.h.l=null,T.na)throw T.ma;return{value:T.return,done:!0}}return{value:void 0,done:!0}}function z(C){this.next=function(T){return $(C.h),C.h.j?T=O(C,C.h.j.next,T,C.h.u):(C.h.u(T),T=L(C)),T},this.throw=function(T){return $(C.h),C.h.j?T=O(C,C.h.j.throw,T,C.h.u):(I(C.h,T),T=L(C)),T},this.return=function(T){return D(C,T)},this[Symbol.iterator]=function(){return this}}function P(C){function T(M){return C.next(M)}function A(M){return C.throw(M)}return new Promise(function(M,j){function K(X){X.done?M(X.value):Promise.resolve(X.value).then(T,A).then(K,j)}K(C.next())})}function _(C){return P(new z(new E(C)))}i("Promise",function(C){function T(X){this.i=0,this.j=void 0,this.h=[],this.u=!1;var oe=this.l();try{X(oe.resolve,oe.reject)}catch(be){oe.reject(be)}}function A(){this.h=null}function M(X){return X instanceof T?X:new T(function(oe){oe(X)})}if(C)return C;A.prototype.i=function(X){if(this.h==null){this.h=[];var oe=this;this.j(function(){oe.m()})}this.h.push(X)};var j=r.setTimeout;A.prototype.j=function(X){j(X,0)},A.prototype.m=function(){for(;this.h&&this.h.length;){var X=this.h;this.h=[];for(var oe=0;oe<X.length;++oe){var be=X[oe];X[oe]=null;try{be()}catch(Re){this.l(Re)}}}this.h=null},A.prototype.l=function(X){this.j(function(){throw X})},T.prototype.l=function(){function X(Re){return function(Fe){be||(be=!0,Re.call(oe,Fe))}}var oe=this,be=!1;return{resolve:X(this.I),reject:X(this.m)}},T.prototype.I=function(X){if(X===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(X instanceof T)this.L(X);else{e:switch(typeof X){case"object":var oe=X!=null;break e;case"function":oe=!0;break e;default:oe=!1}oe?this.F(X):this.s(X)}},T.prototype.F=function(X){var oe=void 0;try{oe=X.then}catch(be){this.m(be);return}typeof oe=="function"?this.M(oe,X):this.s(X)},T.prototype.m=function(X){this.v(2,X)},T.prototype.s=function(X){this.v(1,X)},T.prototype.v=function(X,oe){if(this.i!=0)throw Error("Cannot settle("+X+", "+oe+"): Promise already settled in state"+this.i);this.i=X,this.j=oe,this.i===2&&this.K(),this.H()},T.prototype.K=function(){var X=this;j(function(){if(X.D()){var oe=r.console;typeof oe<"u"&&oe.error(X.j)}},1)},T.prototype.D=function(){if(this.u)return!1;var X=r.CustomEvent,oe=r.Event,be=r.dispatchEvent;return typeof be>"u"?!0:(typeof X=="function"?X=new X("unhandledrejection",{cancelable:!0}):typeof oe=="function"?X=new oe("unhandledrejection",{cancelable:!0}):(X=r.document.createEvent("CustomEvent"),X.initCustomEvent("unhandledrejection",!1,!0,X)),X.promise=this,X.reason=this.j,be(X))},T.prototype.H=function(){if(this.h!=null){for(var X=0;X<this.h.length;++X)K.i(this.h[X]);this.h=null}};var K=new A;return T.prototype.L=function(X){var oe=this.l();X.T(oe.resolve,oe.reject)},T.prototype.M=function(X,oe){var be=this.l();try{X.call(oe,be.resolve,be.reject)}catch(Re){be.reject(Re)}},T.prototype.then=function(X,oe){function be(Ze,Ve){return typeof Ze=="function"?function(rt){try{Re(Ze(rt))}catch(mt){Fe(mt)}}:Ve}var Re,Fe,ot=new T(function(Ze,Ve){Re=Ze,Fe=Ve});return this.T(be(X,Re),be(oe,Fe)),ot},T.prototype.catch=function(X){return this.then(void 0,X)},T.prototype.T=function(X,oe){function be(){switch(Re.i){case 1:X(Re.j);break;case 2:oe(Re.j);break;default:throw Error("Unexpected state: "+Re.i)}}var Re=this;this.h==null?K.i(be):this.h.push(be),this.u=!0},T.resolve=M,T.reject=function(X){return new T(function(oe,be){be(X)})},T.race=function(X){return new T(function(oe,be){for(var Re=o(X),Fe=Re.next();!Fe.done;Fe=Re.next())M(Fe.value).T(oe,be)})},T.all=function(X){var oe=o(X),be=oe.next();return be.done?M([]):new T(function(Re,Fe){function ot(rt){return function(mt){Ze[rt]=mt,Ve--,Ve==0&&Re(Ze)}}var Ze=[],Ve=0;do Ze.push(void 0),Ve++,M(be.value).T(ot(Ze.length-1),Fe),be=oe.next();while(!be.done)})},T});function H(C,T){C instanceof String&&(C+="");var A=0,M=!1,j={next:function(){if(!M&&A<C.length){var K=A++;return{value:T(K,C[K]),done:!1}}return M=!0,{done:!0,value:void 0}}};return j[Symbol.iterator]=function(){return j},j}i("Array.prototype.keys",function(C){return C||function(){return H(this,function(T){return T})}}),i("Array.prototype.fill",function(C){return C||function(T,A,M){var j=this.length||0;for(0>A&&(A=Math.max(0,j+A)),(M==null||M>j)&&(M=j),M=Number(M),0>M&&(M=Math.max(0,j+M)),A=Number(A||0);A<M;A++)this[A]=T;return this}});function q(C){return C||Array.prototype.fill}i("Int8Array.prototype.fill",q),i("Uint8Array.prototype.fill",q),i("Uint8ClampedArray.prototype.fill",q),i("Int16Array.prototype.fill",q),i("Uint16Array.prototype.fill",q),i("Int32Array.prototype.fill",q),i("Uint32Array.prototype.fill",q),i("Float32Array.prototype.fill",q),i("Float64Array.prototype.fill",q),i("Object.is",function(C){return C||function(T,A){return T===A?T!==0||1/T===1/A:T!==T&&A!==A}}),i("Array.prototype.includes",function(C){return C||function(T,A){var M=this;M instanceof String&&(M=String(M));var j=M.length;for(A=A||0,0>A&&(A=Math.max(A+j,0));A<j;A++){var K=M[A];if(K===T||Object.is(K,T))return!0}return!1}}),i("String.prototype.includes",function(C){return C||function(T,A){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(T instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(T,A||0)!==-1}});var ee=this||self;function Y(C,T){C=C.split(".");var A=ee;C[0]in A||typeof A.execScript>"u"||A.execScript("var "+C[0]);for(var M;C.length&&(M=C.shift());)C.length||T===void 0?A[M]&&A[M]!==Object.prototype[M]?A=A[M]:A=A[M]={}:A[M]=T}function G(C){var T;e:{if((T=ee.navigator)&&(T=T.userAgent))break e;T=""}return T.indexOf(C)!=-1}var te=Array.prototype.map?function(C,T){return Array.prototype.map.call(C,T,void 0)}:function(C,T){for(var A=C.length,M=Array(A),j=typeof C=="string"?C.split(""):C,K=0;K<A;K++)K in j&&(M[K]=T.call(void 0,j[K],K,C));return M},re={},he=null;function W(C){var T=C.length,A=3*T/4;A%3?A=Math.floor(A):"=.".indexOf(C[T-1])!=-1&&(A="=.".indexOf(C[T-2])!=-1?A-2:A-1);var M=new Uint8Array(A),j=0;return ne(C,function(K){M[j++]=K}),j!==A?M.subarray(0,j):M}function ne(C,T){function A(be){for(;M<C.length;){var Re=C.charAt(M++),Fe=he[Re];if(Fe!=null)return Fe;if(!/^[\s\xa0]*$/.test(Re))throw Error("Unknown base64 encoding at char: "+Re)}return be}pe();for(var M=0;;){var j=A(-1),K=A(0),X=A(64),oe=A(64);if(oe===64&&j===-1)break;T(j<<2|K>>4),X!=64&&(T(K<<4&240|X>>2),oe!=64&&T(X<<6&192|oe))}}function pe(){if(!he){he={};for(var C="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),T=["+/=","+/","-_=","-_.","-_"],A=0;5>A;A++){var M=C.concat(T[A].split(""));re[A]=M;for(var j=0;j<M.length;j++){var K=M[j];he[K]===void 0&&(he[K]=j)}}}}var de=typeof Uint8Array<"u",we=!(G("Trident")||G("MSIE"))&&typeof ee.btoa=="function";function ke(C){if(!we){var T;T===void 0&&(T=0),pe(),T=re[T];for(var A=Array(Math.floor(C.length/3)),M=T[64]||"",j=0,K=0;j<C.length-2;j+=3){var X=C[j],oe=C[j+1],be=C[j+2],Re=T[X>>2];X=T[(X&3)<<4|oe>>4],oe=T[(oe&15)<<2|be>>6],be=T[be&63],A[K++]=Re+X+oe+be}switch(Re=0,be=M,C.length-j){case 2:Re=C[j+1],be=T[(Re&15)<<2]||M;case 1:C=C[j],A[K]=T[C>>2]+T[(C&3)<<4|Re>>4]+be+M}return A.join("")}for(T="";10240<C.length;)T+=String.fromCharCode.apply(null,C.subarray(0,10240)),C=C.subarray(10240);return T+=String.fromCharCode.apply(null,C),btoa(T)}var Ne=RegExp("[-_.]","g");function Ue(C){switch(C){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function Le(C){if(!we)return W(C);Ne.test(C)&&(C=C.replace(Ne,Ue)),C=atob(C);for(var T=new Uint8Array(C.length),A=0;A<C.length;A++)T[A]=C.charCodeAt(A);return T}var Ge;function at(){return Ge||(Ge=new Uint8Array(0))}var nt={},Tt=typeof Uint8Array.prototype.slice=="function",st=0,gt=0;function Bt(C){var T=0>C;C=Math.abs(C);var A=C>>>0;C=Math.floor((C-A)/4294967296),T&&(A=o($t(A,C)),T=A.next().value,C=A.next().value,A=T),st=A>>>0,gt=C>>>0}var Pt=typeof BigInt=="function";function $t(C,T){return T=~T,C?C=~C+1:T+=1,[C,T]}function Ht(C,T){this.i=C>>>0,this.h=T>>>0}function Ys(C){if(!C)return gn||(gn=new Ht(0,0));if(!/^-?\d+$/.test(C))return null;if(16>C.length)Bt(Number(C));else if(Pt)C=BigInt(C),st=Number(C&BigInt(4294967295))>>>0,gt=Number(C>>BigInt(32)&BigInt(4294967295));else{var T=+(C[0]==="-");gt=st=0;for(var A=C.length,M=T,j=(A-T)%6+T;j<=A;M=j,j+=6)M=Number(C.slice(M,j)),gt*=1e6,st=1e6*st+M,4294967296<=st&&(gt+=st/4294967296|0,st%=4294967296);T&&(T=o($t(st,gt)),C=T.next().value,T=T.next().value,st=C,gt=T)}return new Ht(st,gt)}var gn;function Os(C,T){return Error("Invalid wire type: "+C+" (at position "+T+")")}function rs(){return Error("Failed to read varint, encoding is invalid.")}function Rr(C,T){return Error("Tried to read past the end of the data "+T+" > "+C)}function Ln(){throw Error("Invalid UTF8")}function hr(C,T){return T=String.fromCharCode.apply(null,T),C==null?T:C+T}var is=void 0,hn,as=typeof TextDecoder<"u",Tn,ul=typeof TextEncoder<"u",no;function zu(C){if(C!==nt)throw Error("illegal external caller")}function Qs(C,T){if(zu(T),this.V=C,C!=null&&C.length===0)throw Error("ByteString should be constructed with non-empty values")}function Hi(){return no||(no=new Qs(null,nt))}function Kr(C){zu(nt);var T=C.V;return T=T==null||de&&T!=null&&T instanceof Uint8Array?T:typeof T=="string"?Le(T):null,T==null?T:C.V=T}function Lu(C){if(typeof C=="string")return{buffer:Le(C),C:!1};if(Array.isArray(C))return{buffer:new Uint8Array(C),C:!1};if(C.constructor===Uint8Array)return{buffer:C,C:!1};if(C.constructor===ArrayBuffer)return{buffer:new Uint8Array(C),C:!1};if(C.constructor===Qs)return{buffer:Kr(C)||at(),C:!0};if(C instanceof Uint8Array)return{buffer:new Uint8Array(C.buffer,C.byteOffset,C.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function so(C,T){this.i=null,this.m=!1,this.h=this.j=this.l=0,Sd(this,C,T)}function Sd(C,T,A){A=A===void 0?{}:A,C.S=A.S===void 0?!1:A.S,T&&(T=Lu(T),C.i=T.buffer,C.m=T.C,C.l=0,C.j=C.i.length,C.h=C.l)}so.prototype.reset=function(){this.h=this.l};function ji(C,T){if(C.h=T,T>C.j)throw Rr(C.j,T)}function ro(C){var T=C.i,A=C.h,M=T[A++],j=M&127;if(M&128&&(M=T[A++],j|=(M&127)<<7,M&128&&(M=T[A++],j|=(M&127)<<14,M&128&&(M=T[A++],j|=(M&127)<<21,M&128&&(M=T[A++],j|=M<<28,M&128&&T[A++]&128&&T[A++]&128&&T[A++]&128&&T[A++]&128&&T[A++]&128)))))throw rs();return ji(C,A),j}function Pu(C,T){if(0>T)throw Error("Tried to read a negative byte length: "+T);var A=C.h,M=A+T;if(M>C.j)throw Rr(T,C.j-A);return C.h=M,A}var io=[];function Cd(){this.h=[]}Cd.prototype.length=function(){return this.h.length},Cd.prototype.end=function(){var C=this.h;return this.h=[],C};function $d(C,T,A){for(;0<A||127<T;)C.h.push(T&127|128),T=(T>>>7|A<<25)>>>0,A>>>=7;C.h.push(T)}function qi(C,T){for(;127<T;)C.h.push(T&127|128),T>>>=7;C.h.push(T)}function cl(C,T){if(io.length){var A=io.pop();Sd(A,C,T),C=A}else C=new so(C,T);this.h=C,this.j=this.h.h,this.i=this.l=-1,this.setOptions(T)}cl.prototype.setOptions=function(C){C=C===void 0?{}:C,this.ca=C.ca===void 0?!1:C.ca},cl.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function Mu(C){var T=C.h;if(T.h==T.j)return!1;C.j=C.h.h;var A=ro(C.h)>>>0;if(T=A>>>3,A&=7,!(0<=A&&5>=A))throw Os(A,C.j);if(1>T)throw Error("Invalid field number: "+T+" (at position "+C.j+")");return C.l=T,C.i=A,!0}function hl(C){switch(C.i){case 0:if(C.i!=0)hl(C);else e:{C=C.h;for(var T=C.h,A=T+10,M=C.i;T<A;)if((M[T++]&128)===0){ji(C,T);break e}throw rs()}break;case 1:C=C.h,ji(C,C.h+8);break;case 2:C.i!=2?hl(C):(T=ro(C.h)>>>0,C=C.h,ji(C,C.h+T));break;case 5:C=C.h,ji(C,C.h+4);break;case 3:T=C.l;do{if(!Mu(C))throw Error("Unmatched start-group tag: stream EOF");if(C.i==4){if(C.l!=T)throw Error("Unmatched end-group tag");break}hl(C)}while(!0);break;default:throw Os(C.i,C.j)}}var Bu=[];function Xi(){this.j=[],this.i=0,this.h=new Cd}function wn(C,T){T.length!==0&&(C.j.push(T),C.i+=T.length)}function Fs(C,T){if(T=T.R){wn(C,C.h.end());for(var A=0;A<T.length;A++)wn(C,Kr(T[A])||at())}}var zs=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Si(C,T){return zs?C[zs]|=T:C.A!==void 0?C.A|=T:(Object.defineProperties(C,{A:{value:T,configurable:!0,writable:!0,enumerable:!1}}),T)}function Fm(C,T){zs?C[zs]&&(C[zs]&=~T):C.A!==void 0&&(C.A&=~T)}function Sn(C){var T;return zs?T=C[zs]:T=C.A,T??0}function Ar(C,T){zs?C[zs]=T:C.A!==void 0?C.A=T:Object.defineProperties(C,{A:{value:T,configurable:!0,writable:!0,enumerable:!1}})}function Sa(C){return Si(C,1),C}function kd(C,T){Ar(T,(C|0)&-51)}function Ci(C,T){Ar(T,(C|18)&-41)}var Ki={};function Yi(C){return C!==null&&typeof C=="object"&&!Array.isArray(C)&&C.constructor===Object}var Yr,Pn=[];Ar(Pn,23),Yr=Object.freeze(Pn);function Vu(C){if(Sn(C.o)&2)throw Error("Cannot mutate an immutable Message")}function Uu(C){var T=C.length;(T=T?C[T-1]:void 0)&&Yi(T)?T.g=1:(T={},C.push((T.g=1,T)))}function Qi(C){var T=C.i+C.G;return C.B||(C.B=C.o[T]={})}function ps(C,T){return T===-1?null:T>=C.i?C.B?C.B[T]:void 0:C.o[T+C.G]}function Qr(C,T,A,M){Vu(C),ao(C,T,A,M)}function ao(C,T,A,M){C.j&&(C.j=void 0),T>=C.i||M?Qi(C)[T]=A:(C.o[T+C.G]=A,(C=C.B)&&T in C&&delete C[T])}function Wu(C,T,A,M){var j=ps(C,T);Array.isArray(j)||(j=Yr);var K=Sn(j);if(K&1||Sa(j),M)K&2||Si(j,2),A&1||Object.freeze(j);else{M=!(A&2);var X=K&2;A&1||!X?M&&K&16&&!X&&Fm(j,16):(j=Sa(Array.prototype.slice.call(j)),ao(C,T,j))}return j}function Nd(C,T){var A=ps(C,T),M=A==null?A:typeof A=="number"||A==="NaN"||A==="Infinity"||A==="-Infinity"?Number(A):void 0;return M!=null&&M!==A&&ao(C,T,M),M}function dl(C,T,A,M,j){C.h||(C.h={});var K=C.h[A],X=Wu(C,A,3,j);if(!K){var oe=X;K=[];var be=!!(Sn(C.o)&16);X=!!(Sn(oe)&2);var Re=oe;!j&&X&&(oe=Array.prototype.slice.call(oe));for(var Fe=X,ot=0;ot<oe.length;ot++){var Ze=oe[ot],Ve=T,rt=!1;if(rt=rt===void 0?!1:rt,Ze=Array.isArray(Ze)?new Ve(Ze):rt?new Ve:void 0,Ze!==void 0){Ve=Ze.o;var mt=rt=Sn(Ve);X&&(mt|=2),be&&(mt|=16),mt!=rt&&Ar(Ve,mt),Ve=mt,Fe=Fe||!!(2&Ve),K.push(Ze)}}return C.h[A]=K,be=Sn(oe),T=be|33,T=Fe?T&-9:T|8,be!=T&&(Fe=oe,Object.isFrozen(Fe)&&(Fe=Array.prototype.slice.call(Fe)),Ar(Fe,T),oe=Fe),Re!==oe&&ao(C,A,oe),(j||M&&X)&&Si(K,2),M&&Object.freeze(K),K}return j||(j=Object.isFrozen(K),M&&!j?Object.freeze(K):!M&&j&&(K=Array.prototype.slice.call(K),C.h[A]=K)),K}function oo(C,T,A){var M=!!(Sn(C.o)&2);if(T=dl(C,T,A,M,M),C=Wu(C,A,3,M),!(M||Sn(C)&8)){for(M=0;M<T.length;M++){if(A=T[M],Sn(A.o)&2){var j=ml(A,!1);j.j=A}else j=A;A!==j&&(T[M]=j,C[M]=j.o)}Si(C,8)}return T}function Hn(C,T,A){if(A!=null&&typeof A!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof A+": "+A);Qr(C,T,A)}function Gu(C,T,A,M,j){Vu(C);var K=dl(C,A,T,!1,!1);return A=M??new A,C=Wu(C,T,2,!1),j!=null?(K.splice(j,0,A),C.splice(j,0,A.o)):(K.push(A),C.push(A.o)),A.C()&&Fm(C,8),A}function fl(C,T){return C??T}function ks(C,T,A){return A=A===void 0?0:A,fl(Nd(C,T),A)}var lo;function Id(C){switch(typeof C){case"number":return isFinite(C)?C:String(C);case"object":if(C)if(Array.isArray(C)){if((Sn(C)&128)!==0)return C=Array.prototype.slice.call(C),Uu(C),C}else{if(de&&C!=null&&C instanceof Uint8Array)return ke(C);if(C instanceof Qs){var T=C.V;return T==null?"":typeof T=="string"?T:C.V=ke(T)}}}return C}function zm(C,T,A,M){if(C!=null){if(Array.isArray(C))C=Hu(C,T,A,M!==void 0);else if(Yi(C)){var j={},K;for(K in C)j[K]=zm(C[K],T,A,M);C=j}else C=T(C,M);return C}}function Hu(C,T,A,M){var j=Sn(C);M=M?!!(j&16):void 0,C=Array.prototype.slice.call(C);for(var K=0;K<C.length;K++)C[K]=zm(C[K],T,A,M);return A(j,C),C}function dr(C){return C.ja===Ki?C.toJSON():Id(C)}function Lm(C,T){C&128&&Uu(T)}function Pm(C,T,A){if(A=A===void 0?Ci:A,C!=null){if(de&&C instanceof Uint8Array)return C.length?new Qs(new Uint8Array(C),nt):Hi();if(Array.isArray(C)){var M=Sn(C);return M&2?C:T&&!(M&32)&&(M&16||M===0)?(Ar(C,M|2),C):(C=Hu(C,Pm,M&4?Ci:A,!0),T=Sn(C),T&4&&T&2&&Object.freeze(C),C)}return C.ja===Ki?Td(C):C}}function pl(C,T,A,M,j,K,X){if(C=C.h&&C.h[A]){if(M=Sn(C),M&2?M=C:(K=te(C,Td),Ci(M,K),Object.freeze(K),M=K),Vu(T),X=M==null?Yr:Sa([]),M!=null){for(K=!!M.length,C=0;C<M.length;C++){var oe=M[C];K=K&&!(Sn(oe.o)&2),X[C]=oe.o}K=(K?8:0)|1,C=Sn(X),(C&K)!==K&&(Object.isFrozen(X)&&(X=Array.prototype.slice.call(X)),Ar(X,C|K)),T.h||(T.h={}),T.h[A]=M}else T.h&&(T.h[A]=void 0);ao(T,A,X,j)}else Qr(T,A,Pm(M,K,X),j)}function Td(C){return Sn(C.o)&2||(C=ml(C,!0),Si(C.o,2)),C}function ml(C,T){var A=C.o,M=[];Si(M,16);var j=C.constructor.h;if(j&&M.push(j),j=C.B,j){M.length=A.length,M.fill(void 0,M.length,A.length);var K={};M[M.length-1]=K}(Sn(A)&128)!==0&&Uu(M),T=T||C.C()?Ci:kd,K=C.constructor,lo=M,M=new K(M),lo=void 0,C.R&&(M.R=C.R.slice()),K=!!(Sn(A)&16);for(var X=j?A.length-1:A.length,oe=0;oe<X;oe++)pl(C,M,oe-C.G,A[oe],!1,K,T);if(j)for(var be in j)pl(C,M,+be,j[be],!0,K,T);return M}function Ls(C,T,A){C==null&&(C=lo),lo=void 0;var M=this.constructor.i||0,j=0<M,K=this.constructor.h,X=!1;if(C==null){C=K?[K]:[];var oe=48,be=!0;j&&(M=0,oe|=128),Ar(C,oe)}else{if(!Array.isArray(C)||K&&K!==C[0])throw Error();var Re=oe=Si(C,0);if((be=(16&Re)!==0)&&((X=(32&Re)!==0)||(Re|=32)),j){if(128&Re)M=0;else if(0<C.length){var Fe=C[C.length-1];if(Yi(Fe)&&"g"in Fe){M=0,Re|=128,delete Fe.g;var ot=!0,Ze;for(Ze in Fe){ot=!1;break}ot&&C.pop()}}}else if(128&Re)throw Error();oe!==Re&&Ar(C,Re)}this.G=(K?0:-1)-M,this.h=void 0,this.o=C;e:{if(K=this.o.length,M=K-1,K&&(K=this.o[M],Yi(K))){this.B=K,this.i=M-this.G;break e}T!==void 0&&-1<T?(this.i=Math.max(T,M+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!j&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(A){T=be&&!X&&!0,j=this.i;var Ve;for(be=0;be<A.length;be++)X=A[be],X<j?(X+=this.G,(M=C[X])?Zs(M,T):C[X]=Yr):(Ve||(Ve=Qi(this)),(M=Ve[X])?Zs(M,T):Ve[X]=Yr)}}Ls.prototype.toJSON=function(){return Hu(this.o,dr,Lm)},Ls.prototype.C=function(){return!!(Sn(this.o)&2)};function Zs(C,T){if(Array.isArray(C)){var A=Sn(C),M=1;!T||A&2||(M|=16),(A&M)!==M&&Ar(C,A|M)}}Ls.prototype.ja=Ki,Ls.prototype.toString=function(){return this.o.toString()};function ju(C,T,A){if(A){var M={},j;for(j in A){var K=A[j],X=K.ra;X||(M.J=K.xa||K.oa.W,K.ia?(M.aa=Ed(K.ia),X=function(oe){return function(be,Re,Fe){return oe.J(be,Re,Fe,oe.aa)}}(M)):K.ka?(M.Z=Xu(K.da.P,K.ka),X=function(oe){return function(be,Re,Fe){return oe.J(be,Re,Fe,oe.Z)}}(M)):X=M.J,K.ra=X),X(T,C,K.da),M={J:M.J,aa:M.aa,Z:M.Z}}}Fs(T,C)}var gl=Symbol();function qu(C,T,A){return C[gl]||(C[gl]=function(M,j){return T(M,j,A)})}function Ca(C){var T=C[gl];if(!T){var A=Dr(C);T=function(M,j){return Yu(M,j,A)},C[gl]=T}return T}function Mm(C){var T=C.ia;if(T)return Ca(T);if(T=C.wa)return qu(C.da.P,T,C.ka)}function Bm(C){var T=Mm(C),A=C.da,M=C.oa.U;return T?function(j,K){return M(j,K,A,T)}:function(j,K){return M(j,K,A)}}function $a(C,T){var A=C[T];return typeof A=="function"&&A.length===0&&(A=A(),C[T]=A),Array.isArray(A)&&(Zr in A||xl in A||0<A.length&&typeof A[0]=="function")?A:void 0}function Vm(C,T,A,M,j,K){T.P=C[0];var X=1;if(C.length>X&&typeof C[X]!="number"){var oe=C[X++];A(T,oe)}for(;X<C.length;){A=C[X++];for(var be=X+1;be<C.length&&typeof C[be]!="number";)be++;switch(oe=C[X++],be-=X,be){case 0:M(T,A,oe);break;case 1:(be=$a(C,X))?(X++,j(T,A,oe,be)):M(T,A,oe,C[X++]);break;case 2:be=X++,be=$a(C,be),j(T,A,oe,be,C[X++]);break;case 3:K(T,A,oe,C[X++],C[X++],C[X++]);break;case 4:K(T,A,oe,C[X++],C[X++],C[X++],C[X++]);break;default:throw Error("unexpected number of binary field arguments: "+be)}}return T}var yl=Symbol();function Ed(C){var T=C[yl];if(!T){var A=Zi(C);T=function(M,j){return uo(M,j,A)},C[yl]=T}return T}function Xu(C,T){var A=C[yl];return A||(A=function(M,j){return ju(M,j,T)},C[yl]=A),A}var xl=Symbol();function w0(C,T){C.push(T)}function Ku(C,T,A){C.push(T,A.W)}function Rd(C,T,A,M){var j=Ed(M),K=Zi(M).P,X=A.W;C.push(T,function(oe,be,Re){return X(oe,be,Re,K,j)})}function Ad(C,T,A,M,j,K){var X=Xu(M,K),oe=A.W;C.push(T,function(be,Re,Fe){return oe(be,Re,Fe,M,X)})}function Zi(C){var T=C[xl];return T||(T=Vm(C,C[xl]=[],w0,Ku,Rd,Ad),Zr in C&&xl in C&&(C.length=0),T)}var Zr=Symbol();function Um(C,T){C[0]=T}function Dd(C,T,A,M){var j=A.U;C[T]=M?function(K,X,oe){return j(K,X,oe,M)}:j}function Wm(C,T,A,M,j){var K=A.U,X=Ca(M),oe=Dr(M).P;C[T]=function(be,Re,Fe){return K(be,Re,Fe,oe,X,j)}}function bl(C,T,A,M,j,K,X){var oe=A.U,be=qu(M,j,K);C[T]=function(Re,Fe,ot){return oe(Re,Fe,ot,M,be,X)}}function Dr(C){var T=C[Zr];return T||(T=Vm(C,C[Zr]={},Um,Dd,Wm,bl),Zr in C&&xl in C&&(C.length=0),T)}function Yu(C,T,A){for(;Mu(T)&&T.i!=4;){var M=T.l,j=A[M];if(!j){var K=A[0];K&&(K=K[M])&&(j=A[M]=Bm(K))}if(!j||!j(T,C,M)){j=T,M=C,K=j.j,hl(j);var X=j;if(!X.ca){if(j=X.h.h-K,X.h.h=K,X=X.h,j==0)j=Hi();else{if(K=Pu(X,j),X.S&&X.m)j=X.i.subarray(K,K+j);else{X=X.i;var oe=K;j=K+j,j=oe===j?at():Tt?X.slice(oe,j):new Uint8Array(X.subarray(oe,j))}j=j.length==0?Hi():new Qs(j,nt)}(K=M.R)?K.push(j):M.R=[j]}}}return C}function uo(C,T,A){for(var M=A.length,j=M%2==1,K=j?1:0;K<M;K+=2)(0,A[K+1])(T,C,A[K]);ju(C,T,j?A[0]:void 0)}function fr(C,T){return{U:C,W:T}}var Js=fr(function(C,T,A){if(C.i!==5)return!1;C=C.h;var M=C.i,j=C.h,K=M[j],X=M[j+1],oe=M[j+2];return M=M[j+3],ji(C,C.h+4),X=(K<<0|X<<8|oe<<16|M<<24)>>>0,C=2*(X>>31)+1,K=X>>>23&255,X&=8388607,Qr(T,A,K==255?X?NaN:1/0*C:K==0?C*Math.pow(2,-149)*X:C*Math.pow(2,K-150)*(X+Math.pow(2,23))),!0},function(C,T,A){if(T=Nd(T,A),T!=null){qi(C.h,8*A+5),C=C.h;var M=+T;M===0?0<1/M?st=gt=0:(gt=0,st=2147483648):isNaN(M)?(gt=0,st=2147483647):(M=(A=0>M?-2147483648:0)?-M:M,34028234663852886e22<M?(gt=0,st=(A|2139095040)>>>0):11754943508222875e-54>M?(M=Math.round(M/Math.pow(2,-149)),gt=0,st=(A|M)>>>0):(T=Math.floor(Math.log(M)/Math.LN2),M*=Math.pow(2,-T),M=Math.round(8388608*M),16777216<=M&&++T,gt=0,st=(A|T+127<<23|M&8388607)>>>0)),A=st,C.h.push(A>>>0&255),C.h.push(A>>>8&255),C.h.push(A>>>16&255),C.h.push(A>>>24&255)}}),Qu=fr(function(C,T,A){if(C.i!==0)return!1;var M=C.h,j=0,K=C=0,X=M.i,oe=M.h;do{var be=X[oe++];j|=(be&127)<<K,K+=7}while(32>K&&be&128);for(32<K&&(C|=(be&127)>>4),K=3;32>K&&be&128;K+=7)be=X[oe++],C|=(be&127)<<K;if(ji(M,oe),128>be)M=j>>>0,be=C>>>0,(C=be&2147483648)&&(M=~M+1>>>0,be=~be>>>0,M==0&&(be=be+1>>>0)),M=4294967296*be+(M>>>0);else throw rs();return Qr(T,A,C?-M:M),!0},function(C,T,A){T=ps(T,A),T!=null&&(typeof T=="string"&&Ys(T),T!=null&&(qi(C.h,8*A),typeof T=="number"?(C=C.h,Bt(T),$d(C,st,gt)):(A=Ys(T),$d(C.h,A.i,A.h))))}),Gm=fr(function(C,T,A){return C.i!==0?!1:(Qr(T,A,ro(C.h)),!0)},function(C,T,A){if(T=ps(T,A),T!=null&&T!=null)if(qi(C.h,8*A),C=C.h,A=T,0<=A)qi(C,A);else{for(T=0;9>T;T++)C.h.push(A&127|128),A>>=7;C.h.push(1)}}),vl=fr(function(C,T,A){if(C.i!==2)return!1;var M=ro(C.h)>>>0;C=C.h;var j=Pu(C,M);if(C=C.i,as){var K=C,X;(X=hn)||(X=hn=new TextDecoder("utf-8",{fatal:!0})),C=j+M,K=j===0&&C===K.length?K:K.subarray(j,C);try{var oe=X.decode(K)}catch(ot){if(is===void 0){try{X.decode(new Uint8Array([128]))}catch{}try{X.decode(new Uint8Array([97])),is=!0}catch{is=!1}}throw!is&&(hn=void 0),ot}}else{oe=j,M=oe+M,j=[];for(var be=null,Re,Fe;oe<M;)Re=C[oe++],128>Re?j.push(Re):224>Re?oe>=M?Ln():(Fe=C[oe++],194>Re||(Fe&192)!==128?(oe--,Ln()):j.push((Re&31)<<6|Fe&63)):240>Re?oe>=M-1?Ln():(Fe=C[oe++],(Fe&192)!==128||Re===224&&160>Fe||Re===237&&160<=Fe||((K=C[oe++])&192)!==128?(oe--,Ln()):j.push((Re&15)<<12|(Fe&63)<<6|K&63)):244>=Re?oe>=M-2?Ln():(Fe=C[oe++],(Fe&192)!==128||(Re<<28)+(Fe-144)>>30!==0||((K=C[oe++])&192)!==128||((X=C[oe++])&192)!==128?(oe--,Ln()):(Re=(Re&7)<<18|(Fe&63)<<12|(K&63)<<6|X&63,Re-=65536,j.push((Re>>10&1023)+55296,(Re&1023)+56320))):Ln(),8192<=j.length&&(be=hr(be,j),j.length=0);oe=hr(be,j)}return Qr(T,A,oe),!0},function(C,T,A){if(T=ps(T,A),T!=null){var M=!1;if(M=M===void 0?!1:M,ul){if(M&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(T))throw Error("Found an unpaired surrogate");T=(Tn||(Tn=new TextEncoder)).encode(T)}else{for(var j=0,K=new Uint8Array(3*T.length),X=0;X<T.length;X++){var oe=T.charCodeAt(X);if(128>oe)K[j++]=oe;else{if(2048>oe)K[j++]=oe>>6|192;else{if(55296<=oe&&57343>=oe){if(56319>=oe&&X<T.length){var be=T.charCodeAt(++X);if(56320<=be&&57343>=be){oe=1024*(oe-55296)+be-56320+65536,K[j++]=oe>>18|240,K[j++]=oe>>12&63|128,K[j++]=oe>>6&63|128,K[j++]=oe&63|128;continue}else X--}if(M)throw Error("Found an unpaired surrogate");oe=65533}K[j++]=oe>>12|224,K[j++]=oe>>6&63|128}K[j++]=oe&63|128}}T=j===K.length?K:K.subarray(0,j)}qi(C.h,8*A+2),qi(C.h,T.length),wn(C,C.h.end()),wn(C,T)}}),wl=fr(function(C,T,A,M,j){if(C.i!==2)return!1;T=Gu(T,A,M),A=C.h.j,M=ro(C.h)>>>0;var K=C.h.h+M,X=K-A;if(0>=X&&(C.h.j=K,j(T,C,void 0,void 0,void 0),X=K-C.h.h),X)throw Error("Message parsing ended unexpectedly. Expected to read "+(M+" bytes, instead read "+(M-X)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return C.h.h=K,C.h.j=A,!0},function(C,T,A,M,j){if(T=oo(T,M,A),T!=null)for(M=0;M<T.length;M++){var K=C;qi(K.h,8*A+2);var X=K.h.end();wn(K,X),X.push(K.i),K=X,j(T[M],C),X=C;var oe=K.pop();for(oe=X.i+X.h.length()-oe;127<oe;)K.push(oe&127|128),oe>>>=7,X.i++;K.push(oe),X.i++}});function Zu(C){return function(T,A){e:{if(Bu.length){var M=Bu.pop();M.setOptions(A),Sd(M.h,T,A),T=M}else T=new cl(T,A);try{var j=Dr(C),K=Yu(new j.P,T,j);break e}finally{j=T.h,j.i=null,j.m=!1,j.l=0,j.j=0,j.h=0,j.S=!1,T.l=-1,T.i=-1,100>Bu.length&&Bu.push(T)}K=void 0}return K}}function ms(C){return function(){var T=new Xi;uo(this,T,Zi(C)),wn(T,T.h.end());for(var A=new Uint8Array(T.i),M=T.j,j=M.length,K=0,X=0;X<j;X++){var oe=M[X];A.set(oe,K),K+=oe.length}return T.j=[A],A}}function pr(C){Ls.call(this,C)}v(pr,Ls);var Sl=[pr,1,Gm,2,Js,3,vl,4,vl];pr.prototype.l=ms(Sl);function ka(C){Ls.call(this,C,-1,S0)}v(ka,Ls),ka.prototype.addClassification=function(C,T){return Gu(this,1,pr,C,T),this};var S0=[1],_d=Zu([ka,1,wl,Sl]);function Na(C){Ls.call(this,C)}v(Na,Ls);var co=[Na,1,Js,2,Js,3,Js,4,Js,5,Js];Na.prototype.l=ms(co);function Cl(C){Ls.call(this,C,-1,Hm)}v(Cl,Ls);var Hm=[1],C0=Zu([Cl,1,wl,co]);function Ju(C){Ls.call(this,C)}v(Ju,Ls);var jm=[Ju,1,Js,2,Js,3,Js,4,Js,5,Js,6,Qu],Od=Zu(jm);Ju.prototype.l=ms(jm);function qm(C,T,A){if(A=C.createShader(A===0?C.VERTEX_SHADER:C.FRAGMENT_SHADER),C.shaderSource(A,T),C.compileShader(A),!C.getShaderParameter(A,C.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+C.getShaderInfoLog(A));return A}function $0(C){return oo(C,pr,1).map(function(T){var A=ps(T,1);return{index:A??0,qa:ks(T,2),label:ps(T,3)!=null?fl(ps(T,3),""):void 0,displayName:ps(T,4)!=null?fl(ps(T,4),""):void 0}})}function k0(C){return{x:ks(C,1),y:ks(C,2),z:ks(C,3),visibility:Nd(C,4)!=null?ks(C,4):void 0}}function Fd(C){return oo(C0(C),Na,1).map(k0)}function zd(C,T){this.i=C,this.h=T,this.m=0}function Ld(C,T,A){return N0(C,T),typeof C.h.canvas.transferToImageBitmap=="function"?Promise.resolve(C.h.canvas.transferToImageBitmap()):A?Promise.resolve(C.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(C.h.canvas):(C.j===void 0&&(C.j=document.createElement("canvas")),new Promise(function(M){C.j.height=C.h.canvas.height,C.j.width=C.h.canvas.width,C.j.getContext("2d",{}).drawImage(C.h.canvas,0,0,C.h.canvas.width,C.h.canvas.height),M(C.j)}))}function N0(C,T){var A=C.h;if(C.s===void 0){var M=qm(A,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),j=qm(A,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),K=A.createProgram();if(A.attachShader(K,M),A.attachShader(K,j),A.linkProgram(K),!A.getProgramParameter(K,A.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+A.getProgramInfoLog(K));M=C.s=K,A.useProgram(M),j=A.getUniformLocation(M,"sampler0"),C.l={O:A.getAttribLocation(M,"aVertex"),N:A.getAttribLocation(M,"aTex"),ya:j},C.v=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,C.v),A.enableVertexAttribArray(C.l.O),A.vertexAttribPointer(C.l.O,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),C.u=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,C.u),A.enableVertexAttribArray(C.l.N),A.vertexAttribPointer(C.l.N,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),A.uniform1i(j,0)}M=C.l,A.useProgram(C.s),A.canvas.width=T.width,A.canvas.height=T.height,A.viewport(0,0,T.width,T.height),A.activeTexture(A.TEXTURE0),C.i.bindTexture2d(T.glName),A.enableVertexAttribArray(M.O),A.bindBuffer(A.ARRAY_BUFFER,C.v),A.vertexAttribPointer(M.O,2,A.FLOAT,!1,0,0),A.enableVertexAttribArray(M.N),A.bindBuffer(A.ARRAY_BUFFER,C.u),A.vertexAttribPointer(M.N,2,A.FLOAT,!1,0,0),A.bindFramebuffer(A.DRAW_FRAMEBUFFER?A.DRAW_FRAMEBUFFER:A.FRAMEBUFFER,null),A.clearColor(0,0,0,0),A.clear(A.COLOR_BUFFER_BIT),A.colorMask(!0,!0,!0,!0),A.drawArrays(A.TRIANGLE_FAN,0,4),A.disableVertexAttribArray(M.O),A.disableVertexAttribArray(M.N),A.bindBuffer(A.ARRAY_BUFFER,null),C.i.bindTexture2d(0)}function I0(C){this.h=C}var T0=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function E0(C,T){return T+C}function ec(C,T){window[C]=T}function R0(C){var T=document.createElement("script");return T.setAttribute("src",C),T.setAttribute("crossorigin","anonymous"),new Promise(function(A){T.addEventListener("load",function(){A()},!1),T.addEventListener("error",function(){A()},!1),document.body.appendChild(T)})}function A0(){return _(function(C){switch(C.h){case 1:return C.s=2,N(C,WebAssembly.instantiate(T0),4);case 4:C.h=3,C.s=0;break;case 2:return C.s=0,C.l=null,C.return(!1);case 3:return C.return(!0)}})}function Pd(C){if(this.h=C,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=C&&C.locateFile||E0,typeof window=="object")var T=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")T=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=T,C.options){T=o(Object.keys(C.options));for(var A=T.next();!A.done;A=T.next()){A=A.value;var M=C.options[A].default;M!==void 0&&(this.l[A]=typeof M=="function"?M():M)}}}n=Pd.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function Xm(C){var T,A,M,j,K,X,oe,be,Re,Fe,ot;return _(function(Ze){switch(Ze.h){case 1:return C.ga?(T=C.h.files===void 0?[]:typeof C.h.files=="function"?C.h.files(C.l):C.h.files,N(Ze,A0(),2)):Ze.return();case 2:if(A=Ze.i,typeof window=="object")return ec("createMediapipeSolutionsWasm",{locateFile:C.locateFile}),ec("createMediapipeSolutionsPackedAssets",{locateFile:C.locateFile}),X=T.filter(function(Ve){return Ve.data!==void 0}),oe=T.filter(function(Ve){return Ve.data===void 0}),be=Promise.all(X.map(function(Ve){var rt=tc(C,Ve.url);if(Ve.path!==void 0){var mt=Ve.path;rt=rt.then(function(Ut){return C.overrideFile(mt,Ut),Promise.resolve(Ut)})}return rt})),Re=Promise.all(oe.map(function(Ve){return Ve.simd===void 0||Ve.simd&&A||!Ve.simd&&!A?R0(C.locateFile(Ve.url,C.ha)):Promise.resolve()})).then(function(){var Ve,rt,mt;return _(function(Ut){if(Ut.h==1)return Ve=window.createMediapipeSolutionsWasm,rt=window.createMediapipeSolutionsPackedAssets,mt=C,N(Ut,Ve(rt),2);mt.i=Ut.i,Ut.h=0})}),Fe=function(){return _(function(Ve){return C.h.graph&&C.h.graph.url?Ve=N(Ve,tc(C,C.h.graph.url),0):(Ve.h=0,Ve=void 0),Ve})}(),N(Ze,Promise.all([Re,be,Fe]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return M=T.filter(function(Ve){return Ve.simd===void 0||Ve.simd&&A||!Ve.simd&&!A}).map(function(Ve){return C.locateFile(Ve.url,C.ha)}),importScripts.apply(null,l(M)),j=C,N(Ze,createMediapipeSolutionsWasm(Module),6);case 6:j.i=Ze.i,C.m=new OffscreenCanvas(1,1),C.i.canvas=C.m,K=C.i.GL.createContext(C.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),C.i.GL.makeContextCurrent(K),Ze.h=4;break;case 7:if(C.m=document.createElement("canvas"),ot=C.m.getContext("webgl2",{}),!ot&&(ot=C.m.getContext("webgl",{}),!ot))return alert("Failed to create WebGL canvas context when passing video frame."),Ze.return();C.K=ot,C.i.canvas=C.m,C.i.createContext(C.m,!0,!0,{});case 4:C.j=new C.i.SolutionWasm,C.ga=!1,Ze.h=0}})}function D0(C){var T,A,M,j,K,X,oe,be;return _(function(Re){if(Re.h==1){if(C.h.graph&&C.h.graph.url&&C.fa===C.h.graph.url)return Re.return();if(C.u=!0,!C.h.graph||!C.h.graph.url){Re.h=2;return}return C.fa=C.h.graph.url,N(Re,tc(C,C.h.graph.url),3)}for(Re.h!=2&&(T=Re.i,C.j.loadGraph(T)),A=o(Object.keys(C.D)),M=A.next();!M.done;M=A.next())j=M.value,C.j.overrideFile(j,C.D[j]);if(C.D={},C.h.listeners)for(K=o(C.h.listeners),X=K.next();!X.done;X=K.next())oe=X.value,z0(C,oe);be=C.l,C.l={},C.setOptions(be),Re.h=0})}n.reset=function(){var C=this;return _(function(T){C.j&&(C.j.reset(),C.s={},C.v={}),T.h=0})},n.setOptions=function(C,T){var A=this;if(T=T||this.h.options){for(var M=[],j=[],K={},X=o(Object.keys(C)),oe=X.next();!oe.done;K={X:K.X,Y:K.Y},oe=X.next())if(oe=oe.value,!(oe in this.l&&this.l[oe]===C[oe])){this.l[oe]=C[oe];var be=T[oe];be!==void 0&&(be.onChange&&(K.X=be.onChange,K.Y=C[oe],M.push(function(Re){return function(){var Fe;return _(function(ot){if(ot.h==1)return N(ot,Re.X(Re.Y),2);Fe=ot.i,Fe===!0&&(A.u=!0),ot.h=0})}}(K))),be.graphOptionXref&&(oe=Object.assign({},{calculatorName:"",calculatorIndex:0},be.graphOptionXref,{valueNumber:be.type===1?C[oe]:0,valueBoolean:be.type===0?C[oe]:!1,valueString:be.type===2?C[oe]:""}),j.push(oe)))}(M.length!==0||j.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(j),this.F=(this.F===void 0?[]:this.F).concat(M))}};function _0(C){var T,A,M,j,K,X,oe;return _(function(be){switch(be.h){case 1:if(!C.u)return be.return();if(!C.F){be.h=2;break}T=o(C.F),A=T.next();case 3:if(A.done){be.h=5;break}return M=A.value,N(be,M(),4);case 4:A=T.next(),be.h=3;break;case 5:C.F=void 0;case 2:if(C.H){for(j=new C.i.GraphOptionChangeRequestList,K=o(C.H),X=K.next();!X.done;X=K.next())oe=X.value,j.push_back(oe);C.j.changeOptions(j),j.delete(),C.H=void 0}C.u=!1,be.h=0}})}n.initialize=function(){var C=this;return _(function(T){return T.h==1?N(T,Xm(C),2):T.h!=3?N(T,D0(C),3):N(T,_0(C),0)})};function tc(C,T){var A,M;return _(function(j){return T in C.L?j.return(C.L[T]):(A=C.locateFile(T,""),M=fetch(A).then(function(K){return K.arrayBuffer()}),C.L[T]=M,j.return(M))})}n.overrideFile=function(C,T){this.j?this.j.overrideFile(C,T):this.D[C]=T},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(C,T){var A=this,M,j,K,X,oe,be,Re,Fe,ot;return _(function(Ze){switch(Ze.h){case 1:return A.h.inputs?(M=1e3*(T??performance.now()),N(Ze,A.I,2)):Ze.return();case 2:return N(Ze,A.initialize(),3);case 3:for(j=new A.i.PacketDataList,K=o(Object.keys(C)),X=K.next();!X.done;X=K.next())if(oe=X.value,be=A.h.inputs[oe]){e:{var Ve=C[oe];switch(be.type){case"video":var rt=A.s[be.stream];if(rt||(rt=new zd(A.i,A.K),A.s[be.stream]=rt),rt.m===0&&(rt.m=rt.i.createTexture()),typeof HTMLVideoElement<"u"&&Ve instanceof HTMLVideoElement)var mt=Ve.videoWidth,Ut=Ve.videoHeight;else typeof HTMLImageElement<"u"&&Ve instanceof HTMLImageElement?(mt=Ve.naturalWidth,Ut=Ve.naturalHeight):(mt=Ve.width,Ut=Ve.height);Ut={glName:rt.m,width:mt,height:Ut},mt=rt.h,mt.canvas.width=Ut.width,mt.canvas.height=Ut.height,mt.activeTexture(mt.TEXTURE0),rt.i.bindTexture2d(rt.m),mt.texImage2D(mt.TEXTURE_2D,0,mt.RGBA,mt.RGBA,mt.UNSIGNED_BYTE,Ve),rt.i.bindTexture2d(0),rt=Ut;break e;case"detections":for(rt=A.s[be.stream],rt||(rt=new I0(A.i),A.s[be.stream]=rt),rt.data||(rt.data=new rt.h.DetectionListData),rt.data.reset(Ve.length),Ut=0;Ut<Ve.length;++Ut){mt=Ve[Ut];var Jt=rt.data,En=Jt.setBoundingBox,er=Ut,Ns=mt.la,Et=new Ju;if(Hn(Et,1,Ns.sa),Hn(Et,2,Ns.ta),Hn(Et,3,Ns.height),Hn(Et,4,Ns.width),Hn(Et,5,Ns.rotation),Qr(Et,6,Ns.pa),Ns=Et.l(),En.call(Jt,er,Ns),mt.ea)for(Jt=0;Jt<mt.ea.length;++Jt){Et=mt.ea[Jt],En=rt.data,er=En.addNormalizedLandmark,Ns=Ut,Et=Object.assign({},Et,{visibility:Et.visibility?Et.visibility:0});var Mn=new Na;Hn(Mn,1,Et.x),Hn(Mn,2,Et.y),Hn(Mn,3,Et.z),Et.visibility&&Hn(Mn,4,Et.visibility),Et=Mn.l(),er.call(En,Ns,Et)}if(mt.ba)for(Jt=0;Jt<mt.ba.length;++Jt)En=rt.data,er=En.addClassification,Ns=Ut,Et=mt.ba[Jt],Mn=new pr,Hn(Mn,2,Et.qa),Et.index&&Qr(Mn,1,Et.index),Et.label&&Qr(Mn,3,Et.label),Et.displayName&&Qr(Mn,4,Et.displayName),Et=Mn.l(),er.call(En,Ns,Et)}rt=rt.data;break e;default:rt={}}}switch(Re=rt,Fe=be.stream,be.type){case"video":j.pushTexture2d(Object.assign({},Re,{stream:Fe,timestamp:M}));break;case"detections":ot=Re,ot.stream=Fe,ot.timestamp=M,j.pushDetectionList(ot);break;default:throw Error("Unknown input config type: '"+be.type+"'")}}return A.j.send(j),N(Ze,A.I,4);case 4:j.delete(),Ze.h=0}})};function O0(C,T,A){var M,j,K,X,oe,be,Re,Fe,ot,Ze,Ve,rt,mt,Ut;return _(function(Jt){switch(Jt.h){case 1:if(!A)return Jt.return(T);for(M={},j=0,K=o(Object.keys(A)),X=K.next();!X.done;X=K.next())oe=X.value,be=A[oe],typeof be!="string"&&be.type==="texture"&&T[be.stream]!==void 0&&++j;1<j&&(C.M=!1),Re=o(Object.keys(A)),X=Re.next();case 2:if(X.done){Jt.h=4;break}if(Fe=X.value,ot=A[Fe],typeof ot=="string")return mt=M,Ut=Fe,N(Jt,F0(C,Fe,T[ot]),14);if(Ze=T[ot.stream],ot.type==="detection_list"){if(Ze){for(var En=Ze.getRectList(),er=Ze.getLandmarksList(),Ns=Ze.getClassificationsList(),Et=[],Mn=0;Mn<En.size();++Mn){var $i=Od(En.get(Mn)),Qm=ks($i,1),Zm=ks($i,2),L0=ks($i,3),P0=ks($i,4),M0=ks($i,5,0),nc=void 0;nc=nc===void 0?0:nc,$i={la:{sa:Qm,ta:Zm,height:L0,width:P0,rotation:M0,pa:fl(ps($i,6),nc)},ea:Fd(er.get(Mn)),ba:$0(_d(Ns.get(Mn)))},Et.push($i)}En=Et}else En=[];M[Fe]=En,Jt.h=7;break}if(ot.type==="proto_list"){if(Ze){for(En=Array(Ze.size()),er=0;er<Ze.size();er++)En[er]=Ze.get(er);Ze.delete()}else En=[];M[Fe]=En,Jt.h=7;break}if(Ze===void 0){Jt.h=3;break}if(ot.type==="float_list"){M[Fe]=Ze,Jt.h=7;break}if(ot.type==="proto"){M[Fe]=Ze,Jt.h=7;break}if(ot.type!=="texture")throw Error("Unknown output config type: '"+ot.type+"'");return Ve=C.v[Fe],Ve||(Ve=new zd(C.i,C.K),C.v[Fe]=Ve),N(Jt,Ld(Ve,Ze,C.M),13);case 13:rt=Jt.i,M[Fe]=rt;case 7:ot.transform&&M[Fe]&&(M[Fe]=ot.transform(M[Fe])),Jt.h=3;break;case 14:mt[Ut]=Jt.i;case 3:X=Re.next(),Jt.h=2;break;case 4:return Jt.return(M)}})}function F0(C,T,A){var M;return _(function(j){return typeof A=="number"||A instanceof Uint8Array||A instanceof C.i.Uint8BlobList?j.return(A):A instanceof C.i.Texture2dDataOut?(M=C.v[T],M||(M=new zd(C.i,C.K),C.v[T]=M),j.return(Ld(M,A,C.M))):j.return(void 0)})}function z0(C,T){for(var A=T.name||"$",M=[].concat(l(T.wants)),j=new C.i.StringList,K=o(T.wants),X=K.next();!X.done;X=K.next())j.push_back(X.value);K=C.i.PacketListener.implement({onResults:function(oe){for(var be={},Re=0;Re<T.wants.length;++Re)be[M[Re]]=oe.get(Re);var Fe=C.listeners[A];Fe&&(C.I=O0(C,be,T.outs).then(function(ot){ot=Fe(ot);for(var Ze=0;Ze<T.wants.length;++Ze){var Ve=be[M[Ze]];typeof Ve=="object"&&Ve.hasOwnProperty&&Ve.hasOwnProperty("delete")&&Ve.delete()}ot&&(C.I=ot)}))}}),C.j.attachMultiListener(j,K),j.delete()}n.onResults=function(C,T){this.listeners[T||"$"]=C},Y("Solution",Pd),Y("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Km(C){switch(C===void 0&&(C=0),C){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Ym(C){var T=this;C=C||{},this.h=new Pd({locateFile:C.locateFile,files:function(A){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Km(A.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Fd},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Fd},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(A){var M,j,K;return _(function(X){return X.h==1?(M=Km(A),j="third_party/mediapipe/modules/pose_landmark/"+M,N(X,tc(T.h,M),2)):(K=X.i,T.h.overrideFile(j,K),X.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Ym.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(C){this.h.onResults(C)},n.initialize=function(){var C=this;return _(function(T){return N(T,C.h.initialize(),0)})},n.send=function(C,T){var A=this;return _(function(M){return N(M,A.h.send(C,T),0)})},n.setOptions=function(C){this.h.setOptions(C)},Y("Pose",Ym),Y("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),Y("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),Y("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),Y("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),Y("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),Y("VERSION","0.5.1675469404")}).call(Ov)),Ov}var YL=KL();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QL=1e-7,ZL=1e-4;class f2{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class lx{refCount(e){return xr("refCount")}incRef(e){return xr("incRef")}timerAvailable(){return!0}time(e){return xr("time")}read(e){return xr("read")}readSync(e){return xr("readSync")}readToGPU(e,t){return xr("readToGPU")}numDataIds(){return xr("numDataIds")}disposeData(e,t){return xr("disposeData")}write(e,t,s){return xr("write")}move(e,t,s,r,i){return xr("move")}createTensorFromGPUData(e,t,s){return xr("createTensorFromGPUData")}memory(){return xr("memory")}floatPrecision(){return xr("floatPrecision")}epsilon(){return this.floatPrecision()===32?QL:ZL}dispose(){return xr("dispose")}}function xr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JL(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Lc(n,e,t)}function ru(n,e,t){return Math.max(n,Math.min(e,t))}function p2(n){return n%2===0?n:n+1}function Lc(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function vE(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function B(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function cr(n,e,t=""){B(yt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function oh(n){B(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ue(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function ON(n){return n.length===0}function eP(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function yt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Xc(n){return n%1===0}function dw(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function Uc(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function FN(n,e=r=>0,t,s){return new Promise((r,i)=>{let a=0;const o=()=>{if(n()){r();return}a++;const l=e(a);if(t!=null&&a>=t){i();return}s!=null?s(o,l):setTimeout(o,l)};o()})}function m2(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function pt(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),B(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),B(n.every(s=>Xc(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Zo(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:pt(e,n).sort();let a=0;for(let o=0;o<n.length;++o){if(i!=null){if(i[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(i[a]==null||i[a]>o)&&n[o]===1&&(t.push(n[o]),s.push(o)),i[a]<=o&&a++}n[o]!==1&&(t.push(n[o]),s.push(o))}return{newShape:t,keptDims:s}}function es(n,e){return kn(n,e)}function kn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function tP(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function nP(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function g2(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Iy(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function sP(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function lh(n){return typeof n=="string"||n instanceof String}function rP(n){return typeof n=="boolean"}function fw(n){return typeof n=="number"}function bu(n){return Array.isArray(n)?bu(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":fw(n)?"float32":lh(n)?"string":rP(n)?"bool":"float32"}function pw(n){return!!(n&&n.constructor&&n.call&&n.apply)}function mw(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Ye(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function wE(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let a=0;a<i;a++)r[a]=t[n+a]}else{const i=e[0],a=e.slice(1),o=a.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<i;l++)r[l]=wE(n+l*o,a,t,s)}return r}function pi(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return wE(0,n,e,t)}function py(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function y2(n,e){const t=ws(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function ws(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function SE(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return pi(n,new Float32Array(t));if(e==="int32")return pi(n,new Int32Array(t));if(e==="bool")return pi(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Hr(n){n.forEach(e=>{B(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ua(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function uh(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function iu(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zN="tfjsflags";class iP{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=aP,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(fe().getBool("IS_TEST")||fe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];fe().getBool("IS_TEST")||fe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(iu(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);zN in e&&e[zN].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=lP(r,i)})}}function aP(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(oP(e,s[0],s[1]),s.join("="))),e}function oP(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function lP(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function fe(){return CE}let CE=null;function uP(n){CE=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fv;function $E(){if(Fv==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Fv=n}return Fv}function cP(){const n=$E();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function x2(n,e){const t=cP();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const up="Abs",ch="Acos",hh="Acosh",vu="Add",cp="AddN",ux="All",cx="Any",hp="ArgMax",dp="ArgMin",dh="Asin",fh="Asinh",ph="Atan",mh="Atanh",gh="Atan2",fp="AvgPool",hx="AvgPoolGrad",pp="AvgPool3D",dx="AvgPool3DGrad",mp="BatchMatMul",gp="BatchToSpaceND",fx="Bincount",px="BitwiseAnd",hP="BroadcastTo",mx="BroadcastArgs",yh="Cast",xh="Ceil",bh="ClipByValue",gx="Complex",yp="ComplexAbs",xp="Concat",bp="Conv2D",yx="Conv2DBackpropFilter",vp="Conv2DBackpropInput",wp="Conv3D",xx="Conv3DBackpropFilterV2",bx="Conv3DBackpropInputV2",vh="Cos",wh="Cosh",vx="Cumprod",Sp="Cumsum",wx="CropAndResize",Sx="DenseBincount",Cx="DepthToSpace",Cp="DepthwiseConv2dNative",$x="DepthwiseConv2dNativeBackpropFilter",kx="DepthwiseConv2dNativeBackpropInput",Nx="Diag",$p="Dilation2D",Ty="Dilation2DBackpropInput",Ey="Dilation2DBackpropFilter",b2="Draw",Sh="RealDiv",Ix="Einsum",Ch="Elu",Tx="EluGrad",$h="Erf",kp="Equal",kh="Exp",Np="ExpandDims",Nh="Expm1",Ex="FFT",Rx="Fill",Ax="FlipLeftRight",Ih="Floor",Th="FloorDiv",Ip="FusedBatchNorm",Tp="GatherV2",Dx="GatherNd",Ep="Greater",Eh="GreaterEqual",Rh="Identity",_x="IFFT",Ox="Imag",Ah="IsFinite",Dh="IsInf",_h="IsNan",Rp="LeakyRelu",Ap="Less",Dp="LessEqual",Fx="LinSpace",Oh="Log",Fh="Log1p",_p="LogicalAnd",Op="LogicalNot",Fp="LogicalOr",dP="LogSoftmax",zp="LRN",zx="LRNGrad",Lp="Max",zh="Maximum",Pp="MaxPool",Lx="MaxPoolGrad",Mp="MaxPool3D",Px="MaxPool3DGrad",Mx="MaxPoolWithArgmax",Bp="Mean",Vp="Min",Lh="Minimum",Up="MirrorPad",Ph="Mod",Bx="Multinomial",Mh="Multiply",Wp="Neg",Gp="NotEqual",Vx="NonMaxSuppressionV3",v2="NonMaxSuppressionV4",Ux="NonMaxSuppressionV5",Hp="OnesLike",jp="OneHot",qp="Pack",Xp="PadV2",Bh="Pow",Kp="Prelu",Yp="Prod",w2="RaggedGather",S2="RaggedRange",C2="RaggedTensorToTensor",Wx="Range",Gx="Real",Vh="Reciprocal",Uh="Relu",Qp="Reshape",Zp="ResizeNearestNeighbor",Hx="ResizeNearestNeighborGrad",Jp="ResizeBilinear",jx="ResizeBilinearGrad",Wh="Relu6",em="Reverse",Gh="Round",Hh="Rsqrt",qx="ScatterNd",Xx="TensorScatterUpdate",Kx="SearchSorted",tm="Select",jh="Selu",nm="Slice",qh="Sin",Xh="Sinh",Kh="Sign",Yh="Sigmoid",Qh="Softplus",Zh="Sqrt",sm="Sum",rm="SpaceToBatchND",im="SplitV",am="Softmax",$2="SparseFillEmptyRows",k2="SparseReshape",Yx="SparseSegmentMean",Qx="SparseSegmentSum",Zx="SparseToDense",Jh="SquaredDifference",Jx="Square",eb="StaticRegexReplace",tb="StridedSlice",nb="StringNGrams",N2="StringSplit",I2="StringToHashBucketFast",ed="Sub",td="Tan",nd="Tanh",sd="Tile",sb="TopK",rb="Transform",Jl="Transpose",T2="Unique",om="Unpack",lm="UnsortedSegmentSum",um="ZerosLike",rd="Step",Ry="FromPixels",ib="RotateWithOffset",Vf="_FusedMatMul",Uf="FusedConv2D",Wf="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Br(...n){fe().getBool("IS_TEST")||fe().getBool("PROD")||console.warn(...n)}function fP(...n){fe().getBool("IS_TEST")||fe().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ay=x2("kernelRegistry",()=>new Map),gw=x2("gradRegistry",()=>new Map);function Dy(n,e){const t=kE(n,e);return Ay.get(t)}function LN(n){return gw.get(n)}function PN(n){const e=Ay.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===n&&t.push(a)}return t}function E2(n){const{kernelName:e,backendName:t}=n,s=kE(e,t);Ay.has(s)&&Br(`The kernel '${e}' for backend '${t}' is already registered`),Ay.set(s,n)}function pP(n){const{kernelName:e}=n;gw.has(e)&&fe().getBool("DEBUG")&&Br(`Overriding the gradient for '${e}'`),gw.set(e,n)}function kE(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NE(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var zv,MN;function mP(){if(MN)return zv;MN=1,zv=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(P,_,H){this.low=P|0,this.high=_|0,this.unsigned=!!H}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(P){return(P&&P.__isLong__)===!0}e.isLong=t;var s={},r={};function i(P,_){var H,q,ee;return _?(P>>>=0,(ee=0<=P&&P<256)&&(q=r[P],q)?q:(H=o(P,(P|0)<0?-1:0,!0),ee&&(r[P]=H),H)):(P|=0,(ee=-128<=P&&P<128)&&(q=s[P],q)?q:(H=o(P,P<0?-1:0,!1),ee&&(s[P]=H),H))}e.fromInt=i;function a(P,_){if(isNaN(P))return _?$:w;if(_){if(P<0)return $;if(P>=x)return O}else{if(P<=-b)return L;if(P+1>=b)return D}return P<0?a(-P,_).neg():o(P%g|0,P/g|0,_)}e.fromNumber=a;function o(P,_,H){return new e(P,_,H)}e.fromBits=o;var l=Math.pow;function c(P,_,H){if(P.length===0)throw Error("empty string");if(P==="NaN"||P==="Infinity"||P==="+Infinity"||P==="-Infinity")return w;if(typeof _=="number"?(H=_,_=!1):_=!!_,H=H||10,H<2||36<H)throw RangeError("radix");var q;if((q=P.indexOf("-"))>0)throw Error("interior hyphen");if(q===0)return c(P.substring(1),_,H).neg();for(var ee=a(l(H,8)),Y=w,G=0;G<P.length;G+=8){var te=Math.min(8,P.length-G),re=parseInt(P.substring(G,G+te),H);if(te<8){var he=a(l(H,te));Y=Y.mul(he).add(a(re))}else Y=Y.mul(ee),Y=Y.add(a(re))}return Y.unsigned=_,Y}e.fromString=c;function d(P,_){return typeof P=="number"?a(P,_):typeof P=="string"?c(P,_):o(P.low,P.high,typeof _=="boolean"?_:P.unsigned)}e.fromValue=d;var f=65536,p=1<<24,g=f*f,x=g*g,b=x/2,v=i(p),w=i(0);e.ZERO=w;var $=i(0,!0);e.UZERO=$;var I=i(1);e.ONE=I;var N=i(1,!0);e.UONE=N;var E=i(-1);e.NEG_ONE=E;var D=o(-1,2147483647,!1);e.MAX_VALUE=D;var O=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=O;var L=o(0,-2147483648,!1);e.MIN_VALUE=L;var z=e.prototype;return z.toInt=function(){return this.unsigned?this.low>>>0:this.low},z.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},z.toString=function(_){if(_=_||10,_<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(L)){var H=a(_),q=this.div(H),ee=q.mul(H).sub(this);return q.toString(_)+ee.toInt().toString(_)}else return"-"+this.neg().toString(_);for(var Y=a(l(_,6),this.unsigned),G=this,te="";;){var re=G.div(Y),he=G.sub(re.mul(Y)).toInt()>>>0,W=he.toString(_);if(G=re,G.isZero())return W+te;for(;W.length<6;)W="0"+W;te=""+W+te}},z.getHighBits=function(){return this.high},z.getHighBitsUnsigned=function(){return this.high>>>0},z.getLowBits=function(){return this.low},z.getLowBitsUnsigned=function(){return this.low>>>0},z.getNumBitsAbs=function(){if(this.isNegative())return this.eq(L)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,H=31;H>0&&(_&1<<H)==0;H--);return this.high!=0?H+33:H+1},z.isZero=function(){return this.high===0&&this.low===0},z.eqz=z.isZero,z.isNegative=function(){return!this.unsigned&&this.high<0},z.isPositive=function(){return this.unsigned||this.high>=0},z.isOdd=function(){return(this.low&1)===1},z.isEven=function(){return(this.low&1)===0},z.equals=function(_){return t(_)||(_=d(_)),this.unsigned!==_.unsigned&&this.high>>>31===1&&_.high>>>31===1?!1:this.high===_.high&&this.low===_.low},z.eq=z.equals,z.notEquals=function(_){return!this.eq(_)},z.neq=z.notEquals,z.ne=z.notEquals,z.lessThan=function(_){return this.comp(_)<0},z.lt=z.lessThan,z.lessThanOrEqual=function(_){return this.comp(_)<=0},z.lte=z.lessThanOrEqual,z.le=z.lessThanOrEqual,z.greaterThan=function(_){return this.comp(_)>0},z.gt=z.greaterThan,z.greaterThanOrEqual=function(_){return this.comp(_)>=0},z.gte=z.greaterThanOrEqual,z.ge=z.greaterThanOrEqual,z.compare=function(_){if(t(_)||(_=d(_)),this.eq(_))return 0;var H=this.isNegative(),q=_.isNegative();return H&&!q?-1:!H&&q?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},z.comp=z.compare,z.negate=function(){return!this.unsigned&&this.eq(L)?L:this.not().add(I)},z.neg=z.negate,z.add=function(_){t(_)||(_=d(_));var H=this.high>>>16,q=this.high&65535,ee=this.low>>>16,Y=this.low&65535,G=_.high>>>16,te=_.high&65535,re=_.low>>>16,he=_.low&65535,W=0,ne=0,pe=0,de=0;return de+=Y+he,pe+=de>>>16,de&=65535,pe+=ee+re,ne+=pe>>>16,pe&=65535,ne+=q+te,W+=ne>>>16,ne&=65535,W+=H+G,W&=65535,o(pe<<16|de,W<<16|ne,this.unsigned)},z.subtract=function(_){return t(_)||(_=d(_)),this.add(_.neg())},z.sub=z.subtract,z.multiply=function(_){if(this.isZero())return w;if(t(_)||(_=d(_)),n){var H=n.mul(this.low,this.high,_.low,_.high);return o(H,n.get_high(),this.unsigned)}if(_.isZero())return w;if(this.eq(L))return _.isOdd()?L:w;if(_.eq(L))return this.isOdd()?L:w;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(v)&&_.lt(v))return a(this.toNumber()*_.toNumber(),this.unsigned);var q=this.high>>>16,ee=this.high&65535,Y=this.low>>>16,G=this.low&65535,te=_.high>>>16,re=_.high&65535,he=_.low>>>16,W=_.low&65535,ne=0,pe=0,de=0,we=0;return we+=G*W,de+=we>>>16,we&=65535,de+=Y*W,pe+=de>>>16,de&=65535,de+=G*he,pe+=de>>>16,de&=65535,pe+=ee*W,ne+=pe>>>16,pe&=65535,pe+=Y*he,ne+=pe>>>16,pe&=65535,pe+=G*re,ne+=pe>>>16,pe&=65535,ne+=q*W+ee*he+Y*re+G*te,ne&=65535,o(de<<16|we,ne<<16|pe,this.unsigned)},z.mul=z.multiply,z.divide=function(_){if(t(_)||(_=d(_)),_.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&_.low===-1&&_.high===-1)return this;var H=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,_.low,_.high);return o(H,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?$:w;var q,ee,Y;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return $;if(_.gt(this.shru(1)))return N;Y=$}else{if(this.eq(L)){if(_.eq(I)||_.eq(E))return L;if(_.eq(L))return I;var G=this.shr(1);return q=G.div(_).shl(1),q.eq(w)?_.isNegative()?I:E:(ee=this.sub(_.mul(q)),Y=q.add(ee.div(_)),Y)}else if(_.eq(L))return this.unsigned?$:w;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();Y=w}for(ee=this;ee.gte(_);){q=Math.max(1,Math.floor(ee.toNumber()/_.toNumber()));for(var te=Math.ceil(Math.log(q)/Math.LN2),re=te<=48?1:l(2,te-48),he=a(q),W=he.mul(_);W.isNegative()||W.gt(ee);)q-=re,he=a(q,this.unsigned),W=he.mul(_);he.isZero()&&(he=I),Y=Y.add(he),ee=ee.sub(W)}return Y},z.div=z.divide,z.modulo=function(_){if(t(_)||(_=d(_)),n){var H=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,_.low,_.high);return o(H,n.get_high(),this.unsigned)}return this.sub(this.div(_).mul(_))},z.mod=z.modulo,z.rem=z.modulo,z.not=function(){return o(~this.low,~this.high,this.unsigned)},z.and=function(_){return t(_)||(_=d(_)),o(this.low&_.low,this.high&_.high,this.unsigned)},z.or=function(_){return t(_)||(_=d(_)),o(this.low|_.low,this.high|_.high,this.unsigned)},z.xor=function(_){return t(_)||(_=d(_)),o(this.low^_.low,this.high^_.high,this.unsigned)},z.shiftLeft=function(_){return t(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?o(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):o(0,this.low<<_-32,this.unsigned)},z.shl=z.shiftLeft,z.shiftRight=function(_){return t(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?o(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):o(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},z.shr=z.shiftRight,z.shiftRightUnsigned=function(_){if(t(_)&&(_=_.toInt()),_&=63,_===0)return this;var H=this.high;if(_<32){var q=this.low;return o(q>>>_|H<<32-_,H>>>_,this.unsigned)}else return _===32?o(H,0,this.unsigned):o(H>>>_-32,0,this.unsigned)},z.shru=z.shiftRightUnsigned,z.shr_u=z.shiftRightUnsigned,z.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},z.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},z.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},z.toBytesLE=function(){var _=this.high,H=this.low;return[H&255,H>>>8&255,H>>>16&255,H>>>24,_&255,_>>>8&255,_>>>16&255,_>>>24]},z.toBytesBE=function(){var _=this.high,H=this.low;return[_>>>24,_>>>16&255,_>>>8&255,_&255,H>>>24,H>>>16&255,H>>>8&255,H&255]},e.fromBytes=function(_,H,q){return q?e.fromBytesLE(_,H):e.fromBytesBE(_,H)},e.fromBytesLE=function(_,H){return new e(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,H)},e.fromBytesBE=function(_,H){return new e(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],H)},zv}var IE=mP();const TE=bE(IE),gP=DL({__proto__:null,default:TE},[IE]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hl=TE||gP;function ab(n){return Hl.fromString(n,!0,16)}const EE=ab("c3a5c85c97cb3127"),Ul=ab("b492b66fbe98f273"),Ws=ab("9ae16a3b2f90404f");function yw(n){return n.xor(n.shru(47))}function RE(n,e,t){const s=n.slice(e,e+t);return Hl.fromBytes(Array.from(s),!0,!0)}function on(n,e){return RE(n,e,8)}function BN(n,e){return RE(n,e,4)}function us(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Po(n,e,t=ab("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function yP(n,e,t,s,r,i){r=r.add(n),i=us(i.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(t),i=i.add(us(r,44)),[r.add(s),i.add(a)]}function Zg(n,e,t,s){return yP(on(n,e),on(n,e+8),on(n,e+16),on(n,e+24),t,s)}function xP(n,e=n.length){if(e>=8){const t=Ws.add(e*2),s=on(n,0).add(Ws),r=on(n,e-8),i=us(r,37).mul(t).add(s),a=us(s,25).add(r).mul(t);return Po(i,a,t)}if(e>=4){const t=Ws.add(e*2),s=BN(n,0);return Po(s.shl(3).add(e),BN(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),a=e+(r<<2);return yw(Ws.mul(i).xor(EE.mul(a))).mul(Ws)}return Ws}function bP(n,e=n.length){const t=Ws.add(e*2),s=on(n,0).mul(Ul),r=on(n,8),i=on(n,e-8).mul(t),a=on(n,e-16).mul(Ws);return Po(us(s.add(r),43).add(us(i,30)).add(a),s.add(us(r.add(Ws),18)).add(i),t)}function vP(n,e=n.length){const t=Ws.add(e*2),s=on(n,0).mul(Ws),r=on(n,8),i=on(n,e-8).mul(t),a=on(n,e-16).mul(Ws),o=us(s.add(r),43).add(us(i,30)).add(a),l=Po(o,s.add(us(r.add(Ws),18)).add(i),t),c=on(n,16).mul(t),d=on(n,24),f=o.add(on(n,e-32)).mul(t),p=l.add(on(n,e-24)).mul(t);return Po(us(c.add(d),43).add(us(f,30)).add(p),c.add(us(d.add(s),18)).add(f),t)}function wP(n,e=n.length){const t=Hl.fromNumber(81,!0);if(e<=32)return e<=16?xP(n,e):bP(n,e);if(e<=64)return vP(n,e);let s=t,r=t.mul(Ul).add(113),i=yw(r.mul(Ws).add(113)).mul(Ws),a=[Hl.UZERO,Hl.UZERO],o=[Hl.UZERO,Hl.UZERO];s=s.mul(Ws).add(on(n,0));let l=0;const c=(e-1>>6)*64,d=c+(e-1&63)-63;do s=us(s.add(r).add(a[0]).add(on(n,l+8)),37).mul(Ul),r=us(r.add(a[1]).add(on(n,l+48)),42).mul(Ul),s=s.xor(o[1]),r=r.add(a[0]).add(on(n,l+40)),i=us(i.add(o[0]),33).mul(Ul),a=Zg(n,l,a[1].mul(Ul),s.add(o[0])),o=Zg(n,l+32,i.add(o[1]),r.add(on(n,l+16))),[i,s]=[s,i],l+=64;while(l!==c);const f=Ul.add(i.and(255).shl(1));return l=d,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=us(s.add(r).add(a[0]).add(on(n,l+8)),37).mul(f),r=us(r.add(a[1]).add(on(n,l+48)),42).mul(f),s=s.xor(o[1].mul(9)),r=r.add(a[0].mul(9).add(on(n,l+40))),i=us(i.add(o[0]),33).mul(f),a=Zg(n,l,a[1].mul(f),s.add(o[0])),o=Zg(n,l+32,i.add(o[1]),r.add(on(n,l+16))),[i,s]=[s,i],Po(Po(a[0],o[0],f).add(yw(r).mul(EE)).add(i),Po(a[1],o[1],f).add(s),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jo(n,e){return e==="string"?Ha(n):wu([n],e)}function SP(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function wu(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ka(n)),fe().getBool("DEBUG")&&tP(n,e),SP(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function nr(){return fe().platform.now()}function Ha(n,e="utf-8"){return e=e||"utf-8",fe().platform.encode(n,e)}function Oi(n,e="utf-8"){return e=e||"utf-8",fe().platform.decode(n,e)}function yi(n){return fe().platform.isTypedArray!=null?fe().platform.isTypedArray(n):NE(n)}function Ka(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||iu(n)||n==null||yi(n)&&t)e.push(n);else if(Array.isArray(n)||yi(n))for(let s=0;s<n.length;++s)Ka(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Ka(n[r],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CP{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new kP)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let a;const o=nr();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();a=Promise.resolve({kernelMs:nr()-o})}if(fe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const d=r[c];d.data().then(f=>{$P(f,d.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(c=>c.kernelMs),extraInfo:a.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:a}=e;s.forEach(o=>{Promise.all([o.data(),r,a]).then(l=>{this.logger.logKernelProfile(t,o,l[0],l[1],i,l[2])})})}}function $P(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class kP{logKernelProfile(e,t,s,r,i,a){const o=typeof r=="number"?Uc(`${r}ms`,9):r.error,l=Uc(e,25),c=t.rank,d=t.size,f=Uc(t.shape.toString(),14);let p="";for(const g in i){const x=i[g];if(x!=null){const b=x.shape||t.shape,v=b.length;p+=`${g}: ${v}D ${v>0?b:""} `}}console.log(`%c${l}	%c${o}	%c${c}D ${f}	%c${d}	%c${p}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NP(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],d=c.inputs;for(const f in d){const p=d[f];let g=!1;for(let x=0;x<e.length;x++)if(s[p.id]){c.outputs.forEach(b=>s[b.id]=!0),g=!0,r[c.id]=!0;break}if(g)break}}const i={};i[t.id]=!0;const a={};for(let l=n.length-1;l>=0;l--){const c=n[l],d=c.inputs;for(let f=0;f<c.outputs.length;f++)if(i[c.outputs[f].id]){for(const p in d)i[d[p].id]=!0,a[c.id]=!0;break}}const o=[];for(let l=0;l<n.length;l++){const c=n[l];if(r[c.id]&&a[c.id]){const d={};for(const p in c.inputs){const g=c.inputs[p];s[g.id]&&(d[p]=g)}const f=Object.assign({},c);f.inputs=d,f.outputs=c.outputs,o.push(f)}}return o}function IP(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],a=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?a.push(c):a.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const l in i.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const c=t(()=>o[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const d=i.inputs[l];if(!yt(c.shape,d.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=c;else{const f=n[d.id];n[d.id]=s(f,c),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VN=20,If=3,Lv=7;function TP(n,e,t,s){const r=Ye(e),i=EP(n,e,t,r),a=e.length,o=my(n,e,t,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(c=>"    "+c).join(`
`)),l.join(`
`)}function EP(n,e,t,s){const r=ue(e),i=s[s.length-1],a=new Array(i).fill(0),o=e.length,l=t==="complex64"?_f(n):n;if(o>1)for(let c=0;c<r/i;c++){const d=c*i;for(let f=0;f<i;f++)a[f]=Math.max(a[f],Df(l[d+f],0,t).length)}return a}function Df(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Lv))} + ${parseFloat(n[1].toFixed(Lv))}j`:lh(n)?s=`'${n}'`:t==="bool"?s=AE(n):s=parseFloat(n.toFixed(Lv)).toString(),Uc(s,e)}function AE(n){return n===0?"false":"true"}function my(n,e,t,s,r,i=!0){const a=t==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(t==="complex64"){const b=_f(n);return[Df(b[0],0,t)]}return t==="bool"?[AE(n[0])]:[n[0].toString()]}if(l===1){if(o>VN){const v=If*a;let w=Array.from(n.slice(0,v)),$=Array.from(n.slice((o-If)*a,o*a));return t==="complex64"&&(w=_f(w),$=_f($)),["["+w.map((I,N)=>Df(I,r[N],t)).join(", ")+", ..., "+$.map((I,N)=>Df(I,r[o-If+N],t)).join(", ")+"]"]}return["["+(t==="complex64"?_f(n):Array.from(n)).map((v,w)=>Df(v,r[w],t)).join(", ")+"]"]}const c=e.slice(1),d=s.slice(1),f=s[0]*a,p=[];if(o>VN){for(let b=0;b<If;b++){const v=b*f,w=v+f;p.push(...my(n.slice(v,w),c,t,d,r,!1))}p.push("...");for(let b=o-If;b<o;b++){const v=b*f,w=v+f;p.push(...my(n.slice(v,w),c,t,d,r,b===o-1))}}else for(let b=0;b<o;b++){const v=b*f,w=v+f;p.push(...my(n.slice(v,w),c,t,d,r,b===o-1))}const g=l===2?",":"";p[0]="["+(o>0?p[0]+g:"");for(let b=1;b<p.length-1;b++)p[b]=" "+p[b]+g;let x=`,
`;for(let b=2;b<l;b++)x+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(i?"":x),p}function _f(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qn{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=ue(e),s!=null){const r=s.length;B(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||kn(t,this.size),this.strides=Ye(e)}set(e,...t){t.length===0&&(t=[0]),B(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ri().makeTensor(this.values,this.shape,this.dtype)}}let Ri=null,Pc=null;function RP(n){Ri=n}function AP(n){Pc=n}class Gt{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ue(e),this.strides=Ye(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Pc.buffer(this.shape,this.dtype,e)}bufferSync(){return Pc.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return pi(this.shape,e,this.dtype==="complex64")}arraySync(){return pi(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ri().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Oi(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ri().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ri().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Oi(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ri().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ri().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Pc.print(this,e)}clone(){return this.throwIfDisposed(),Pc.clone(this)}toString(e=!1){const t=this.dataSync();return TP(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Pc.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Ri().makeVariable(this,e,t,s)}}Object.defineProperty(Gt,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Se(){return x2("Tensor",()=>Gt)}Se();class _y extends Gt{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!yt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ri().disposeTensor(this),this.dataId=e.dataId,Ri().incRef(this,null)}dispose(){Ri().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(_y,Symbol.hasInstance,{value:n=>n instanceof Gt&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var UN;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(UN||(UN={}));var xw;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(xw||(xw={}));var bw;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(bw||(bw={}));var vw;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(vw||(vw={}));var ww;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(ww||(ww={}));const DP={float32:vw,int32:xw,bool:bw,complex64:ww};function ds(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return DP[n][e]}function ob(n){return ds(n,"int32")}function DE(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function _E(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(n,e){if(n.dtype===e.dtype)return[n,e];const t=ds(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function _P(n,e){B(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function OE(n){const e=[];return FE(n,e,new Set),e}function FE(n,e,t){if(n==null)return;if(n instanceof Gt){e.push(n);return}if(!OP(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),FE(i,e,t))}}function OP(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pv(n){return n.kernelName!=null}class WN{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Kc{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new WN}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Br(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new CP(this.backendInstance),!0}setupRegisteredKernels(){PN(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){PN(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof lx)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Br(`Initialization of backend ${e} failed`),Br(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Br(`Initialization of backend ${e} failed`),Br(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Kc.nextTensorId++}nextVariableId(){return Kc.nextVariableId++}clone(e){const t=se.runKernel(Rh,{x:e}),s={x:e},r=a=>({x:()=>{const o="float32",l={x:a},c={dtype:o};return se.runKernel(yh,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(Dy(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-i-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const c=Pv(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Pv(e)){const{kernelName:x,inputs:b,attrs:v}=e;this.backendName==null&&this.backend;const w=Dy(x,this.backendName);B(w!=null,()=>`Cannot find registered kernel '${x}' for backend '${this.backendName}'`),o=()=>{const $=this.backend.numDataIds();l=w.kernelFunc({inputs:b,attrs:v,backend:this.backend});const I=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(x,$,I);const N=I.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(x,b,N);s=this.saveTensorsForBackwardMode(E)}return N}}else{const{forwardFunc:x}=e,b=v=>{r&&(s=v.map(w=>this.keep(this.clone(w))))};o=()=>{const v=this.backend.numDataIds();l=this.tidy(()=>x(this.backend,b));const w=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,v,w),w}}const{inputs:d,attrs:f}=e,p=Pv(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(g=this.profiler.profileKernel(c,d,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),t=g.outputs)}),r&&this.addTapeNode(c,d,t,p,s,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(x=>d[x]!=null?d[x].shape:null),outputShapes:t.map(x=>x.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=LN(e);if(r!=null){const i=r.inputsToSave||[],a=r.outputsToSave||[];let o;r.saveAllInputs?(B(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(c=>t[c])):o=i.map(c=>t[c]);const l=s.filter((c,d)=>a[d]);return o.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&lh(e[0])&&(i=e.map(l=>Ha(l)));const a=r.write(i,t,s),o=new Gt(t,s,a,this.nextTensorId());if(this.trackTensor(o,r),s==="string"){const l=this.state.tensorInfo.get(a),c=sP(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return o}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,a=new Gt(r,i,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new _y(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Iy(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof _y||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Iy(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},l=LN(e);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=c=>(c=c.map((d,f)=>{if(d==null){const p=s[f],g=ws(p.size,p.dtype);return this.makeTensor(g,p.shape,p.dtype)}return d}),r(c.length>1?c:c[0],i,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=OE(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(B(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));B(i instanceof Gt,()=>"The result y returned by f() must be a tensor.");const a=NP(this.state.activeTape,t,i);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[i.id]=s??FP(i.shape),IP(o,a,c=>this.tidy(c),zP);const l=t.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return B(pw(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{B(t.every(o=>o instanceof Gt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((o,l)=>{r[l]=o});const i=(o,l)=>(s=e(...t,l),B(s.value instanceof Gt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),B(pw(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(o,l)=>{const c=s.gradFunc(o,l),d=Array.isArray(c)?c:[c];B(d.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),B(d.every(p=>p instanceof Gt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return d.forEach((p,g)=>{f[g]=()=>p}),f};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=nr(),s=await this.backend.time(e);return s.wallMs=nr()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new WN;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Kc.nextTensorId=0;Kc.nextVariableId=0;function FP(n){const e=y2(ue(n),"float32");return se.makeTensor(e,n,"float32")}function zE(){const n=$E();if(n._tfengine==null){const e=new iP(n);n._tfengine=new Kc(e)}return uP(n._tfengine.ENV),RP(()=>n._tfengine),n._tfengine}const se=zE();function zP(n,e){const t={a:n,b:e};return se.runKernel(vu,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LP(){return typeof navigator<"u"&&navigator!=null}function LE(n){if(n||LP()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function PE(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const or=fe();or.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});or.registerFlag("IS_BROWSER",()=>PE());or.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");or.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));or.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));or.registerFlag("PROD",()=>!1);or.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>or.getBool("DEBUG"));or.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);or.registerFlag("IS_TEST",()=>!1);or.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>or.getBool("DEBUG"));or.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);or.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);or.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function el(n,e){let t=n;if(yi(n))return e==="string"?[]:[n.length];if(DE(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(_E(n))return[n.buffer.size/(e==null?4:Iy(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||yi(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&fe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ME(n,s,[]),s}function ME(n,e,t){if(t=t||[],!Array.isArray(n)&&!yi(n)){B(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}B(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),B(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)ME(n[r],s,t.concat(r))}function GN(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function U(n,e,t,s="numeric"){if(n instanceof Se())return GN(s,n.dtype,e,t),n;let r=bu(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),GN(s,r,e,t),n==null||!yi(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=el(n,r);!yi(n)&&!Array.isArray(n)&&(n=[n]);const o=r!=="string"?wu(n,r):Ka(n,[],!0);return se.makeTensor(o,i,r)}function Oy(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,a)=>U(i,`${e}[${a}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BE="__op";function J(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+BE;const r=(...i)=>{se.startScope(t);try{const a=s(...i);return iu(a)&&console.error("Cannot return a Promise inside of tidy."),se.endScope(a),a}catch(a){throw se.endScope(null),a}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PP(n,e){const t=U(n,"real","complex"),s=U(e,"imag","complex");cr(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return se.runKernel(gx,r)}const Vo=J({complex_:PP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tl(n,e,t,s){if(s==null)s=bu(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(_E(n)||DE(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return se.backend.createTensorFromGPUData(n,e||t,s)}if(!yi(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Hr(e);const r=ue(e),i=ue(t);B(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let a=0;a<t.length;++a){const o=t[a],l=a===t.length-1?o!==ue(e.slice(a)):!0;B(t[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!yi(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?wu(n,s):Ka(n,[],!0),se.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(n,e,t){const s=el(n,t);return tl(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const au={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Ui{static join(e){return new Ui(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>yi(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),a=new Uint8Array(i);let o=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],f=e+o-c.start,p=o,x=Math.min(t,c.end)-c.start,b=new Uint8Array(c.buffer,f,x-f);if(a.set(b,p),o+=b.length,t<c.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=MP(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function MP(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vs(){return se}function HN(){return se.memory()}function ce(n,e){return se.tidy(n,e)}function et(n){OE(n).forEach(t=>t.dispose())}function cs(n){return se.keep(n)}function BP(n){return se.setBackend(n)}function VP(){return se.ready()}function Gf(){return se.backendName}function R2(n,e,t=1){return se.registerBackend(n,e,t)}function ou(){return se.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uo=4;async function Sw(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){const o=r[a],l=Array.isArray(n)?n[a].tensor:n[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const c={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const d=new Promise(async f=>{const p=await l.bytes(),g=p.reduce((v,w)=>v+w.length,0)+Uo*p.length,x=new Uint8Array(g);let b=0;for(let v=0;v<p.length;v++){const w=p[v],$=new Uint8Array(new Uint32Array([w.length]).buffer);x.set($,b),b+=Uo,x.set(w,b),b+=w.length}f(x)});s.push(d)}else s.push(l.data());e!=null&&(c.group=e),t.push(c)}const i=await Promise.all(s);return{data:GP(i),specs:t}}function VE(n,e){const t=new Ui(n),s={};let r=0;for(const i of e){const a=UP(i,(o,l)=>t.slice(r+o,r+l));s[i.name]=UE(i,t.slice(r,r+a)),r+=a}return s}function UP(n,e){const t=ue(n.shape);let s;if("quantization"in n){const r=n.quantization;s=au[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Uo+new Uint32Array(e(r,r+Uo))[0];return r}else s=au[n.dtype];return t*s}async function WP(n,e){const t=ue(n.shape);let s;if("quantization"in n){const r=n.quantization;s=au[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Uo+new Uint32Array(await e(r,r+Uo))[0];return r}else s=au[n.dtype];return t*s}function UE(n,e){const t=n.name,s=n.dtype,r=n.shape,i=ue(r);let a,o=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=au[l.dtype],d=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){a=new Float32Array(d.length);for(let f=0;f<d.length;f++){const p=d[f];a[f]=p*l.scale+l.min}}else if(l.dtype==="float16")a=YP()(d);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);a=new Int32Array(d.length);for(let f=0;f<d.length;f++){const p=d[f];a[f]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=i*c}else if(s==="string"){const l=ue(n.shape);a=[];for(let c=0;c<l;c++){const d=new Uint32Array(e.slice(o,o+Uo))[0];o+=Uo;const f=new Uint8Array(e.slice(o,o+d));a.push(f),o+=d}}else{const l=au[s];if(s==="float32")a=new Float32Array(e);else if(s==="int32")a=new Int32Array(e);else if(s==="bool")a=new Uint8Array(e);else if(s==="complex64"){a=new Float32Array(e);const c=new Float32Array(a.length/2),d=new Float32Array(a.length/2);for(let x=0;x<c.length;x++)c[x]=a[x*2],d[x]=a[x*2+1];const f=Di(c,r,"float32"),p=Di(d,r,"float32"),g=Vo(f,p);return f.dispose(),p.dispose(),g}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=i*l}return Di(a,r,s)}async function jN(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:i}=await n.read();if(r&&i==null){const o=t-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const a=new Uint8Array(s.length+i.byteLength);a.set(s,0),a.set(new Uint8Array(i),s.length),s=a}return s.buffer}async function WE(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const i of e){const a=await WP(i,async(c,d)=>(r=await jN(s,r,d),r.slice(c,d)));r=await jN(s,r,a);const o=r.slice(0,a);r=r.slice(a);const l=UE(i,o);if(t[i.name]=l,Gf()==="webgpu"){const c=ou();"uploadToGPU"in c&&ue(l.shape)>=fe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return t}function GP(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const A2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function qN(n){return A2?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function HP(n){if(A2)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function jP(n){if(A2){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function GE(n){return Ui.join(n)}function XN(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function HE(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function jE(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function D2(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),jE(n,t,s)}function cm(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:qN(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:qN(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Ui(n.weightData).byteLength}}function Cw(n){const e=[];for(const t of n)e.push(...t.weights);return e}function qP(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function XP(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function KP(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function YP(){const n=qP(),e=XP(),t=KP();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let a=0;a<s.length;a++){const o=s[a],l=n[t[o>>10]+(o&1023)]+e[o>>10];i[a]=l}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return xn.instance==null&&(xn.instance=new xn),xn.instance}static registerSaveRouter(e){xn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){xn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return xn.getHandlers(e,"save")}static getLoadHandlers(e,t){return xn.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?xn.getInstance().loadRouters:xn.getInstance().saveRouters).forEach(a=>{const o=a(e,s);o!==null&&r.push(o)}),r}}const QP=n=>xn.registerSaveRouter(n),ZP=n=>xn.registerLoadRouter(n),qE=n=>xn.getSaveHandlers(n),JP=(n,e)=>xn.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $w="tensorflowjs",kw=1,Yl="models_store",Oo="model_info_store";function XE(){if(!fe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Nw(n){const e=n.result;e.createObjectStore(Yl,{keyPath:"modelPath"}),e.createObjectStore(Oo,{keyPath:"modelPath"})}class lu{constructor(e){if(this.indexedDB=XE(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open($w,kw);i.onupgradeneeded=()=>Nw(i),i.onsuccess=()=>{const a=i.result;if(t==null){const o=a.transaction(Yl,"readonly"),c=o.objectStore(Yl).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),r(c.error)),o.oncomplete=()=>a.close()}else{t.weightData=Ui.join(t.weightData);const o=cm(t),l=a.transaction(Oo,"readwrite");let c=l.objectStore(Oo),d;try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(p){return r(p)}let f;d.onsuccess=()=>{f=a.transaction(Yl,"readwrite");const p=f.objectStore(Yl);let g;try{g=p.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(x){return r(x)}g.onsuccess=()=>s({modelArtifactsInfo:o}),g.onerror=x=>{c=l.objectStore(Oo);const b=c.delete(this.modelPath);b.onsuccess=()=>(a.close(),r(g.error)),b.onerror=v=>(a.close(),r(g.error))}},d.onerror=p=>(a.close(),r(d.error)),l.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},i.onerror=a=>r(i.error)})}}lu.URL_SCHEME="indexeddb://";const KE=n=>fe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(lu.URL_SCHEME)?eM(n.slice(lu.URL_SCHEME.length)):null;xn.registerSaveRouter(KE);xn.registerLoadRouter(KE);function eM(n){return new lu(n)}function tM(n){return n.startsWith(lu.URL_SCHEME)?n.slice(lu.URL_SCHEME.length):n}class nM{constructor(){this.indexedDB=XE()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open($w,kw);s.onupgradeneeded=()=>Nw(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Oo,"readonly"),o=i.objectStore(Oo).getAll();o.onsuccess=()=>{const l={};for(const c of o.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},o.onerror=l=>(r.close(),t(o.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=tM(e),new Promise((t,s)=>{const r=this.indexedDB.open($w,kw);r.onupgradeneeded=()=>Nw(r),r.onsuccess=()=>{const i=r.result,a=i.transaction(Oo,"readwrite"),o=a.objectStore(Oo),l=o.get(e);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=o.delete(e),f=()=>{c=i.transaction(Yl,"readwrite");const g=c.objectStore(Yl).delete(e);g.onsuccess=()=>t(l.result.modelArtifactsInfo),g.onerror=x=>s(l.error)};d.onsuccess=f,d.onerror=p=>(f(),i.close(),s(l.error))}},l.onerror=d=>(i.close(),s(l.error)),a.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wa="/",Mc="tensorflowjs_models",YE="info",sM="model_topology",rM="weight_specs",iM="weight_data",aM="model_metadata";function QE(n){return{info:[Mc,n,YE].join(Wa),topology:[Mc,n,sM].join(Wa),weightSpecs:[Mc,n,rM].join(Wa),weightData:[Mc,n,iM].join(Wa),modelMetadata:[Mc,n,aM].join(Wa)}}function ZE(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function oM(n){const e=n.split(Wa);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Wa)}function lM(n){return n.startsWith(uu.URL_SCHEME)?n.slice(uu.URL_SCHEME.length):n}class uu{constructor(e){if(!fe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=QE(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=cm(e),i=Ui.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,HP(i));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw ZE(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const o=JSON.parse(i);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=jP(a),t}}uu.URL_SCHEME="localstorage://";const JE=n=>fe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(uu.URL_SCHEME)?uM(n.slice(uu.URL_SCHEME.length)):null;xn.registerSaveRouter(JE);xn.registerLoadRouter(JE);function uM(n){return new uu(n)}class cM{constructor(){B(fe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),B(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Mc+Wa,s=Wa+YE;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const a=oM(i);e[a]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=lM(e);const t=QE(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return ZE(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wc="://";class Us{constructor(){this.managers={}}static getInstance(){return Us.instance==null&&(Us.instance=new Us),Us.instance}static registerManager(e,t){B(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Wc)&&(e=e.slice(0,e.indexOf(Wc))),B(e.length>0,()=>"scheme must not be an empty string.");const s=Us.getInstance();B(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=Us.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Us.getInstance().managers)}}function gy(n){if(n.indexOf(Wc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Us.getSchemes().join(",")}`);return{scheme:n.split(Wc)[0],path:n.split(Wc)[1]}}async function eR(n,e,t=!1){B(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=xn.getLoadHandlers(n);B(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),B(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],i=xn.getSaveHandlers(e);B(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),B(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=i[0],o=gy(n).scheme,l=gy(n).path,c=o===gy(n).scheme,d=await r.load();t&&c&&await Us.getManager(o).removeModel(l);const f=await a.save(d);return t&&!c&&await Us.getManager(o).removeModel(l),f.modelArtifactsInfo}async function hM(){const n=Us.getSchemes(),e={};for(const t of n){const s=await Us.getManager(t).listModels();for(const r in s){const i=t+Wc+r;e[i]=s[r]}}return e}async function dM(n){const e=gy(n);return Us.getManager(e.scheme).removeModel(e.path)}async function fM(n,e){return eR(n,e,!1)}async function pM(n,e){return eR(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mM{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!fe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return NE(e)}}if(fe().get("IS_BROWSER")){fe().setPlatform("browser",new mM);try{Us.registerManager(uu.URL_SCHEME,new cM)}catch{}try{Us.registerManager(lu.URL_SCHEME,new nM)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gM={importFetch:()=>require("node-fetch")};let Mv;class yM{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return fe().global.fetch!=null?fe().global.fetch(e,t):(Mv==null&&(Mv=gM.importFetch()),Mv(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}fe().get("IS_NODE")&&!fe().get("IS_BROWSER")&&fe().setPlatform("node",new yM);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ft(n,e="float32",t){return e=e||"float32",Hr(n),new Qn(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xM(n,e){const t=U(n,"x","cast");if(!nP(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return se.runKernel(yh,s,r)}const De=J({cast_:xM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bM(n){const t={x:U(n,"x","clone","string_or_numeric")};return se.runKernel(Rh,t)}const ja=J({clone_:bM});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tR(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zE();const vM={buffer:ft,cast:De,clone:ja,print:tR};AP(vM);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wM(n,e){let t=U(n,"a","add"),s=U(e,"b","add");[t,s]=Nn(t,s);const r={a:t,b:s};return se.runKernel(vu,r)}const Ce=J({add_:wM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SM(n,e){let t=U(n,"a","floorDiv"),s=U(e,"b","floorDiv");[t,s]=Nn(t,s);const r={a:t,b:s};return se.runKernel(Th,r)}const _2=J({floorDiv_:SM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CM(n,e){let t=U(n,"a","div"),s=U(e,"b","div");if([t,s]=Nn(t,s),t.dtype==="int32"&&s.dtype==="int32")return _2(t,s);const r={a:t,b:s},i={};return se.runKernel(Sh,r,i)}const Pe=J({div_:CM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $M(n,e){let t=U(n,"a","mul"),s=U(e,"b","mul");[t,s]=Nn(t,s);const r={a:t,b:s};return se.runKernel(Mh,r)}const Q=J({mul_:$M});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kM(n){const e=U(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return se.runKernel(yp,t)}else{const t={x:e};return se.runKernel(up,t)}}const Xn=J({abs_:kM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NM(n){const t={x:U(n,"x","acos")};return se.runKernel(ch,t)}const nR=J({acos_:NM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IM(n){const t={x:U(n,"x","acosh")};return se.runKernel(hh,t)}const sR=J({acosh_:IM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TM(n){B(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),B(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,i)=>U(r,`tensors${i}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!yt(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return se.runKernel(cp,s)}const EM=J({addN_:TM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RM(n,e=null,t=!1){const r={x:U(n,"x","all","bool")},i={axis:e,keepDims:t};return se.runKernel(ux,r,i)}const O2=J({all_:RM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AM(n,e=null,t=!1){const r={x:U(n,"x","any","bool")},i={axis:e,keepDims:t};return se.runKernel(cx,r,i)}const Fy=J({any_:AM});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DM(n,e=0){const s={x:U(n,"x","argMax")},r={axis:e};return se.runKernel(hp,s,r)}const cu=J({argMax_:DM});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _M(n,e=0){const s={x:U(n,"x","argMin")},r={axis:e};return se.runKernel(dp,s,r)}const rR=J({argMin_:_M});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OM(n){const t={x:U(n,"x","asin")};return se.runKernel(dh,t)}const iR=J({asin_:OM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FM(n){const t={x:U(n,"x","asinh")};return se.runKernel(fh,t)}const aR=J({asinh_:FM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zM(n){const t={x:U(n,"x","atan")};return se.runKernel(ph,t)}const oR=J({atan_:zM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LM(n,e){let t=U(n,"a","atan2"),s=U(e,"b","atan2");[t,s]=Nn(t,s);const r={a:t,b:s};return se.runKernel(gh,r)}const lR=J({atan2_:LM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PM(n){const t={x:U(n,"x","atanh")};return se.runKernel(mh,t)}const uR=J({atanh_:PM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nl(n,e,t,s,r="NHWC",i){const a=n[3],o=[...e,a],l=Tr(r);return un(n,o,t,i,s,null,null,l)}function As(n,e,t,s,r,i,a="channelsLast"){const[o,l]=Hf(e);let c;if(a==="channelsLast")c=[o,l,n[3],n[3]];else if(a==="channelsFirst")c=[o,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return un(n,c,t,s,r,i,!1,a)}function jr(n,e,t,s,r,i,a="NDHWC"){const[o,l,c]=Iw(e);let d,f;if(a==="NDHWC")f="channelsLast",d=[o,l,c,n[4],n[4]];else if(a==="NCDHW")f="channelsFirst",d=[o,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Wi(n,d,t,s,r,!1,f,i)}function un(n,e,t,s,r,i,a=!1,o="channelsLast"){let[l,c,d,f]=[-1,-1,-1,-1];if(o==="channelsLast")[l,c,d,f]=n;else if(o==="channelsFirst")[l,f,c,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,g,,x]=e,[b,v]=Hf(t),[w,$]=Hf(s),I=Gc(p,w),N=Gc(g,$),{padInfo:E,outHeight:D,outWidth:O}=VM(r,c,d,b,v,I,N,i,o),L=a?x*f:x;let z;return o==="channelsFirst"?z=[l,L,D,O]:o==="channelsLast"&&(z=[l,D,O,L]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:d,inChannels:f,outHeight:D,outWidth:O,outChannels:L,padInfo:E,strideHeight:b,strideWidth:v,filterHeight:p,filterWidth:g,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationHeight:w,dilationWidth:$,inShape:n,outShape:z,filterShape:e}}function Wi(n,e,t,s,r,i=!1,a="channelsLast",o){let[l,c,d,f,p]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,c,d,f,p]=n;else if(a==="channelsFirst")[l,p,c,d,f]=n;else throw new Error(`Unknown dataFormat ${a}`);const[g,x,b,,v]=e,[w,$,I]=Iw(t),[N,E,D]=Iw(s),O=Gc(g,N),L=Gc(x,E),z=Gc(b,D),{padInfo:P,outDepth:_,outHeight:H,outWidth:q}=UM(r,c,d,f,w,$,I,O,L,z,o),ee=i?v*p:v;let Y;return a==="channelsFirst"?Y=[l,ee,_,H,q]:a==="channelsLast"&&(Y=[l,_,H,q,ee]),{batchSize:l,dataFormat:a,inDepth:c,inHeight:d,inWidth:f,inChannels:p,outDepth:_,outHeight:H,outWidth:q,outChannels:ee,padInfo:P,strideDepth:w,strideHeight:$,strideWidth:I,filterDepth:g,filterHeight:x,filterWidth:b,effectiveFilterDepth:O,effectiveFilterHeight:L,effectiveFilterWidth:z,dilationDepth:N,dilationHeight:E,dilationWidth:D,inShape:n,outShape:Y,filterShape:e}}function MM(n,e,t,s,r){s==null&&(s=F2(n,e,t));const i=n[0],a=n[1],o=jf((i-e+2*s)/t+1,r),l=jf((a-e+2*s)/t+1,r);return[o,l]}function BM(n,e,t,s,r,i){r==null&&(r=F2(n,e[0],s[0]));const a=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*r>=e[o]&&(a[o]=jf((n[o]-e[o]+2*r)/s[o]+1,i));return a}function F2(n,e,t,s=1){const r=Gc(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function Hf(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Iw(n){return typeof n=="number"?[n,n,n]:n}function Gc(n,e){return e<=1?n:n+(n-1)*(e-1)}function VM(n,e,t,s,r,i,a,o,l){let c,d,f;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const g=MM([e,t],i,s,n,o);d=g[0],f=g[1]}else if(n==="same"){d=Math.ceil(e/s),f=Math.ceil(t/r);const p=Math.max(0,(d-1)*s+i-e),g=Math.max(0,(f-1)*r+a-t),x=Math.floor(p/2),b=p-x,v=Math.floor(g/2),w=g-v;c={top:x,bottom:b,left:v,right:w,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-i+1)/s),f=Math.ceil((t-a+1)/r);else if(typeof n=="object"){const p=l==="channelsLast"?n[1][0]:n[2][0],g=l==="channelsLast"?n[1][1]:n[2][1],x=l==="channelsLast"?n[2][0]:n[3][0],b=l==="channelsLast"?n[2][1]:n[3][1];c={top:p,bottom:g,left:x,right:b,type:p===0&&g===0&&x===0&&b===0?"VALID":"EXPLICIT"},d=jf((e-i+p+g)/s+1,o),f=jf((t-a+x+b)/r+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:d,outWidth:f}}function UM(n,e,t,s,r,i,a,o,l,c,d){let f,p,g,x;if(n==="valid"&&(n=0),typeof n=="number"){f={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const v=BM([e,t,s,1],[o,l,c],1,[r,i,a],n,d);p=v[0],g=v[1],x=v[2]}else if(n==="same"){p=Math.ceil(e/r),g=Math.ceil(t/i),x=Math.ceil(s/a);const b=(p-1)*r+o-e,v=(g-1)*i+l-t,w=(x-1)*a+c-s,$=Math.floor(b/2),I=b-$,N=Math.floor(v/2),E=v-N,D=Math.floor(w/2),O=w-D;f={top:N,bottom:E,left:D,right:O,front:$,back:I,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:f,outDepth:p,outHeight:g,outWidth:x}}function jf(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Wo(n){const[e,t,s]=Hf(n);return e===1&&t===1&&s===1}function ns(n,e){return Wo(n)||Wo(e)}function hu(n){return Hf(n).every(e=>e>0)}function Tr(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Xs(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")B(Xc(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{B(Xc(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WM(n,e){const s={x:U(n,"x","reshape","string_or_numeric")},r={shape:e};return se.runKernel(Qp,s,r)}const ie=J({reshape_:WM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GM(n,e,t,s,r){const i=U(n,"x","avgPool","float32"),a=1;B(ns(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=i,l=!1;i.rank===3&&(l=!0,o=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),B(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Xs("avgPool",s,r);const c={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let f=se.runKernel(fp,c,d);return f=De(f,i.dtype),l?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const lb=J({avgPool_:GM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HM(n,e,t,s,r,i="NDHWC"){const a=U(n,"x","avgPool3d","float32");let o=a,l=!1;a.rank===4&&(l=!0,o=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),B(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),B(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),B(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Xs("avgPool3d",s,r);const c={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let f=se.runKernel(pp,c,d);return f=De(f,o.dtype),l?ie(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const cR=J({avgPool3d_:HM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jM(n,e=0){B(n.length>=1,()=>"Pass at least one tensor to concat");const t=Oy(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return ja(t[0]);const s=t,r={axis:e};return se.runKernel(xp,s,r)}const vn=J({concat_:jM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qM(n,e,t=!1,s=!1){let r=U(n,"a","matMul"),i=U(e,"b","matMul");[r,i]=Nn(r,i);const a={a:r,b:i},o={transposeA:t,transposeB:s};return se.runKernel(mp,a,o)}const Ct=J({matMul_:qM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XM(n){const t={x:U(n,"x","sigmoid","float32")};return se.runKernel(Yh,t)}const Ur=J({sigmoid_:XM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KM(n,e,t){const s=U(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return se.runKernel(nm,r,i)}const ct=J({slice_:KM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YM(n){const t={x:U(n,"x","tanh","float32")};return se.runKernel(nd,t)}const du=J({tanh_:YM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QM(n,e,t,s,r,i){const a=U(n,"forgetBias","basicLSTMCell"),o=U(e,"lstmKernel","basicLSTMCell"),l=U(t,"lstmBias","basicLSTMCell"),c=U(s,"data","basicLSTMCell"),d=U(r,"c","basicLSTMCell"),f=U(i,"h","basicLSTMCell"),p=vn([c,f],1),g=Ct(p,o),x=Ce(g,l),b=x.shape[0],v=x.shape[1]/4,w=[b,v],$=ct(x,[0,0],w),I=ct(x,[0,v],w),N=ct(x,[0,v*2],w),E=ct(x,[0,v*3],w),D=Ce(Q(Ur($),du(I)),Q(d,Ur(Ce(a,N)))),O=Q(du(D),Ur(E));return[D,O]}const ZM=J({basicLSTMCell_:QM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JM(n,e,t){const s=U(n,"x","batchToSpaceND"),r=e.reduce((o,l)=>o*l);B(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),B(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),B(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},a={blockShape:e,crops:t};return se.runKernel(gp,i,a)}const ub=J({batchToSpaceND_:JM});function eB(n){let e;return n.rank===0||n.rank===1?e=ie(n,[1,1,1,n.size]):n.rank===2?e=ie(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tB(n,e,t,s,r,i){i==null&&(i=.001);const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),l=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let d;s!=null&&(d=U(s,"offset","batchNorm")),B(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:eB(a),scale:c,offset:d,mean:o,variance:l},g={varianceEpsilon:i},x=se.runKernel(Ip,p,g);return ie(x,a.shape)}const hm=J({batchNorm_:tB});function nB(n,e,t,s,r,i){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),l=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),B(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),B(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),B(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&B(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),d!=null&&B(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),hm(a,o,l,d,c,i)}const hR=J({batchNorm2d_:nB});function sB(n,e,t,s,r,i){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),l=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),B(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),B(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),B(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&B(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),d!=null&&B(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),hm(a,o,l,d,c,i)}const dR=J({batchNorm3d_:sB});function rB(n,e,t,s,r,i){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),l=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),B(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),B(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),B(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&B(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),d!=null&&B(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),hm(a,o,l,d,c,i)}const fR=J({batchNorm4d_:rB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(n,e,t){const s=U(n,"x","bincount"),r=U(e,"weights","bincount");B(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),B(t>=0,()=>`size must be non-negative, but got ${t}.`),B(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},a={size:t};return se.runKernel(fx,i,a)}const pR=J({bincount_:iB});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(n,e){const t=U(n,"x","bitwiseAnd"),s=U(e,"y","bitwiseAnd");if(!yt(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return se.runKernel(px,r)}const oB=J({bitwiseAnd_:aB});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lB(n,e){const t=U(n,"s0","broadcastArgs","int32"),s=U(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return se.runKernel(mx,r)}const uB=J({broadcastArgs_:lB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cB(n,e){let t=U(n,"broadcastTo","x");const s=t.shape;if(Hr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=ie(t,c)}const r=t.shape,i=Array.from(e);for(let c=e.length-1;c>=0;c--)if(r[c]===e[c])i[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((c,d)=>c>1?d:-1).filter(c=>c>=0).length===0)return ja(t);const o={x:t},l={reps:i};return se.runKernel(sd,o,l)}const Hc=J({broadcastTo_:cB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hB(n){const t={x:U(n,"x","ceil","float32")};return se.runKernel(xh,t)}const mR=J({ceil_:hB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function id(n,e,t){Hr(n),t=t||bu(e);const s={shape:n,value:e,dtype:t};return se.runKernel(Rx,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(n,e,t){const s=U(n,"x","clipByValue");if(B(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return id(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return se.runKernel(bh,r,i)}const lr=J({clipByValue_:dB});function fB(n){return vn(n,0)}const gR=J({concat1d_:fB});function pB(n,e){return vn(n,e)}const yR=J({concat2d_:pB});function mB(n,e){return vn(n,e)}const xR=J({concat3d_:mB});function gB(n,e){return vn(n,e)}const bR=J({concat4d_:gB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yB(n,e,t,s,r="NHWC",i=[1,1],a){const o=U(n,"x","conv2d","float32"),l=U(e,"filter","conv2d","float32");let c=o,d=!1;o.rank===3&&(d=!0,c=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),B(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),B(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Xs("conv2d",s,a);const f=r==="NHWC"?c.shape[3]:c.shape[1];B(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`),B(ns(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),B(hu(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),B(hu(t),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},g={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},x=se.runKernel(bp,p,g);return d?ie(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const Go=J({conv2d_:yB});function xB(n,e,t,s,r="NWC",i=1,a){const o=U(n,"x","conv1d"),l=U(e,"filter","conv1d");let c=o,d=!1;o.rank===2&&(d=!0,c=ie(o,[1,o.shape[0],o.shape[1]])),B(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),B(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Xs("conv1d",s,a),B(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),B(ns(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),B(hu(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),B(hu(t),()=>"Error in conv1D: Stride should be larger than 0."),B(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const f=ie(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=ie(c,[c.shape[0],1,c.shape[1],c.shape[2]]),v=Go(p,f,[1,t],s,"NHWC",[1,i],a);return d?ie(v,[v.shape[2],v.shape[3]]):ie(v,[v.shape[0],v.shape[2],v.shape[3]])}const z2=J({conv1d_:xB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bB(n,e,t,s,r,i="NHWC",a){B(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,l=e,c=!1;e.rank===3&&(c=!0,l=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,n[0],n[1],n[2]]),B(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),B(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),B(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const d=i==="NHWC"?o[3]:o[1],f=i==="NHWC"?l.shape[3]:l.shape[1];B(d===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${t.shape[2]}.`),B(f===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${t.shape[3]}.`),Xs("conv2dDerInput",r,a);const p={dy:l,filter:t},g={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o},x=se.runKernel(vp,p,g);return c?ie(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const L2=J({conv2DBackpropInput_:bB});function vB(n,e,t,s,r,i){const a=U(n,"x","conv2dTranspose"),o=U(e,"filter","conv2dTranspose");return L2(t,a,o,s,r,"NHWC",i)}const P2=J({conv2dTranspose_:vB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wB(n,e,t,s,r="NDHWC",i=[1,1,1]){const a=U(n,"x","conv3d"),o=U(e,"filter","conv3d");let l=a,c=!1;a.rank===4&&(c=!0,l=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),B(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),B(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),B(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),B(ns(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),B(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),B(hu(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),B(hu(t),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:l,filter:o},f={strides:t,pad:s,dataFormat:r,dilations:i},p=se.runKernel(wp,d,f);return c?ie(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const vR=J({conv3d_:wB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SB(n,e,t,s,r){B(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,a=e,o=!1;e.rank===4&&(o=!0,a=ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=a.shape[4];B(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),B(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),B(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),B(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),B(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const d={dy:a,filter:t},f={pad:r,strides:s,inputShape:i},p=se.runKernel(bx,d,f);return o?ie(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const wR=J({conv3DBackpropInput_:SB});function CB(n,e,t,s,r){const i=U(n,"x","conv3dTranspose"),a=U(e,"filter","conv3dTranspose");return wR(t,i,a,s,r)}const SR=J({conv3dTranspose_:CB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(n){const t={x:U(n,"x","cos","float32")};return se.runKernel(vh,t)}const cb=J({cos_:$B});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kB(n){const t={x:U(n,"x","cosh","float32")};return se.runKernel(wh,t)}const M2=J({cosh_:kB});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NB(n,e=0,t=!1,s=!1){const i={x:U(n,"x","cumprod")},a={axis:e,exclusive:t,reverse:s};return se.runKernel(vx,i,a)}const zy=J({cumprod_:NB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IB(n,e=0,t=!1,s=!1){const i={x:U(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:s};return se.runKernel(Sp,i,a)}const B2=J({cumsum_:IB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TB(n,e,t,s=!1){const r=U(n,"x","denseBincount"),i=U(e,"weights","denseBincount");B(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),B(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),B(t>=0,()=>`size must be non-negative, but got ${t}.`),B(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const a={x:r,weights:i},o={size:t,binaryOutput:s};return se.runKernel(Sx,a,o)}const Tw=J({denseBincount_:TB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EB(n,e,t="NHWC"){const s=U(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],a=t==="NHWC"?s.shape[3]:s.shape[1];B(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),B(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),B(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),B(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const o={x:s},l={blockSize:e,dataFormat:t};return se.runKernel(Cx,o,l)}const CR=J({depthToSpace_:EB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RB(n,e,t,s,r="NHWC",i=[1,1],a){const o=U(n,"x","depthwiseConv2d","float32"),l=U(e,"filter","depthwiseConv2d","float32");let c=o,d=!1;o.rank===3&&(d=!0,c=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),B(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),B(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=r==="NHWC"?c.shape[3]:c.shape[1];B(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`),Xs("depthwiseConv2d",s,a);const p={x:c,filter:l},g={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},x=se.runKernel(Cp,p,g);return d?ie(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const dm=J({depthwiseConv2d_:RB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(n){const t={x:U(n,"x","diag")};return se.runKernel(Nx,t)}const DB=J({diag_:AB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _B(n,e,t,s,r=[1,1],i="NHWC"){const a=U(n,"x","dilation2d"),o=U(e,"filter","dilation2d");B(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),B(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),B(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=a,c=!1;a.rank===3&&(l=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0),B(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const d={x:l,filter:o},f={strides:t,pad:s,dilations:r},p=se.runKernel($p,d,f);return c?ie(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const $R=J({dilation2d_:_B});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ho(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,a=n[i]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(i)}return s}function ts(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,a=e[i];(r==null||r===1&&a>1)&&t.unshift(i)}return t}function tt(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let a=e[e.length-r-1];if(a==null&&(a=1),i===1)s[t-r-1]=a;else if(a===1)s[t-r-1]=i;else if(i!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(o)}else s[t-r-1]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(n,e){let t=U(n,"a","equal","string_or_numeric"),s=U(e,"b","equal","string_or_numeric");[t,s]=Nn(t,s),tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(kp,r)}const Fi=J({equal_:OB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(n,e,t){const s=U(e,"a","where"),r=U(t,"b","where"),i=U(n,"condition","where","bool"),a=tt(tt(i.shape,s.shape),r.shape),o=Hc(i,a),l=Hc(s,a),c=Hc(r,a),d={condition:o,t:l,e:c};return se.runKernel(tm,d)}const Rs=J({where_:FB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zB(n){const t={x:U(n,"x","zerosLike")};return se.runKernel(um,t)}const _t=J({zerosLike_:zB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LB(n,e){let t=U(n,"a","div"),s=U(e,"b","div");[t,s]=Nn(t,s);const r=Pe(t,s),i=_t(r),a=Fi(s,i);return Rs(a,i,r)}const kR=J({divNoNan_:LB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PB(n,e){const t=U(n,"t1","dot"),s=U(e,"t2","dot");B((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(B(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const a=ie(t,[1,-1]),o=ie(s,[-1,1]),l=Ct(a,o);return ie(l,[])}else if(t.rank===1&&s.rank===2){const a=ie(t,[1,-1]),o=ie(s,[s.shape[0],s.shape[1]]),l=Ct(a,o);return ie(l,[l.size])}else if(t.rank===2&&s.rank===1){const a=ie(s,[-1,1]),o=Ct(t,a);return ie(o,[o.size])}else{const a=ie(s,[s.shape[0],s.shape[1]]);return Ct(t,a)}}const NR=J({dot_:PB});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(n,...e){const t=e.map((r,i)=>U(r,`tensors${i}`,"einsum")),s={equation:n};return se.runKernel(Ix,t,s)}const Bc=J({einsum_:MB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(n){const t={x:U(n,"x","elu","float32")};return se.runKernel(Ch,t)}const fm=J({elu_:BB});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VB(n,e){const t=U(n,"x","ensureShape","string_or_numeric");if(!eP(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const UB=J({ensureShape_:VB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(n){let e=U(n,"x","erf");B(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=De(e,"float32"));const t={x:e};return se.runKernel($h,t)}const V2=J({erf_:WB});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function IR(n,e,t){const s=n.length+e.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)t.indexOf(o)===-1?r.push(n[i++]):r.push(e[a++]);return r}function On(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function In(n,e){const t=e.map(s=>1);return IR(n,t,e)}function Gn(n,e,t){B(U2(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Zt(n,e){if(U2(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function xa(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function cn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GB(n,e=null,t=!1){const r={x:U(n,"x","max")},i={reductionIndices:e,keepDims:t};return se.runKernel(Lp,r,i)}const mi=J({max_:GB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(n,e=null,t=!1){const r={x:U(n,"x","min")},i={axis:e,keepDims:t};return se.runKernel(Vp,r,i)}const qf=J({min_:HB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jB(n,e){let t=U(n,"base","pow"),s=U(e,"exp","pow");[t,s]=Nn(t,s);const r={a:t,b:s};return se.runKernel(Bh,r)}const Ya=J({pow_:jB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qe(n,e){if((yi(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&yi(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return tl(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qB(n){const t={x:U(n,"x","sqrt","float32")};return se.runKernel(Zh,t)}const Ss=J({sqrt_:qB});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XB(n){const e=U(n,"x","square"),t={};return se.runKernel("Square",{x:e},t)}const Yt=J({square_:XB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB(n,e=null,t=!1){let s=U(n,"x","sum");s.dtype==="bool"&&(s=De(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return se.runKernel(sm,r,i)}const je=J({sum_:KB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YB(n,e="euclidean",t=null,s=!1){n=U(n,"x","norm");const r=TR(n,e,t);let i=r.shape;if(s){const a=pt(t,n.shape);i=In(r.shape,a)}return ie(r,i)}function TR(n,e,t=null){if(n.rank===0)return Xn(n);if(n.rank!==1&&t===null)return TR(ie(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return je(Xn(n),t);if(e===1/0)return mi(Xn(n),t);if(e===-1/0)return qf(Xn(n),t);if(e==="euclidean"||e===2)return Ss(je(Ya(Xn(n),Qe(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return mi(je(Xn(n),t[0]),t[1]-1);if(e===1/0)return mi(je(Xn(n),t[1]),t[0]);if(e===-1/0)return qf(je(Xn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Ss(je(Yt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const pm=J({norm_:YB});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QB(n,e=null,t=!1){return pm(n,"euclidean",e,t)}const ER=J({euclideanNorm_:QB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZB(n){const t={x:U(n,"x","exp")};return se.runKernel(kh,t)}const js=J({exp_:ZB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(n,e=0){const t=U(n,"x","expandDims","string_or_numeric");B(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return se.runKernel(Np,s,r)}const Un=J({expandDims_:JB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e4(n){const t={x:U(n,"x","expm1")};return se.runKernel(Nh,t)}const RR=J({expm1_:e4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t4(n,e){const t=U(n,"x","tile","string_or_numeric");B(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return se.runKernel(sd,s,r)}const hi=J({tile_:t4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n4(n,e,t,s="float32"){e==null&&(e=n);const r=ft([n,e],s),i=n<=e?n:e;for(let o=0;o<i;++o)r.set(1,o,o);const a=ie(r.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return hi(Un(a,0),[t[0],1,1]);if(t.length===2)return hi(Un(Un(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return hi(Un(Un(Un(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const W2=J({eye_:n4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4(n){const t={x:U(n,"x","floor","float32")};return se.runKernel(Ih,t)}const mm=J({floor_:s4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r4(n,e,t=0,s=0){const r=U(n,"x","gather"),i=U(e,"indices","gather","int32"),a={x:r,indices:i},o={axis:t,batchDims:s};return se.runKernel(Tp,a,o)}const gm=J({gather_:r4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i4(n,e){let t=U(n,"a","greater","string_or_numeric"),s=U(e,"b","greater","string_or_numeric");[t,s]=Nn(t,s),tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Ep,r)}const Er=J({greater_:i4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a4(n,e){let t=U(n,"a","greaterEqual","string_or_numeric"),s=U(e,"b","greaterEqual","string_or_numeric");[t,s]=Nn(t,s),tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Eh,r)}const sl=J({greaterEqual_:a4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o4(n){const t={input:U(n,"input","imag")};return se.runKernel(Ox,t)}const hb=J({imag_:o4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l4(n){const t={x:U(n,"x","isFinite")};return se.runKernel(Ah,t)}const AR=J({isFinite_:l4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(n){const t={x:U(n,"x","isInf")};return se.runKernel(Dh,t)}const DR=J({isInf_:u4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c4(n){const t={x:U(n,"x","isNaN")};return se.runKernel(_h,t)}const _R=J({isNaN_:c4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h4(n,e=.2){const s={x:U(n,"x","leakyRelu")},r={alpha:e};return se.runKernel(Rp,s,r)}const db=J({leakyRelu_:h4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d4(n,e){let t=U(n,"a","less","string_or_numeric"),s=U(e,"b","less","string_or_numeric");[t,s]=Nn(t,s),tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Ap,r)}const Xf=J({less_:d4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4(n,e){let t=U(n,"a","lessEqual","string_or_numeric"),s=U(e,"b","lessEqual","string_or_numeric");[t,s]=Nn(t,s),tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Dp,r)}const Su=J({lessEqual_:f4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return se.runKernel(Fx,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4(n,e=5,t=1,s=1,r=.5){const i=U(n,"x","localResponseNormalization");B(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),B(Xc(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=i,o=!1;i.rank===3&&(o=!0,a=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:a},c={depthRadius:e,bias:t,alpha:s,beta:r},d=se.runKernel(zp,l,c);return o?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const OR=J({localResponseNormalization_:m4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g4(n){const t={x:U(n,"x","log","float32")};return se.runKernel(Oh,t)}const Wr=J({log_:g4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4(n){const t={x:U(n,"x","log1p")};return se.runKernel(Fh,t)}const fb=J({log1p_:y4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x4(n,e){B(pw(n),()=>"The f passed in variableGrads(f) must be a function"),B(e==null||Array.isArray(e)&&e.every(c=>c instanceof _y),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in se.registeredVariables)e.push(se.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,r=e.length;e=e.filter(c=>c.trainable),B(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:a,grads:o}=se.gradients(n,e,null,i);B(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),B(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((c,d)=>{o[d]!=null&&(l[c.name]=o[d])}),s?.forEach(c=>l[c.name]=null),{value:a,grads:l}}function Qa(n){return se.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(n){const t={x:U(n,"x","neg")};return se.runKernel(Wp,t)}const fn=J({neg_:b4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v4(n){const t={x:U(n,"x","softplus")};return se.runKernel(Qh,t)}const ad=J({softplus_:v4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w4(n){const e=U(n,"x","logSigmoid");return Qa(s=>({value:fn(ad(fn(s))),gradFunc:a=>Q(a,Ur(fn(s)))}))(e)}const FR=J({logSigmoid_:w4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S4(n,e){let t=U(n,"a","sub"),s=U(e,"b","sub");[t,s]=Nn(t,s);const r={a:t,b:s};return se.runKernel(ed,r)}const Me=J({sub_:S4});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C4(n,e=-1){const t=U(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Qa((r,i)=>{const o=mi(r,e,!0),l=Me(r,o),c=Me(De(l,"float32"),Wr(je(js(l),e,!0)));return i([c]),{value:c,gradFunc:(f,p)=>{const[g]=p,x=!0,b=js(g);return Me(f,Q(je(f,e,x),b))}}})(t)}const G2=J({logSoftmax_:C4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $4(n,e=null,t=!1){const s=U(n,"x","logSumExp"),r=pt(e,s.shape),i=mi(s,r,!0),a=Me(s,i),o=js(a),l=je(o,r),c=Wr(l),d=Ce(ie(i,c.shape),c);if(t){const f=In(d.shape,r);return ie(d,f)}return d}const pb=J({logSumExp_:$4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k4(n,e){const t=U(n,"a","logicalAnd","bool"),s=U(e,"b","logicalAnd","bool");tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(_p,r)}const fa=J({logicalAnd_:k4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N4(n){const t={x:U(n,"x","logicalNot","bool")};return se.runKernel(Op,t)}const mb=J({logicalNot_:N4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I4(n,e){const t=U(n,"a","logicalOr","bool"),s=U(e,"b","logicalOr","bool");tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Fp,r)}const H2=J({logicalOr_:I4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T4(n,e){const t=U(n,"a","logicalXor","bool"),s=U(e,"b","logicalXor","bool");return tt(t.shape,s.shape),fa(H2(n,e),mb(fa(n,e)))}const zR=J({logicalXor_:T4});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jg=2147483648;function E4(n,e,t="left"){const s=U(n,"sortedSequence","searchSorted"),r=U(e,"values","searchSorted"),i=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],o=ie(s,[-1,i]),l=ie(r,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ue(l.shape)>=Jg)throw new Error(`values tensor size must less than ${Jg}`);if(o.shape[1]>=Jg)throw new Error(`trailing dim_size must less than ${Jg} for int32 output type, was ${o.shape[1]}`);const c={sortedSequence:o,values:l},d={side:t};return se.runKernel(Kx,c,d)}const j2=J({searchSorted_:E4});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R4(n,e){return j2(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4(n,e,t,s,r){const i=U(n,"x","maxPool"),a=1;let o=i,l=!1;i.rank===3&&(l=!0,o=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),B(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),B(ns(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),Xs("maxPool",s,r);const c={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r},f=se.runKernel(Pp,c,d);return l?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const gb=J({maxPool_:A4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D4(n,e=[1,1,1],t,s,r,i="NDHWC"){const a=U(n,"x","maxPool3d");let o=a,l=!1;a.rank===4&&(l=!0,o=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),B(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),B(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Xs("maxPool3d",s,r);const c={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},f=se.runKernel(Mp,c,d);return l?ie(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const LR=J({maxPool3d_:D4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _4(n,e,t,s,r=!1){const a={x:U(n,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=se.runKernel(Mx,a,o);return{result:l[0],indexes:l[1]}}const O4=J({maxPoolWithArgmax_:_4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F4(n,e){let t=U(n,"a","maximum"),s=U(e,"b","maximum");[t,s]=Nn(t,s),t.dtype==="bool"&&(t=De(t,"int32"),s=De(s,"int32")),tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(zh,r)}const Za=J({maximum_:F4});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z4(n,e=null,t=!1){const r={x:U(n,"x","mean")},i={axis:e,keepDims:t};return se.runKernel(Bp,r,i)}const $n=J({mean_:z4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn(n,e="float32"){if(Hr(n),e==="complex64"){const s=Dn(n,"float32"),r=Dn(n,"float32");return Vo(s,r)}const t=ws(ue(n),e);return se.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sr(n,e="float32"){if(Hr(n),e==="complex64"){const s=Sr(n,"float32"),r=Dn(n,"float32");return Vo(s,r)}const t=y2(ue(n),e);return se.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=U(n,"x","meshgrid",n instanceof Gt?n.dtype:"float32");if(e===void 0)return[s];let r=U(e,"y","meshgrid",e instanceof Gt?e.dtype:"float32");const i=ue(s.shape),a=ue(r.shape);return t==="xy"?(s=ie(s,[1,-1]),r=ie(r,[-1,1]),[Ct(Sr([a,1],s.dtype),s),Ct(r,Sr([1,i],r.dtype))]):(s=ie(s,[-1,1]),r=ie(r,[1,-1]),[Ct(s,Sr([1,a],s.dtype)),Ct(Sr([i,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P4(n,e){let t=U(n,"a","minimum"),s=U(e,"b","minimum");[t,s]=Nn(t,s),t.dtype==="bool"&&(t=De(t,"int32"),s=De(s,"int32")),tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Lh,r)}const jo=J({minimum_:P4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M4(n,e,t){B(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=U(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");B(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let o=0;o<s.rank;o++)B(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),B(e[o][0]>=0&&e[o][0]<=s.shape[o]-r&&e[o][1]>=0&&e[o][1]<=s.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},a={x:s};return se.runKernel(Up,a,i)}const q2=J({mirrorPad_:M4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B4(n,e){let t=U(n,"a","mod"),s=U(e,"b","mod");[t,s]=Nn(t,s);const r={a:t,b:s};return se.runKernel(Ph,r)}const PR=J({mod_:B4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V4(n,e=null,t=!1){n=U(n,"x","moments");const s=pt(e,n.shape),r=$n(n,s,t);let i=r.shape;t||(i=In(r.shape,s));const a=Yt(Me(De(n,"float32"),ie(r,i))),o=$n(a,s,t);return{mean:r,variance:o}}const yb=J({moments_:V4});function U4(n,e,t,s){const r=U(e,"data","multiRNNCell"),i=Oy(t,"c","multiRNNCell"),a=Oy(s,"h","multiRNNCell");let o=r;const l=[];for(let f=0;f<n.length;f++){const p=n[f](o,i[f],a[f]);l.push(p[0]),l.push(p[1]),o=p[1]}const c=[],d=[];for(let f=0;f<l.length;f+=2)c.push(l[f]),d.push(l[f+1]);return[c,d]}const W4=J({multiRNNCell_:U4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4(n,e,t,s=!1){const r=U(n,"logits","multinomial"),i=r.size,a=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const l={logits:a===1?ie(r,[1,-1]):r},c={numSamples:e,seed:t,normalized:s},d=se.runKernel(Bx,l,c);return a===1?ie(d,[d.size]):d}const H4=J({multinomial_:G4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j4(n,e){let t=U(n,"a","notEqual","string_or_numeric"),s=U(e,"b","notEqual","string_or_numeric");[t,s]=Nn(t,s),tt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Gp,r)}const Yc=J({notEqual_:j4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q4(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:U(n,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:t,offValue:s};return se.runKernel(jp,a,o)}const X2=J({oneHot_:q4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X4(n){const t={x:U(n,"x","onesLike")};return se.runKernel(Hp,t)}const Gr=J({onesLike_:X4});function K4(n,e){const t=U(n,"v1","outerProduct"),s=U(e,"v2","outerProduct");B(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=ie(t,[-1,1]),i=ie(s,[1,-1]);return Ct(r,i)}const Y4=J({outerProduct_:K4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q4(n,e,t=0){const s=U(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return se.runKernel(Xp,i,r)}const zi=J({pad_:Q4});function Z4(n,e,t=0){return B(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),zi(n,[e],t)}const J4=J({pad1d_:Z4});function eV(n,e,t=0){return B(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,e,t)}const tV=J({pad2d_:eV});function nV(n,e,t=0){return B(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,e,t)}const sV=J({pad3d_:nV});function rV(n,e,t=0){return B(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,e,t)}const iV=J({pad4d_:rV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aV(n,e,t){const s=U(n,"x","spaceToBatchND");B(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),B(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),B(s.shape.reduce((a,o,l)=>l>0&&l<=e.length?a&&(o+t[l-1][0]+t[l-1][1])%e[l-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return se.runKernel(rm,r,i)}const xb=J({spaceToBatchND_:aV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oV(n,e,t,s,r,i,a){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const o=U(n,"x","maxPool");let l=o,c=!1;o.rank===3&&(c=!0,l=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),B(ns(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const d=As(l.shape,e,i,r,s),f=[d.dilationHeight,d.dilationWidth];let p;s==="same"?p=uV([d.filterHeight,d.filterWidth],f):p=[[0,0],[0,0]];const g=f[0]===1&&f[1]===1,[x,b]=lV([d.inHeight,d.inWidth],f,p),v=g?s:"valid",w=g?l:xb(l,f,x),I=(t==="avg"?()=>lb(w,e,i,v,a):()=>gb(w,e,i,v,a))(),N=g?I:ub(I,f,b);return c?ie(N,[N.shape[1],N.shape[2],N.shape[3]]):N}function lV(n,e,t){const s=t.map(d=>d[0]),r=t.map(d=>d[1]),i=n.concat(s,r),a=e.map((d,f)=>(d-i[f]%d)%d),o=r.map((d,f)=>d+a[f]),l=e.map((d,f)=>[s[f],o[f]]),c=e.map((d,f)=>[0,a[f]]);return[l,c]}function uV(n,e){const s=n.map((a,o)=>a+(a-1)*(e[o]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),i=s.map((a,o)=>a-r[o]);return s.map((a,o)=>[r[o],i[o]])}const MR=J({pool_:oV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cV(n,e){const t=U(n,"x","prelu"),s=U(e,"alpha","prelu"),r={x:t,alpha:s};return se.runKernel(Kp,r)}const bb=J({prelu_:cV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hV(n,e=null,t=!1){let s=U(n,"x","prod");s.dtype==="bool"&&(s=De(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return se.runKernel(Yp,r,i)}const BR=J({prod_:hV});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dV(n,e,t,s){const r=n.map((d,f)=>U(d,`tensors${f}`,"raggedGather","int32")),i=U(e,"paramsDenseValues","raggedGather"),a=U(t,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:i,indices:a},l={outputRaggedRank:s},c=se.runKernel(w2,o,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const fV=J({raggedGather_:dV});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pV(n,e,t){const s=U(n,"starts","raggedRange"),r=U(e,"limits","raggedRange",s.dtype),i=U(t,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:i},o=se.runKernel(S2,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const mV=J({raggedRange_:pV});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gV(n,e,t,s,r){const i=U(n,"shape","raggedTensorToTensor","int32"),a=U(e,"values","raggedTensorToTensor"),o=U(t,"defaultValue","raggedTensorToTensor",a.dtype),l=s.map((f,p)=>U(f,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:i,values:a,defaultValue:o,rowPartitionTensors:l},d={rowPartitionTypes:r};return se.runKernel(C2,c,d)}const yV=J({raggedTensorToTensor_:gV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xV(n,e,t){Hr(n);const s=ue(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<s;i++)r[i]=e();return se.makeTensor(r,n,t)}const bV=J({rand_:xV});var yy={exports:{}},vV=yy.exports,KN;function wV(){return KN||(KN=1,function(n){(function(e,t,s){function r(l){var c=this,d=o();c.next=function(){var f=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=f-(c.c=f|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(l),c.s0<0&&(c.s0+=1),c.s1-=d(l),c.s1<0&&(c.s1+=1),c.s2-=d(l),c.s2<0&&(c.s2+=1),d=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function a(l,c){var d=new r(l),f=c&&c.state,p=d.next;return p.int32=function(){return d.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,f&&(typeof f=="object"&&i(f,d),p.state=function(){return i(d,{})}),p}function o(){var l=4022871197,c=function(d){d=String(d);for(var f=0;f<d.length;f++){l+=d.charCodeAt(f);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=a:this.alea=a})(vV,n)}(yy)),yy.exports}var xy={exports:{}},SV=xy.exports,YN;function CV(){return YN||(YN=1,function(n){(function(e,t,s){function r(o){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var f=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^f^f>>>8},o===(o|0)?l.x=o:c+=o;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,l.next()}function i(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function a(o,l){var c=new r(o),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(p+g)/(1<<21);while(x===0);return x},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&i(d,c),f.state=function(){return i(c,{})}),f}t&&t.exports?t.exports=a:this.xor128=a})(SV,n)}(xy)),xy.exports}var by={exports:{}},$V=by.exports,QN;function kV(){return QN||(QN=1,function(n){(function(e,t,s){function r(o){var l=this,c="";l.next=function(){var f=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:c+=o;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,d==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function a(o,l){var c=new r(o),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(p+g)/(1<<21);while(x===0);return x},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&i(d,c),f.state=function(){return i(c,{})}),f}t&&t.exports?t.exports=a:this.xorwow=a})($V,n)}(by)),by.exports}var vy={exports:{}},NV=vy.exports,ZN;function IV(){return ZN||(ZN=1,function(n){(function(e,t,s){function r(o){var l=this;l.next=function(){var d=l.x,f=l.i,p,g;return p=d[f],p^=p>>>7,g=p^p<<24,p=d[f+1&7],g^=p^p>>>10,p=d[f+3&7],g^=p^p>>>3,p=d[f+4&7],g^=p^p<<7,p=d[f+7&7],p=p^p<<13,g^=p^p<<9,d[f]=g,l.i=f+1&7,g};function c(d,f){var p,g=[];if(f===(f|0))g[0]=f;else for(f=""+f,p=0;p<f.length;++p)g[p&7]=g[p&7]<<15^f.charCodeAt(p)+g[p+1&7]<<13;for(;g.length<8;)g.push(0);for(p=0;p<8&&g[p]===0;++p);for(p==8?g[7]=-1:g[p],d.x=g,d.i=0,p=256;p>0;--p)d.next()}c(l,o)}function i(o,l){return l.x=o.x.slice(),l.i=o.i,l}function a(o,l){o==null&&(o=+new Date);var c=new r(o),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(p+g)/(1<<21);while(x===0);return x},f.int32=c.next,f.quick=f,d&&(d.x&&i(d,c),f.state=function(){return i(c,{})}),f}t&&t.exports?t.exports=a:this.xorshift7=a})(NV,n)}(vy)),vy.exports}var wy={exports:{}},TV=wy.exports,JN;function EV(){return JN||(JN=1,function(n){(function(e,t,s){function r(o){var l=this;l.next=function(){var d=l.w,f=l.X,p=l.i,g,x;return l.w=d=d+1640531527|0,x=f[p+34&127],g=f[p=p+1&127],x^=x<<13,g^=g<<17,x^=x>>>15,g^=g>>>12,x=f[p]=x^g,l.i=p,x+(d^d>>>16)|0};function c(d,f){var p,g,x,b,v,w=[],$=128;for(f===(f|0)?(g=f,f=null):(f=f+"\0",g=0,$=Math.max($,f.length)),x=0,b=-32;b<$;++b)f&&(g^=f.charCodeAt((b+32)%f.length)),b===0&&(v=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,b>=0&&(v=v+1640531527|0,p=w[b&127]^=g+v,x=p==0?x+1:0);for(x>=128&&(w[(f&&f.length||0)&127]=-1),x=127,b=4*128;b>0;--b)g=w[x+34&127],p=w[x=x+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,w[x]=g^p;d.w=v,d.X=w,d.i=x}c(l,o)}function i(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function a(o,l){o==null&&(o=+new Date);var c=new r(o),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(p+g)/(1<<21);while(x===0);return x},f.int32=c.next,f.quick=f,d&&(d.X&&i(d,c),f.state=function(){return i(c,{})}),f}t&&t.exports?t.exports=a:this.xor4096=a})(TV,n)}(wy)),wy.exports}var Sy={exports:{}},RV=Sy.exports,eI;function AV(){return eI||(eI=1,function(n){(function(e,t,s){function r(o){var l=this,c="";l.next=function(){var f=l.b,p=l.c,g=l.d,x=l.a;return f=f<<25^f>>>7^p,p=p-g|0,g=g<<24^g>>>8^x,x=x-f|0,l.b=f=f<<20^f>>>12^p,l.c=p=p-g|0,l.d=g<<16^p>>>16^x,l.a=x-f|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):c+=o;for(var d=0;d<c.length+20;d++)l.b^=c.charCodeAt(d)|0,l.next()}function i(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function a(o,l){var c=new r(o),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(p+g)/(1<<21);while(x===0);return x},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&i(d,c),f.state=function(){return i(c,{})}),f}t&&t.exports?t.exports=a:this.tychei=a})(RV,n)}(Sy)),Sy.exports}var Cy={exports:{}};const DV={},_V=Object.freeze(Object.defineProperty({__proto__:null,default:DV},Symbol.toStringTag,{value:"Module"})),OV=_L(_V);var FV=Cy.exports,tI;function zV(){return tI||(tI=1,function(n){(function(e,t,s){var r=256,i=6,a=52,o="random",l=s.pow(r,i),c=s.pow(2,a),d=c*2,f=r-1,p;function g(N,E,D){var O=[];E=E==!0?{entropy:!0}:E||{};var L=w(v(E.entropy?[N,I(t)]:N??$(),3),O),z=new x(O),P=function(){for(var _=z.g(i),H=l,q=0;_<c;)_=(_+q)*r,H*=r,q=z.g(1);for(;_>=d;)_/=2,H/=2,q>>>=1;return(_+q)/H};return P.int32=function(){return z.g(4)|0},P.quick=function(){return z.g(4)/4294967296},P.double=P,w(I(z.S),t),(E.pass||D||function(_,H,q,ee){return ee&&(ee.S&&b(ee,z),_.state=function(){return b(z,{})}),q?(s[o]=_,H):_})(P,L,"global"in E?E.global:this==s,E.state)}function x(N){var E,D=N.length,O=this,L=0,z=O.i=O.j=0,P=O.S=[];for(D||(N=[D++]);L<r;)P[L]=L++;for(L=0;L<r;L++)P[L]=P[z=f&z+N[L%D]+(E=P[L])],P[z]=E;(O.g=function(_){for(var H,q=0,ee=O.i,Y=O.j,G=O.S;_--;)H=G[ee=f&ee+1],q=q*r+G[f&(G[ee]=G[Y=f&Y+H])+(G[Y]=H)];return O.i=ee,O.j=Y,q})(r)}function b(N,E){return E.i=N.i,E.j=N.j,E.S=N.S.slice(),E}function v(N,E){var D=[],O=typeof N,L;if(E&&O=="object")for(L in N)try{D.push(v(N[L],E-1))}catch{}return D.length?D:O=="string"?N:N+"\0"}function w(N,E){for(var D=N+"",O,L=0;L<D.length;)E[f&L]=f&(O^=E[f&L]*19)+D.charCodeAt(L++);return I(E)}function $(){try{var N;return p&&(N=p.randomBytes)?N=N(r):(N=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(N)),I(N)}catch{var E=e.navigator,D=E&&E.plugins;return[+new Date,e,D,e.screen,I(t)]}}function I(N){return String.fromCharCode.apply(0,N)}if(w(s.random(),t),n.exports){n.exports=g;try{p=OV}catch{}}else s["seed"+o]=g})(typeof self<"u"?self:FV,[],Math)}(Cy)),Cy.exports}var Bv,nI;function LV(){if(nI)return Bv;nI=1;var n=wV(),e=CV(),t=kV(),s=IV(),r=EV(),i=AV(),a=zV();return a.alea=n,a.xor128=e,a.xorwow=t,a.xorshift7=s,a.xor4096=r,a.tychei=i,Bv=a,Bv}var vb=LV();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K2{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=i||Math.random();this.random=vb.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,a;do r=2*this.random()-1,i=2*this.random()-1,a=r*r+i*i;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*i*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class PV{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const i=r||Math.random();this.randu=vb.alea(i.toString()),this.randn=new K2(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,i,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),i=this.randu(),i<t||Math.log(i)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class MV{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=vb.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BV(n,e,t=1,s="float32",r){if(Hr(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const i=new PV(e,t,s,r),a=ft(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const VV=J({randomGamma_:BV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UV(n,e=0,t=1,s,r){if(Hr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new K2(e,t,s,!1,r),a=ft(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Y2=J({randomNormal_:UV});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WV(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Y2(n,0,1,e,t)}const GV=J({randomStandardNormal_:WV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HV(n,e=0,t=1,s="float32",r){Hr(n);const i=ft(n,s),a=new MV(e,t,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Cu=J({randomUniform_:HV});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jV(n,e,t,s){return Cu(n,e,t,"int32",s)}const qV=J({randomUniformInt_:jV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qc(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return se.runKernel(Wx,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XV(n){const t={input:U(n,"input","real")};return se.runKernel(Gx,t)}const Kf=J({real_:XV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KV(n){const t={x:U(n,"x","reciprocal")};return se.runKernel(Vh,t)}const VR=J({reciprocal_:KV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YV(n){const t={x:U(n,"x","relu")};return se.runKernel(Uh,t)}const ba=J({relu_:YV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QV(n){const t={x:U(n,"x","relu6")};return se.runKernel(Wh,t)}const Q2=J({relu6_:QV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZV(n,e){const s={x:U(n,"x","reverse")},r={dims:e};return se.runKernel(em,s,r)}const xi=J({reverse_:ZV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JV(n){const e=U(n,"x","reverse");return B(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),xi(e,0)}const eU=J({reverse1d_:JV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(n,e){const t=U(n,"x","reverse");return B(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),xi(t,e)}const nU=J({reverse2d_:tU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sU(n,e){const t=U(n,"x","reverse");return B(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),xi(t,e)}const rU=J({reverse3d_:sU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iU(n,e){const t=U(n,"x","reverse");return B(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),xi(t,e)}const aU=J({reverse4d_:iU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oU(n){const t={x:U(n,"x","round")};return se.runKernel(Gh,t)}const Z2=J({round_:oU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lU(n){const t={x:U(n,"x","rsqrt","float32")};return se.runKernel(Hh,t)}const J2=J({rsqrt_:lU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uU(n){const t={x:U(n,"x","selu")};return se.runKernel(jh,t)}const eS=J({selu_:uU});function cU(n,e,t,s,r,i=[1,1],a="NHWC"){const o=U(n,"x","separableConv2d"),l=U(e,"depthwiseFilter","separableConv2d"),c=U(t,"pointwiseFilter","separableConv2d");let d=o,f=!1;if(o.rank===3&&(f=!0,d=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");B(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),B(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),B(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),B(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),B(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],g=l.shape[3];B(c.shape[2]===p*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*g}, but got ${c.shape[2]}.`);const x=dm(d,l,s,r,a,i),v=Go(x,c,1,"valid",a);return f?ie(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const tS=J({separableConv2d_:cU});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function hU(n,e){const t=U(n,"x","setdiff1d"),s=U(e,"y","setdiff1d");B(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),B(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),B(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),i=await s.data(),a=new Set(i);let o=0;for(let d=0;d<r.length;d++)a.has(r[d])||o++;const l=new Qn([o],t.dtype),c=new Qn([o],"int32");for(let d=0,f=0;d<r.length;d++)a.has(r[d])||(l.values[f]=r[d],c.values[f]=d,f++);return[l.toTensor(),c.toTensor()]}const dU=hU;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fU(n){const t={x:U(n,"x","sign")};return se.runKernel(Kh,t)}const UR=J({sign_:fU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pU(n){const t={x:U(n,"x","sin","float32")};return se.runKernel(qh,t)}const nS=J({sin_:pU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mU(n){const t={x:U(n,"x","sinh")};return se.runKernel(Xh,t)}const sS=J({sinh_:mU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gU(n,e,t){const s=U(n,"x","slice1d");return B(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),ct(s,[e],[t])}const wb=J({slice1d_:gU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yU(n,e,t){const s=U(n,"x","slice2d");return B(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),ct(s,e,t)}const rS=J({slice2d_:yU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xU(n,e,t){const s=U(n,"x","slice3d");return B(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),ct(s,e,t)}const Sb=J({slice3d_:xU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bU(n,e,t){const s=U(n,"x","slice4d");return B(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),ct(s,e,t)}const Yf=J({slice4d_:bU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(n,e=-1){const t=U(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return se.runKernel(am,s,r)}const Cb=J({softmax_:vU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wU(n){B(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return se.runKernel(Ex,e)}const $b=J({fft_:wU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SU(n){B(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return se.runKernel(_x,e)}const Qf=J({ifft_:SU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CU(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=ie(n,[t,e]);s=Qf(r)}else{const r=[t,2*(e-1)],i=ie(Kf(n),[t,e]),a=ie(hb(n),[t,e]),o=xi(ct(i,[0,1],[t,e-2]),1),l=Q(xi(ct(a,[0,1],[t,e-2]),1),Qe(-1)),c=vn([i,o],1),d=vn([a,l],1),f=ie(Vo(c,d),[r[0],r[1]]);s=Qf(f)}if(s=Kf(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=ie(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const iS=J({irfft_:CU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $U(n,e,t=0){const r={x:U(n,"x","split")},i={numOrSizeSplits:e,axis:t};return se.runKernel(im,r,i)}const Cr=J({split_:$U});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kU(n,e){B(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const x=n.shape.map(v=>0),b=n.shape.map(v=>v);b[n.shape.length-1]=e,r=ct(n,x,b),t=e}else if(e!=null&&e>t){const x=n.shape.map(b=>b);x[n.shape.length-1]=e-t,r=vn([n,Dn(x)],n.shape.length-1),t=e}else r=n;const i=_t(r),a=ie(Vo(r,i),[s,t]),o=$b(a),l=Math.floor(t/2)+1,c=Kf(o),d=hb(o),f=Cr(c,[l,t-l],c.shape.length-1),p=Cr(d,[l,t-l],d.shape.length-1),g=r.shape.slice();return g[r.shape.length-1]=l,ie(Vo(f[0],p[0]),g)}const kb=J({rfft_:kU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NU(n,e){let t=U(n,"a","squaredDifference"),s=U(e,"b","squaredDifference");[t,s]=Nn(t,s),tt(t.shape,s.shape);const r={a:t,b:s},i={};return se.runKernel(Jh,r,i)}const aS=J({squaredDifference_:NU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IU(n,e){const t=U(n,"x","squeeze","string_or_numeric");return ie(t,Zo(t.shape,e).newShape)}const Mt=J({squeeze_:IU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TU(n,e=0){const t=Oy(n,"tensors","stack","string_or_numeric");B(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&B(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return se.runKernel(qp,s,r)}const $r=J({stack_:TU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EU(n,e=0){const s={x:U(n,"x","step")},r={alpha:e};return se.runKernel(rd,s,r)}const od=J({step_:EU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RU(n,e,t,s,r=0,i=0,a=0,o=0,l=0){const d={x:U(n,"x","stridedSlice","string_or_numeric")},f={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return se.runKernel(tb,d,f)}const WR=J({stridedSlice_:RU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AU(n){const t={x:U(n,"x","tan","float32")};return se.runKernel(td,t)}const GR=J({tan_:AU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(n,e){oh(n);const t=el(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return tl(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gi(n,e,t){if(oh(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=el(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return tl(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HR(n,e,t){if(oh(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=el(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return tl(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(n,e,t){if(oh(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=el(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return tl(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _U(n,e,t){if(oh(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=el(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return tl(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OU(n,e,t){if(oh(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=el(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,tl(n,e,s,t)}function jR(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(t.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-r;++a)if(t.shape[a+r]!==n[a+s])throw new Error(i+` updates.shape[${a+r}] (${t.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function oS(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}jR(t,e,n)}function va(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let a=1;for(let f=r;f<i;++f)a*=t[f];const o=r<1?1:r,l=ue(e.shape)/o,c=[...Ye(t.slice(0,r)),1],d=ue(t);return{sliceRank:r,numUpdates:l,sliceSize:a,strides:c,outputSize:d}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FU(n,e,t){const s=U(n,"tensor","tensorScatterupdate"),r=U(e,"indices","tensorScatterupdate","int32"),i=U(t,"updates","tensorScatterupdate");if(oS(i,r,s.shape),s.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${i.dtype}.`);const a={tensor:s,indices:r,updates:i},o={};return se.runKernel(Xx,a,o)}const zU=J({tensorScatterUpdate_:FU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LU(n,e=1,t=!0){const s=U(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},a={k:e,sorted:t},[o,l]=se.runKernel(sb,i,a);return{values:o,indices:l}}const qR=J({topk_:LU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PU(n,e=0,t=1,s,r){if(Hr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new K2(e,t,s,!0,r),a=ft(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const lS=J({truncatedNormal_:PU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MU(n,e=0){const t=U(n,"x","unique","string_or_numeric");B(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,a]=se.runKernel(T2,s,r);return{values:i,indices:a}}const XR=J({unique_:MU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BU(n,e,t){const s=U(n,"x","unsortedSegmentSum"),r=U(e,"segmentIds","unsortedSegmentSum","int32");B(Xc(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},a={numSegments:t};return se.runKernel(lm,i,a)}const uS=J({unsortedSegmentSum_:BU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VU(n,e=0){const t=U(n,"x","unstack","string_or_numeric");B(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return se.runKernel(om,s,r)}const bi=J({unstack_:VU});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UU(n,e){return j2(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KR(n,e=!0,t,s){return se.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cS(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=ft(n,"int32"),r=ft([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const a=s.indexToLoc(t[i]),o=i*n.length;r.values.set(a,o)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function WU(n){const e=U(n,"condition","whereAsync","bool"),t=await e.data(),s=cS(e.shape,t);return n!==e&&e.dispose(),s}const YR=WU;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function GU(n,e,t){const s=U(n,"tensor","boolMask"),r=U(e,"mask","boolMask","bool"),i=t??0,a=r.rank,o=s.shape;B(a>0,()=>"mask cannot be scalar"),cr(o.slice(i,i+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let b=i;b<i+a;b++)l*=o[b];const c=o.slice(0,i).concat([l],o.slice(i+a)),d=ie(s,c),f=ie(r,[-1]),p=await YR(f),g=Mt(p,[1]),x=gm(d,g,i);return n!==s&&s.dispose(),e!==r&&r.dispose(),g.dispose(),d.dispose(),f.dispose(),p.dispose(),x}const HU=GU;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jU(n,e,t){const s=U(n,"x","transpose");if(e==null&&(e=s.shape.map((a,o)=>o).reverse()),B(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{B(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?ce(()=>{let a=Kf(s),o=hb(s);return a=se.runKernel(Jl,{x:a},i),o=se.runKernel(Jl,{x:o},i),t&&(o=fn(o)),Vo(a,o)}):se.runKernel(Jl,r,i)}const Dt=J({transpose_:jU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qU(n,e,t,s,r=!0){const i=U(n,"v","movingAverage"),a=U(e,"x","movingAverage"),o=U(t,"decay","movingAverage");_P(i,a),B(yt(i.shape,a.shape),()=>"Shape mismatch in v and x");const l=Qe(1),c=Me(l,o);let d=Q(Me(a,i),c);if(r){B(s!=null,()=>"When using zeroDebias: true, step is required.");const f=U(s,"step","movingAverage");d=Pe(d,Me(l,Ya(o,f)))}return Ce(i,d)}const XU=J({movingAverage_:qU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KU(n,e,t){Hr(t);const s=U(n,"indices","scatterND","int32"),r=U(e,"updates","scatterND");oS(r,s,t);const i={indices:s,updates:r},a={shape:t};return se.runKernel(qx,i,a)}const YU=J({scatterND_:KU});function QU(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(n,e,t,s=0){Hr(t);const r=U(n,"sparseIndices","sparseToDense","int32"),i=U(e,"sparseValues","sparseToDense","string_or_numeric"),a=U(s,"defaultValue","sparseToDense",i.dtype);QU(r,i,t,a);const o={sparseIndices:r,sparseValues:i,defaultValue:a},l={outputShape:t};return se.runKernel(Zx,o,l)}const JU=J({sparseToDense_:ZU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eW(n,e){const t=U(e,"indices","gatherND","int32"),r={params:U(n,"x","gatherND","string_or_numeric"),indices:t};return se.runKernel(Dx,r)}const tW=J({gatherND_:eW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nW(n,e){if(e==null)return n.shape.slice();if(yt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sW(n,e,t,s){const r=U(n,"x","dropout");if(B(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),B(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Gt?r.clone():r;const i=nW(r,t),a=1-e,o=Pe(mm(Ce(Cu(i,0,1,"float32",s),a)),a);return Q(r,o)}const QR=J({dropout_:sW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZR(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function hS(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const a=2*Math.PI*i/(n+s-1);r[i]=e-t*Math.cos(a)}return Wn(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function rW(n,e,t=1){const s=U(n,"predictions","inTopK"),r=U(e,"targets","inTopK");B(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),B(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),cr(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];B(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const a=await s.data(),o=await r.data(),[l,c]=[a.length/i,i],d=es("bool",l);for(let f=0;f<l;f++){const p=f*c,g=a.subarray(p,p+c),x=[];for(let b=0;b<g.length;b++)x.push({value:g[b],index:b});x.sort((b,v)=>v.value-b.value),d[f]=0;for(let b=0;b<t;b++)if(x[b].index===o[f]){d[f]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),Di(d,r.shape,"bool")}const iW=rW;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aW(n,e,t,s,r,i="NHWC",a){let o=n;n.rank===3&&(o=ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]])),B(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),B(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),B(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=i==="NHWC"?o.shape[3]:o.shape[1],d=i==="NHWC"?l.shape[3]:l.shape[1];B(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),B(d===t[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${t[3]}).`),Xs("conv2dDerFilter",r,a);const f={x:o,dy:l},p={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:t};return se.runKernel(yx,f,p)}const dS=J({conv2DBackpropFilter_:aW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nb(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Q(n,od(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Ib(n,e){let t=e;const s=ts(n.shape,e.shape);return s.length>0&&(t=je(t,s)),ie(t,n.shape)}function Tb(n,e,t,s){if(e==="linear")return n;if(e==="relu")return ba(n);if(e==="elu")return fm(n);if(e==="relu6")return Q2(n);if(e==="prelu")return bb(n,t);if(e==="leakyrelu")return db(n,s);if(e==="sigmoid")return Ur(n);throw new Error(`Unknown fused activation ${e}.`)}const Eb=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(l=l||"linear",Eb(se.state.gradientDepth,l)===!1){B(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let D=Go(n,e,t,s,r,i,a);return o!=null&&(D=Ce(D,o)),Tb(D,l,c,d)}const f=U(n,"x","conv2d","float32"),p=U(e,"filter","conv2d","float32");let g=f,x=!1;f.rank===3&&(x=!0,g=ie(f,[1,f.shape[0],f.shape[1],f.shape[2]])),B(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),B(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Xs("fused conv2d",s,a);const b=r==="NHWC"?g.shape[3]:g.shape[1];B(p.shape[2]===b,()=>`Error in conv2d: depth of input (${b}) must match input depth for filter ${p.shape[2]}.`),B(ns(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const v=un(g.shape,p.shape,t,i,s,a);let w;o!=null&&(w=U(o,"bias","fused conv2d"),[w]=Nn(w,f),r==="NHWC"?tt(v.outShape,w.shape):(B(w.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${w.shape.length}.`),B(w.shape.length===0||w.shape[0]===v.outChannels||w.shape[0]===1,()=>`Error in fused conv2d: bias shape (${w.shape}) is not compatible with the number of output channels (${v.outChannels})`)));let $;if(c!=null){const D=c.shape;if(B(D.length<=1||D.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${D.length}.`),D.length===1)B(D[0]===1||D[0]===v.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the number of output channels (${v.outChannels}).`);else if(D.length===3)try{tt(D,v.outShape)}catch{const L=`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(L)}$=U(c,"prelu weights","fused conv2d")}const I=(D,O)=>{B(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[L,z,P,_]=O,H=Nb(D,P,l);B(Wo(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const q=L2(z.shape,H,L,t,s),ee=dS(z,H,L.shape,t,s),Y=[q,ee];if(_!=null){const G=Ib(_,H);Y.push(G)}return Y},N={x:g,filter:p,bias:w,preluActivationWeights:$},E={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:d};return o==null?Qa((O,L,z)=>{let P=se.runKernel(Uf,N,E);return z([L,O,P]),x&&(P=ie(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:I}})(g,p):Qa((O,L,z,P)=>{let _=se.runKernel(Uf,N,E);return P([L,O,_,z]),x&&(_=ie(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:I}})(g,p,w)}const JR=J({fusedConv2d_:oW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lW(n,e,t,s,r,i=[1,1],a){let o=n;n.rank===3&&(o=ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:o,dy:l},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:t};return se.runKernel($x,c,d)}const eA=J({depthwiseConv2dNativeBackpropFilter_:lW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uW(n,e,t,s,r,i=[1,1],a){let o=e,l=!1;e.rank===3&&(l=!0,o=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:o,filter:t},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:n},f=se.runKernel(kx,c,d);return l?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const tA=J({depthwiseConv2dNativeBackpropInput_:uW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cW({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(Eb(se.state.gradientDepth,l)===!1){let E=dm(n,e,t,s,r,i,a);return o!=null&&(E=Ce(E,o)),Tb(E,l,c,d)}const f=U(n,"x","depthwiseConv2d","float32"),p=U(e,"filter","depthwiseConv2d","float32");let g=f,x=!1;f.rank===3&&(x=!0,g=ie(f,[1,f.shape[0],f.shape[1],f.shape[2]])),B(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),B(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),B(g.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),i==null&&(i=[1,1]),B(ns(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Xs("fused depthwiseConv2d",s,a);const b=un(g.shape,p.shape,t,i,s,a,!0);let v;o!=null&&(v=U(o,"bias","fused conv2d"),[v]=Nn(v,f),tt(b.outShape,v.shape));let w;c!=null&&(w=U(c,"prelu weights","fused depthwiseConv2d"));const $=(E,D)=>{B(Wo(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[O,L,z,P]=D,_=Nb(E,z,l),H=tA(L.shape,_,O,t,s,i,a),q=eA(L,_,O.shape,t,s,i,a);if(P!=null){const ee=Ib(v,_);return[H,q,ee]}return[H,q]},I={x:g,filter:p,bias:v,preluActivationWeights:w},N={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:d};return o==null?Qa((D,O,L)=>{let z=se.runKernel(Wf,I,N);return L([O,D,z]),x&&(z=ie(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:$}})(g,p):Qa((D,O,L,z)=>{let P=se.runKernel(Wf,I,N);return z([O,D,P,L]),x&&(P=ie(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:$}})(g,p,v)}const hW=J({fusedDepthwiseConv2d_:cW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dW({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(Eb(se.state.gradientDepth,i)===!1){let _=Ct(n,e,t,s);return r!=null&&(_=Ce(_,r)),Tb(_,i,a,o)}let l=U(n,"a","fused matMul"),c=U(e,"b","fused matMul");[l,c]=Nn(l,c);const d=t?l.shape[l.rank-2]:l.shape[l.rank-1],f=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=t?l.shape[l.rank-1]:l.shape[l.rank-2],g=s?c.shape[c.rank-2]:c.shape[c.rank-1],x=l.shape.slice(0,-2),b=c.shape.slice(0,-2),v=ue(x),w=ue(b);B(d===f,()=>`Error in fused matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const I=tt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,g]),N=t?ie(l,[v,d,p]):ie(l,[v,p,d]),E=s?ie(c,[w,g,f]):ie(c,[w,f,g]);let D;r!=null&&(D=U(r,"bias","fused matMul"),[D]=Nn(D,l),tt(I,D.shape));let O;a!=null&&(O=U(a,"prelu weights","fused matMul"));const L=(_,H)=>{const[q,ee,Y,G]=H,te=Nb(ie(_,Y.shape),Y,i);let re,he;if(!t&&!s?(re=Ct(te,ee,!1,!0),he=Ct(q,te,!0,!1)):!t&&s?(re=Ct(te,ee,!1,!1),he=Ct(te,q,!0,!1)):t&&!s?(re=Ct(ee,te,!1,!0),he=Ct(q,te,!1,!1)):(re=Ct(ee,te,!0,!0),he=Ct(te,q,!0,!0)),r!=null){const W=Ib(G,te);return[re,he,W]}else return[re,he]},z={a:N,b:E,bias:D,preluActivationWeights:O},P={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:o};return r==null?Qa((H,q,ee)=>{const Y=se.runKernel(Vf,z,P);return ee([H,q,Y]),{value:ie(Y,I),gradFunc:L}})(N,E):Qa((H,q,ee,Y)=>{const G=se.runKernel(Vf,z,P);return Y([H,q,G,ee]),{value:ie(G,I),gradFunc:L}})(N,E,D)}const Ew=J({fusedMatMul_:dW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fW=Object.freeze(Object.defineProperty({__proto__:null,conv2d:JR,depthwiseConv2d:hW,matMul:Ew},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pW(n){return hS(n,.54,.46)}const mW=J({hammingWindow_:pW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gW(n){return hS(n,.5,.5)}const nA=J({hannWindow_:gW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yW(n,e,t,s=!1,r=0){let i=0;const a=[];for(;i+e<=n.size;)a.push(ct(n,i,e)),i+=t;if(s)for(;i<n.size;){const o=i+e-n.size,l=vn([ct(n,i,e-o),id([o],r)]);a.push(l),i+=t}return a.length===0?gi([],[0,e]):ie(vn(a),[a.length,e])}const sA=J({frame_:yW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xW(n,e,t,s,r=nA){s==null&&(s=ZR(e));const i=sA(n,e,t),a=Q(i,r(e));return kb(a,s)}const bW=J({stft_:xW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(n,e,t,s,r="bilinear",i=0){const a=U(n,"image","cropAndResize"),o=U(e,"boxes","cropAndResize","float32"),l=U(t,"boxInd","cropAndResize","int32"),c=o.shape[0];B(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),B(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),B(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),B(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),B(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),B(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:a,boxes:o,boxInd:l},f={method:r,extrapolationValue:i,cropSize:s};return se.runKernel(wx,d,f)}const wW=J({cropAndResize_:vW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SW(n){const e=U(n,"image","flipLeftRight","float32");B(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return se.runKernel(Ax,t,{})}const CW=J({flipLeftRight_:SW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $W(n){const e=U(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];B(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),B(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,hi(e,r)}const kW=J({grayscaleToRGB_:$W});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NW(n){const e=U(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];B(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),B(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=De(e,"float32"),a=Wn([.2989,.587,.114]);let o;switch(e.rank){case 2:o=Bc("ij,j->i",i,a);break;case 3:o=Bc("ijk,k->ij",i,a);break;case 4:o=Bc("ijkl,l->ijk",i,a);break;case 5:o=Bc("ijklm,m->ijkl",i,a);break;case 6:o=Bc("ijklmn,n->ijklm",i,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Un(o,-1),De(o,r)}const IW=J({rgbToGrayscale_:NW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(n,e,t=0,s=.5){const r=U(n,"image","rotateWithOffset","float32");B(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},a={radians:e,fillValue:t,center:s};return se.runKernel(ib,i,a)}const EW=J({rotateWithOffset_:TW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ld(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const a=n.shape[0];return t=Math.min(t,a),B(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),B(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),B(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),B(e.rank===1,()=>"scores must be a 1D tensor"),B(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),B(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RW(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=U(n,"boxes","nonMaxSuppression","float32"),a=U(e,"scores","nonMaxSuppression","float32"),o=ld(i,a,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return se.runKernel(Vx,{boxes:i,scores:a},l)}const AW=J({nonMaxSuppression_:RW});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DW(n,e,t){const s=_W(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function _W(n,e,t){return FW(n,e,t||OW)}function OW(n,e){return n>e?1:n<e?-1:0}function FW(n,e,t){let s=0,r=n.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=t(e,n[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rb(n,e,t,s,r){return pS(n,e,t,s,r,0)}function fS(n,e,t,s,r,i){return pS(n,e,t,s,r,0,!1,i,!0)}function Ab(n,e,t,s,r,i){return pS(n,e,t,s,r,i,!0)}function pS(n,e,t,s,r,i,a=!1,o=!1,l=!1){const c=[];for(let v=0;v<e.length;v++)e[v]>r&&c.push({score:e[v],boxIndex:v,suppressBeginIndex:0});c.sort(sI);const d=i>0?-.5/i:0,f=[],p=[];for(;f.length<t&&c.length>0;){const v=c.pop(),{score:w,boxIndex:$,suppressBeginIndex:I}=v;if(w<r)break;let N=!1;for(let E=f.length-1;E>=I;--E){const D=zW(n,$,f[E]);if(D>=s){N=!0;break}if(v.score=v.score*LW(s,d,D),v.score<=r)break}v.suppressBeginIndex=f.length,N||(v.score===w?(f.push($),p.push(v.score)):v.score>r&&DW(c,v,sI))}const g=f.length,x=t-g;o&&x>0&&(f.push(...new Array(x).fill(0)),p.push(...new Array(x).fill(0)));const b={selectedIndices:f};return a&&(b.selectedScores=p),l&&(b.validOutputs=g),b}function zW(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),f=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),g=(o-i)*(l-a),x=(f-c)*(p-d);if(g<=0||x<=0)return 0;const b=Math.max(i,c),v=Math.max(a,d),w=Math.min(o,f),$=Math.min(l,p),I=Math.max(w-b,0)*Math.max($-v,0);return I/(g+x-I)}function LW(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function sI(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function PW(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=U(n,"boxes","nonMaxSuppressionAsync"),a=U(e,"scores","nonMaxSuppressionAsync"),o=ld(i,a,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l=await Promise.all([i.data(),a.data()]),c=l[0],d=l[1],{selectedIndices:f}=Rb(c,d,t,s,r);return i!==n&&i.dispose(),a!==e&&a.dispose(),Wn(f,"int32")}const MW=PW;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BW(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=U(n,"boxes","nonMaxSuppression"),o=U(e,"scores","nonMaxSuppression"),l=ld(a,o,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:a,scores:o},d={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},f=se.runKernel(Ux,c,d);return{selectedIndices:f[0],selectedScores:f[1]}}const VW=J({nonMaxSuppressionWithScore_:BW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function UW(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=U(n,"boxes","nonMaxSuppressionAsync"),o=U(e,"scores","nonMaxSuppressionAsync"),l=ld(a,o,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([a.data(),o.data()]),d=c[0],f=c[1],{selectedIndices:p,selectedScores:g}=Ab(d,f,t,s,r,i);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Wn(p,"int32"),selectedScores:Wn(g)}}const WW=UW;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GW(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=U(n,"boxes","nonMaxSuppression"),o=U(e,"scores","nonMaxSuppression"),l=ld(a,o,t,s,r,null),c=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,p={boxes:a,scores:o},g={maxOutputSize:c,iouThreshold:d,scoreThreshold:f,padToMaxOutputSize:i},x=se.runKernel(v2,p,g);return{selectedIndices:x[0],validOutputs:x[1]}}const HW=J({nonMaxSuppressionPadded_:GW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function jW(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=U(n,"boxes","nonMaxSuppressionAsync"),o=U(e,"scores","nonMaxSuppressionAsync"),l=ld(a,o,t,s,r,null),c=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,[p,g]=await Promise.all([a.data(),o.data()]),{selectedIndices:x,validOutputs:b}=fS(p,g,c,d,f,i);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Wn(x,"int32"),validOutputs:Qe(b,"int32")}}const qW=jW;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XW(n,e,t=!1,s=!1){const r=U(n,"images","resizeBilinear");B(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),B(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),B(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=ie(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},c=se.runKernel(Jp,o,l);return a?ie(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const rA=J({resizeBilinear_:XW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KW(n,e,t=!1,s=!1){const r=U(n,"images","resizeNearestNeighbor");B(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),B(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),B(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),B(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=ie(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},c=se.runKernel(Zp,o,l);return a?ie(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const iA=J({resizeNearestNeighbor_:KW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YW(n,e="binary",t=!1,s=.5){const r=U(n,"image","threshold"),i=.2989,a=.587,o=.114,l=r.shape[0]*r.shape[1];let c=Q(Wn([s]),255),d,f,p,g;if(B(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),B(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),B(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),B(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[d,f,p]=Cr(r,[1,1,1],-1);const v=Q(d,i),w=Q(f,a),$=Q(p,o);g=Ce(Ce(v,w),$)}else g=n;if(e==="otsu"){const v=pR(De(Z2(g),"int32"),Di([]),256);c=QW(v,l)}const x=t?Su(g,c):Er(g,c);return De(Q(x,255),"int32")}function QW(n,e){let t=Wn([-1]),s=Wn([0]),r=Wn([0]),i,a,o,l,c,d;for(let f=0;f<n.size-1;f++){i=ct(n,0,f+1),a=ct(n,f+1),c=Pe(je(i),e),d=Pe(je(a),e);const p=je(Q(i,Qc(0,i.size)));o=Pe(p,je(i));const g=id(a.shape,i.size),x=Ce(Qc(0,a.size),g),b=Q(a,x);l=Pe(je(b),je(a));const v=Me(o,l),w=Me(o,l),$=Q(c,d);r=Q(Q($,v),w);const I=Er(r,s);s=Rs(I,r,s),t=Rs(I,Wn([f]),t)}return t}const ZW=J({threshold_:YW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JW(n,e,t="nearest",s="constant",r=0,i){const a=U(n,"image","transform","float32"),o=U(e,"transforms","transform","float32");B(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),B(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),B(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:a,transforms:o},c={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return se.runKernel(rb,l,c)}const eG=J({transform_:JW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tG(n,e,t){const s=U(n,"a","bandPart");B(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,a]=s.shape.slice(-2);let o,l;typeof e=="number"?(B(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),B(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),o=U(e<0?i:e,"numLower","bandPart")):(B(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Rs(Xf(e,0),i,jo(e,i))),typeof t=="number"?(B(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),B(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),l=U(t<0?a:t,"numUpper","bandPart")):(B(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Rs(Xf(t,0),a,jo(t,a)));const c=ie(Qc(0,i,1,"int32"),[-1,1]),d=Qc(0,a,1,"int32"),f=Me(c,d),p=fa(Su(f,o),sl(f,fn(l))),g=Dn([i,a],s.dtype);return ie($r(bi(ie(s,[-1,i,a])).map(x=>Rs(p,x,g))),r)}const nG=J({bandPart_:tG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sG(n){let e;if(Array.isArray(n)){e=!1,B(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)B(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=Cr(n,n.shape[0],0).map(r=>Mt(r,[0]));B(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(se.tidy(()=>{let i=s[r];if(r>0)for(let a=0;a<r;++a){const o=Q(je(Q(t[a],i)),t[a]);i=Me(i,o)}return Pe(i,pm(i,"euclidean"))}));return e?$r(t,0):t}const rG=J({gramSchmidt_:sG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iG(n,e=!1){if(B(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return rI(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=bi(ie(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[c,d]=rI(l,e);r.push(c),i.push(d)});const a=ie($r(r,0),n.shape),o=ie($r(i,0),n.shape);return[a,o]}}function rI(n,e=!1){return se.tidy(()=>{B(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=W2(t),i=ja(n);const a=gi([[1]],[1,1]);let o=ja(a);const l=t>=s?s:t;for(let c=0;c<l;++c){const d=i,f=o,p=r;[o,i,r]=se.tidy(()=>{const g=ct(i,[c,c],[t-c,1]),x=pm(g),b=ct(i,[c,c],[1,1]),v=Rs(Er(b,0),gi([[-1]]),gi([[1]])),w=Me(b,Q(v,x)),$=Pe(g,w);$.shape[0]===1?o=ja(a):o=vn([a,ct($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const I=fn(Pe(Ct(v,w),x)),N=ct(i,[c,0],[t-c,s]),E=Q(I,o),D=Dt(o);if(c===0)i=Me(N,Ct(E,Ct(D,N)));else{const z=Me(N,Ct(E,Ct(D,N)));i=vn([ct(i,[0,0],[c,s]),z],0)}const O=Dt(E),L=ct(r,[0,c],[t,r.shape[1]-c]);if(c===0)r=Me(L,Ct(Ct(L,o),O));else{const z=Me(L,Ct(Ct(L,o),O));r=vn([ct(r,[0,0],[t,c]),z],1)}return[o,i,r]}),et([d,f,p])}return!e&&t>s&&(r=ct(r,[0,0],[t,s]),i=ct(i,[0,0],[s,s])),[r,i]})}const aG=J({qr_:iG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var rr;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(rr||(rr={}));function oG(n,e,t=rr.SUM_BY_NONZERO_WEIGHTS){const s=U(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=U(e,"weights","computeWeightedLoss"));const i=r==null?s:Q(s,r);if(t===rr.NONE)return i;if(t===rr.SUM)return je(i);if(t===rr.MEAN){if(r==null)return $n(i);{const a=s.size/r.size,o=Pe(je(i),je(r));return a>1?Pe(o,Qe(a)):o}}if(t===rr.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Pe(je(i),Qe(s.size));{const a=Q(r,Sr(s.shape)),o=De(je(Yc(a,Qe(0))),"float32");return Pe(je(i),o)}}throw Error(`Unknown reduction: ${t}`)}const Ja=J({computeWeightedLoss_:oG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lG(n,e,t,s=rr.SUM_BY_NONZERO_WEIGHTS){const r=U(n,"labels","absoluteDifference"),i=U(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=U(t,"weights","absoluteDifference")),cr(r.shape,i.shape,"Error in absoluteDifference: ");const o=Xn(Me(r,i));return Ja(o,a,s)}const uG=J({absoluteDifference_:lG});function cG(n,e,t,s,r=rr.SUM_BY_NONZERO_WEIGHTS){const i=U(n,"labels","cosineDistance"),a=U(e,"predictions","cosineDistance");let o=null;s!=null&&(o=U(s,"weights","cosineDistance")),cr(i.shape,a.shape,"Error in cosineDistance: ");const l=Qe(1),c=Me(l,je(Q(i,a),t,!0));return Ja(c,o,r)}const hG=J({cosineDistance_:cG});function dG(n,e,t,s=rr.SUM_BY_NONZERO_WEIGHTS){let r=U(n,"labels","hingeLoss");const i=U(e,"predictions","hingeLoss");let a=null;t!=null&&(a=U(t,"weights","hingeLoss")),cr(r.shape,i.shape,"Error in hingeLoss: ");const o=Qe(1);r=Me(Q(Qe(2),r),o);const l=ba(Me(o,Q(r,i)));return Ja(l,a,s)}const fG=J({hingeLoss_:dG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pG(n,e,t,s=1,r=rr.SUM_BY_NONZERO_WEIGHTS){const i=U(n,"labels","huberLoss"),a=U(e,"predictions","huberLoss");let o=null;t!=null&&(o=U(t,"weights","huberLoss")),cr(i.shape,a.shape,"Error in huberLoss: ");const l=Qe(s),c=Xn(Me(a,i)),d=jo(c,l),f=Me(c,d),p=Ce(Q(Qe(.5),Yt(d)),Q(l,f));return Ja(p,o,r)}const mG=J({huberLoss_:pG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gG(n,e,t,s=1e-7,r=rr.SUM_BY_NONZERO_WEIGHTS){const i=U(n,"labels","logLoss"),a=U(e,"predictions","logLoss");let o=null;t!=null&&(o=U(t,"weights","logLoss")),cr(i.shape,a.shape,"Error in logLoss: ");const l=Qe(1),c=Qe(s),d=fn(Q(i,Wr(Ce(a,c)))),f=Q(Me(l,i),Wr(Ce(Me(l,a),c))),p=Me(d,f);return Ja(p,o,r)}const yG=J({logLoss_:gG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xG(n,e,t,s=rr.SUM_BY_NONZERO_WEIGHTS){const r=U(n,"labels","meanSquaredError"),i=U(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=U(t,"weights","meanSquaredError")),cr(r.shape,i.shape,"Error in meanSquaredError: ");const o=aS(r,i);return Ja(o,a,s)}const bG=J({meanSquaredError_:xG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vG(n,e){const t=U(n,"labels","sigmoidCrossEntropyWithLogits"),s=U(e,"logits","sigmoidCrossEntropyWithLogits");cr(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=ba(s),i=Q(s,t),a=fb(js(fn(Xn(s))));return Ce(Me(r,i),a)}function wG(n,e,t,s=0,r=rr.SUM_BY_NONZERO_WEIGHTS){let i=U(n,"multiClassLabels","sigmoidCrossEntropy");const a=U(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=U(t,"weights","sigmoidCrossEntropy")),cr(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=Qe(s),d=Qe(1),f=Qe(.5);i=Ce(Q(i,Me(d,c)),Q(f,c))}const l=vG(i,a);return Ja(l,o,r)}const SG=J({sigmoidCrossEntropy_:wG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CG(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Qa((r,i,a)=>{const l=pb(i,[t],!0),c=Me(De(i,"float32"),l);a([r,c]);const d=fn(Q(c,r));return{value:je(d,[t]),gradFunc:(g,x)=>{const[b,v]=x,w=In(g.shape,[t]);return[Q(ie(g,w),Me(De(b,"float32"),js(v))),Q(ie(g,w),Me(js(v),De(b,"float32")))]}}})(n,e)}function $G(n,e,t,s=0,r=rr.SUM_BY_NONZERO_WEIGHTS){let i=U(n,"onehotLabels","softmaxCrossEntropy");const a=U(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=U(t,"weights","softmaxCrossEntropy")),cr(i.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const c=Qe(s),d=Qe(1),f=Qe(i.shape[1]);i=Ce(Q(i,Me(d,c)),Pe(c,f))}const l=CG(i,a);return Ja(l,o,r)}const kG=J({softmaxCrossEntropy_:$G});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NG(n,e,t,s){const r=U(n,"indices","sparseFillEmptyRows","int32"),i=U(e,"values","sparseFillEmptyRows"),a=U(t,"denseShape","sparseFillEmptyRows","int32"),o=U(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:r,values:i,denseShape:a,defaultValue:o},c=se.runKernel($2,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const IG=J({sparseFillEmptyRows_:NG});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TG(n,e,t){const s=U(n,"inputIndices","sparseReshape","int32"),r=U(e,"inputShape","sparseReshape","int32"),i=U(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a={inputIndices:s,inputShape:r,newShape:i},o=se.runKernel(k2,a);return{outputIndices:o[0],outputShape:o[1]}}const EG=J({sparseReshape_:TG});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RG(n,e,t){const s=U(n,"data","sparseSegmentMean"),r=U(e,"indices","sparseSegmentMean","int32"),i=U(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return se.runKernel(Yx,a)}const AG=J({sparseSegmentMean_:RG});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DG(n,e,t){const s=U(n,"data","sparseSegmentSum"),r=U(e,"indices","sparseSegmentSum","int32"),i=U(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return se.runKernel(Qx,a)}const _G=J({sparseSegmentSum_:DG});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OG(n,e,t,s,r,i,a,o){const l=U(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=U(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:t,nGramWidths:s,leftPad:r,rightPad:i,padWidth:a,preserveShortSequences:o},f={data:l,dataSplits:c},p=se.runKernel(nb,f,d);return{nGrams:p[0],nGramsSplits:p[1]}}const FG=J({stringNGrams_:OG});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zG(n,e,t=!0){const s=U(n,"input","stringSplit","string"),r=U(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:t},a={input:s,delimiter:r},o=se.runKernel(N2,a,i);return{indices:o[0],values:o[1],shape:o[2]}}const LG=J({stringSplit_:zG});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PG(n,e){const t=U(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return se.runKernel(I2,r,s)}const MG=J({stringToHashBucketFast_:PG});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BG(n,e,t,s=!0){const r=U(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:s};return se.runKernel(eb,{x:r},i)}const VG=J({staticRegexReplace_:BG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG={fft:$b,ifft:Qf,rfft:kb,irfft:iS},WG={hammingWindow:mW,hannWindow:nA,frame:sA,stft:bW},Hs={flipLeftRight:CW,grayscaleToRGB:kW,resizeNearestNeighbor:iA,resizeBilinear:rA,rgbToGrayscale:IW,rotateWithOffset:EW,cropAndResize:wW,nonMaxSuppression:AW,nonMaxSuppressionAsync:MW,nonMaxSuppressionWithScore:VW,nonMaxSuppressionWithScoreAsync:WW,nonMaxSuppressionPadded:HW,nonMaxSuppressionPaddedAsync:qW,threshold:ZW,transform:eG},aA={bandPart:nG,gramSchmidt:rG,qr:aG},GG={absoluteDifference:uG,computeWeightedLoss:Ja,cosineDistance:hG,hingeLoss:fG,huberLoss:mG,logLoss:yG,meanSquaredError:bG,sigmoidCrossEntropy:SG,softmaxCrossEntropy:kG},HG={sparseFillEmptyRows:IG,sparseReshape:EG,sparseSegmentMean:AG,sparseSegmentSum:_G},jG={stringNGrams:FG,stringSplit:LG,stringToHashBucketFast:MG,staticRegexReplace:VG};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qG=new Map,XG=new Map;class ud{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class ci{constructor(){this.classNameMap={}}static getMap(){return ci.instance==null&&(ci.instance=new ci),ci.instance}static register(e){ci.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Ee(n,e,t){B(n.className!=null,()=>"Class being registered does not have the static className property defined."),B(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),B(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return ci.register(n),qG.set(r,n),XG.set(n,r),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rl extends ud{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const a=s.map(o=>({name:o.name,tensor:i[o.name]}));this.applyGradients(a)}else this.applyGradients(i);return et(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return x4(e,t)}dispose(){this.iterations_!=null&&et(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Qe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(rl,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oA extends rl{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:ce(()=>_t(i).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:ce(()=>_t(i).variable(a))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;ce(()=>{const d=Ce(Q(l,this.rho),Q(Yt(o),1-this.rho)),f=Q(Pe(Ss(Ce(c,this.epsilon)),Ss(Ce(l,this.epsilon))),o),p=Ce(Q(c,this.rho),Q(Yt(f),1-this.rho));l.assign(d),c.assign(p);const g=Ce(Q(f,-this.learningRate),i);i.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(et(this.accumulatedGrads.map(e=>e.variable)),et(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lA extends rl{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:ce(()=>id(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const o=this.accumulatedGrads[r].variable;ce(()=>{const l=Ce(o,Yt(a));o.assign(l);const c=Ce(Q(Pe(a,Ss(Ce(l,se.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&et(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uA extends rl{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ce(()=>{this.accBeta1=Qe(t).variable(),this.accBeta2=Qe(s).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ce(()=>{const s=Me(1,this.accBeta1),r=Me(1,this.accBeta2);t.forEach((i,a)=>{const o=se.registeredVariables[i],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:ce(()=>_t(o).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:ce(()=>_t(o).variable(l))});const c=Array.isArray(e)?e[a].tensor:e[i];if(c==null)return;const d=this.accumulatedFirstMoment[a].variable,f=this.accumulatedSecondMoment[a].variable,p=Ce(Q(d,this.beta1),Q(c,1-this.beta1)),g=Ce(Q(f,this.beta2),Q(Yt(c),1-this.beta2)),x=Pe(p,s),b=Pe(g,r);d.assign(p),f.assign(g);const v=Ce(Q(Pe(x,Ce(Ss(b),this.epsilon)),-this.learningRate),o);o.assign(v)}),this.accBeta1.assign(Q(this.accBeta1,this.beta1)),this.accBeta2.assign(Q(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&et(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ce(()=>{this.accBeta1.assign(Ya(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ya(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cA extends rl{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ce(()=>{this.iteration=Qe(0).variable(),this.accBeta1=Qe(t).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ce(()=>{const s=Me(1,this.accBeta1),r=Pe(-this.learningRate,Ce(Q(this.iteration,this.decay),1));t.forEach((i,a)=>{const o=se.registeredVariables[i],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:_t(o).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:_t(o).variable(l)});const c=Array.isArray(e)?e[a].tensor:e[i];if(c==null)return;const d=this.accumulatedFirstMoment[a].variable,f=this.accumulatedWeightedInfNorm[a].variable,p=Ce(Q(d,this.beta1),Q(c,1-this.beta1)),g=Q(f,this.beta2),x=Xn(c),b=Za(g,x);d.assign(p),f.assign(b);const v=Ce(Q(Pe(r,s),Pe(p,Ce(b,this.epsilon))),o);o.assign(v)}),this.iteration.assign(Ce(this.iteration,1)),this.accBeta1.assign(Q(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&et(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mS extends rl{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const a=se.registeredVariables[s];ce(()=>{const o=Ce(Q(this.c,i),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=cs(Qe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hA extends mS{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=Qe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:ce(()=>_t(i).variable(!1))});const a=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[s];o!=null&&ce(()=>{let l;const c=Ce(Q(this.m,a),o);this.useNesterov?l=Ce(Q(this.c,Ce(o,Q(c,this.m))),i):l=Ce(Q(this.c,c),i),a.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&et(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dA extends rl{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=se.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:ce(()=>_t(i).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:ce(()=>_t(i).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:ce(()=>_t(i).variable(a))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;ce(()=>{const d=Ce(Q(l,this.decay),Q(Yt(o),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[r].variable,p=Ce(Q(f,this.decay),Q(o,1-this.decay)),g=Pe(Q(o,this.learningRate),Ss(Me(d,Ce(Yt(p),this.epsilon)))),x=Ce(Q(c,this.momentum),g);l.assign(d),f.assign(p),c.assign(x);const b=Me(i,x);i.assign(b)}else{const f=Ce(Q(l,this.decay),Q(Yt(o),1-this.decay)),p=Ce(Q(c,this.momentum),Pe(Q(o,this.learningRate),Ss(Ce(f,this.epsilon))));l.assign(f),c.assign(p);const g=Me(i,p);i.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&et(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&et(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&et(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KG=[oA,lA,uA,cA,hA,dA,mS];function YG(){for(const n of KG)Ee(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG="model",ZG=".json",JG=".weights.bin";function iI(n){return new Promise(e=>setTimeout(e)).then(n)}class fu{constructor(e){if(!fe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(fu.URL_SCHEME)&&(e=e.slice(fu.URL_SCHEME.length)),(e==null||e.length===0)&&(e=QG),this.modelJsonFileName=e+ZG,this.weightDataFileName=e+JG}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Ui.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=HE(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await iI(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await iI(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:cm(e)}}}}fu.URL_SCHEME="downloads://";class eH{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const i=JSON.parse(r.target.result),a=i.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const l=D2(i,c=>this.loadWeights(c));e(l)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const a of e)t.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),i=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(i).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((s,r)=>{const i=new FileReader;i.onload=a=>{const o=a.target.result;s(o)},i.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(i=>XN(i.name)),r={};for(const i of e)i.paths.forEach(a=>{const o=XN(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const tH=n=>fe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(fu.URL_SCHEME)?nH(n.slice(fu.URL_SCHEME.length)):null;xn.registerSaveRouter(tH);function nH(n="model"){return new fu(n)}function sH(n){return new eH(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(n,e,t,s){a(n),t=t??0,s=s??1,o(t,s);let r=0;const i=l=>(l.then(c=>{const d=t+ ++r/n.length*(s-t);return e(d),c}),l);function a(l){B(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,c){B(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),B(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),B(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function fA(n,e){e==null&&(e={});const t=e.fetchFunc==null?fe().platform.fetch:e.fetchFunc,s=n.map(f=>t(f,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(s):await aI(s,e.onProgress,0,.5)).map(f=>f.arrayBuffer());return e.onProgress==null?await Promise.all(o):await aI(o,e.onProgress,.5,1)}function rH(n,e){var t;const s=e.fetchFunc==null?fe().platform.fetch:e.fetchFunc;let r=0,i;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var o;r<n.length;){i||(i=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await i.read();if(l){r++,i=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,r/n.length);continue}a.enqueue(c);return}a.close()}})}async function iH(n,e="",t,s){return pA(a=>fA(a,{requestInit:s}))(n,e,t)}function pA(n){return async(e,t="",s)=>{const r=e.map(()=>!1),i={},a=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((g,x)=>{let b=0;g.weights.forEach(v=>{const w="quantization"in v?v.quantization.dtype:v.dtype,$=au[w]*ue(v.shape),I=()=>{r[x]=!0,i[x]==null&&(i[x]=[]),i[x].push({manifestEntry:v,groupOffset:b,sizeBytes:$})};s!=null?s.forEach((N,E)=>{N===v.name&&(I(),a[E]=!0)}):I(),o.push(v.name),b+=$})}),!a.every(g=>g)){const g=s.filter((x,b)=>!a[b]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=r.reduce((g,x,b)=>(x&&g.push(b),g),[]),c=[];l.forEach(g=>{e[g].paths.forEach(x=>{const b=t+(t.endsWith("/")?"":"/")+x;c.push(b)})});const d=await n(c),f={};let p=0;return l.forEach(g=>{const x=e[g].paths.length,b=new Ui(d.slice(p,p+x));i[g].forEach(w=>{const $=b.slice(w.groupOffset,w.groupOffset+w.sizeBytes),I=VE($,[w.manifestEntry]);for(const N in I)f[N]=I[N]}),p+=x}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aH="application/octet-stream",oH="application/json";class gS{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(B(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=fe().platform.fetch,B(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&B(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=HE(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:oH}),"model.json"),e.weightData!=null){const a=Ui.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:aH}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:cm(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return D2(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=Cw(e.weightsManifest),r=()=>rH(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=lH(t),i=this.weightPathPrefix||s,a=[],o=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(c)):a.push(i+c+r);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(e){const t=await this.getWeightUrls(e),s=Cw(e),r=await fA(t,this.loadOptions);return[s,r]}}gS.URL_SCHEME_REGEX=/^https?:\/\//;function lH(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function Rw(n){return n.match(gS.URL_SCHEME_REGEX)!=null}const mA=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>Rw(s)):t=Rw(n),t)return yS(n,e)}return null};xn.registerSaveRouter(mA);xn.registerLoadRouter(mA);function yS(n,e){return new gS(n,e)}function uH(n,e){return yS(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vv{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class gA{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class cH{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function hH(n,e,t,s){const r=arguments;return new cH(yA(...r))}function yA(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Vv(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Vv({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Vv({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function dH(n){return new gA(n)}function fH(n){return new gA(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xA=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Ui,browserFiles:sH,browserHTTPRequest:uH,concatenateArrayBuffers:GE,copyModel:fM,decodeWeights:VE,decodeWeightsStream:WE,encodeWeights:Sw,fromMemory:hH,fromMemorySync:yA,getLoadHandlers:JP,getModelArtifactsForJSON:D2,getModelArtifactsForJSONSync:jE,getModelArtifactsInfoForJSON:cm,getSaveHandlers:qE,getWeightSpecs:Cw,http:yS,isHTTPScheme:Rw,listModels:hM,loadWeights:iH,moveModel:pM,registerLoadRouter:ZP,registerSaveRouter:QP,removeModel:dM,weightsLoaderFactory:pA,withSaveHandler:dH,withSaveHandlerSync:fH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ml,oI=!1;function pH(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,i=!1,a=!1,o=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Dy(Ry,se.backendName)!=null){const x={pixels:n},b={numChannels:e};return se.runKernel(Ry,x,b)}const[c,d]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let f;if(a)f=n.getContext("2d").getImageData(0,0,c,d).data;else if(s||t)f=n.data;else if(i||r||o){if(Ml==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Ml=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ml=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ml.canvas.width=c,Ml.canvas.height=d,Ml.drawImage(n,0,0,c,d),f=Ml.getImageData(0,0,c,d).data}let p;if(e===4)p=new Int32Array(f);else{const x=c*d;p=new Int32Array(x*e);for(let b=0;b<x;b++)for(let v=0;v<e;++v)p[b*e+v]=f[b*4+v]}return HR(p,[d,c,e],"int32")}function mH(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}async function xS(n,e){let t=U(n,"img","toPixels");if(!(n instanceof Gt)){const c=t;t=De(c,"int32"),c.dispose()}mH(t);const[s,r]=t.shape.slice(0,2),i=t.rank===2?1:t.shape[2],a=await t.data(),o=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*s*4);for(let c=0;c<s*r;++c){const d=[0,0,0,255];for(let p=0;p<i;p++){const g=a[c*i+p];if(t.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(t.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);i===1?(d[0]=g*o,d[1]=g*o,d[2]=g*o):d[p]=g*o}const f=c*4;l[f+0]=Math.round(d[0]),l[f+1]=Math.round(d[1]),l[f+2]=Math.round(d[2]),l[f+3]=Math.round(d[3])}if(e!=null){oI||Dy(b2,se.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),oI=!0),e.width=r,e.height=s;const c=e.getContext("2d"),d=new ImageData(l,r,s);c.putImageData(d,0,0)}return t!==n&&t.dispose(),l}const bA=J({fromPixels_:pH});function Db(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(ue(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let a=1;for(let f=0;f<r.length-1;++f)a*=r[f];const o=n.shape,l=r.slice();l.pop();let c=1;for(let f=i;f<t;++f)c*=o[f],l.push(o[f]);const d=[...Ye(n.shape).map(f=>f/c),1].slice(0,i);return[l,a,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aw=-2,gH=-1;function _b(n,e,t){const s=n.shape.length;B(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),B(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)B(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function yH(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Ob(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function vA(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function wA(n,e,t){return t<=n?t:t-(e-1)}function SA(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function xH(n,e,t,s,r,i,a,o,l){const c=n.length;let d=new Array(c),f=new Array(c),p=new Array(c);if(e.length&&t>0){const g=e[0],x=t+1;d=CA(a,g,x,s,n),f=$A(o,g,x,r,n),p=vA(i,g,x,n)}else for(let g=0;g<c;g++)d[g]=NA(a,s,i,n,g,l),f[g]=IA(o,r,i,n,g,l),p[g]=kA(i,g,l);return{begin:d,end:f,strides:p}}function CA(n,e,t,s,r){const i=[...r],a=SA(t,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const l=wA(e,t,o);let c=s[l];n&1<<l&&(c=0),i[o]=c}return i}function $A(n,e,t,s,r){const i=[...r],a=SA(t,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const l=wA(e,t,o);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[o]=c}for(let o=0;o<i.length;o++){const l=r[o];i[o]<0&&(i[o]+=l),i[o]=ru(0,i[o],r[o])}return i}function kA(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function NA(n,e,t,s,r,i){let a=e[r];const o=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=ru(0,a,l-1),a}function IA(n,e,t,s,r,i){let a=e[r];const o=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),o>0?a=ru(0,a,l):a=ru(-1,a,l-1),a}function bS(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function vS(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function ym(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{B(a!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((a,o)=>a>=0?a:(B(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,i]}function Fb(n,e,t,s,r,i,a,o,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const f={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let I=0;I<f.dims;I++)d&&(1<<I&o)!==0&&f.numAddAxisAfterEllipsis++,1<<I&a&&(d=!0);d||(f.ellipsisMask|=1<<f.dims,f.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};bH(f,p);let g=!0,x=!0,b=!0;const v=[],w=[];for(let I=0;I<n.length;++I){if(p.strides[I]===0)throw Error(`strides[${I}] must be non-zero`);const N=!!(p.shrinkAxisMask&1<<I),E=n[I];if(E===-1){v.push(N?1:-1);continue}const D=[p.beginMask&1<<I,p.endMask&1<<I],O=[p.strides[I]>0?0:-1,p.strides[I]>0?E:E-1];if(N&&p.strides[I]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&p.strides[I]===1;const L=!!(p.beginMask&1<<I&&p.endMask&1<<I);if(p.beginValid&&p.endValid){if(N){const H=p.begin[I]<0?E+p.begin[I]:p.begin[I];if(p.begin[I]=H,p.end[I]=p.begin[I]+1,H<0||H>=E)throw Error(`slice index ${p.begin[I]} of dimension ${I} out of bounds.`)}else p.begin[I]=lI(p.begin[I],0,p.strides[I],E,D,O),p.end[I]=lI(p.end[I],1,p.strides[I],E,D,O);const _=p.strides[I]===1&&p.begin[I]===0&&p.end[I]===E;g=g&&_,x=x&&(I===0&&p.strides[I]===1||_)}else g=g&&p.strides[I]===1&&L,x=x&&(I===0&&p.strides[I]===1||L);let z,P=!1;if(p.beginValid&&p.endValid?(z=p.end[I]-p.begin[I],P=!0):N?(z=1,P=!0):L&&E>=0&&(p.strides[I]<0?z=-E:z=E,P=!0),P){let _;z===0||z<0!=p.strides[I]<0?_=0:_=Math.trunc(z/p.strides[I])+(z%p.strides[I]!==0?1:0),v.push(_)}else v.push(-1)}for(let I=0;I<p.finalShapeGatherIndices.length;++I){const N=p.finalShapeGatherIndices[I];N>=0?w.push(v[N]):N===Aw&&w.push(1)}return{finalShapeSparse:w.filter((I,N)=>p.finalShapeGatherIndices[N]!==Aw),finalShape:w,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:p.begin,end:p.end,strides:p.strides}}function bH(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(Aw),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(gH),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function lI(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const a=n<0?s+n:n;return a<i[0]?i[0]:a>i[1]?i[1]:a}}const vH=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:_b,computeFlatOffset:vS,computeOutShape:Ob,getNormalizedAxes:xH,isSliceContinous:bS,maskToAxes:yH,parseSliceParams:ym,sliceInfo:Fb,startForAxis:NA,startIndicesWithElidedDims:CA,stopForAxis:IA,stopIndicesWithElidedDims:$A,stridesForAxis:kA,stridesWithElidedDims:vA},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wH{static sgd(e){return new mS(e)}static momentum(e,t,s=!1){return new hA(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new dA(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new uA(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new oA(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new cA(e,t,s,r,i)}static adagrad(e,t=.1){return new lA(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ac=wH;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SH=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function TA(){return new Promise(n=>SH(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zb(n,e){const t=n[0].length;n.forEach((r,i)=>{B(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),B(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let a=0;a<t;a++)B(a===e||r[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function ir(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ai;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Ai||(Ai={}));function EA(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],a=s[s.length-t.length+r],o=s[a];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${o}`)}else s[a]=i}return s}function RA(n){const e={FIRST_DIM_SIZE:Ai.FIRST_DIM_SIZE,VALUE_ROWIDS:Ai.VALUE_ROWIDS,ROW_LENGTHS:Ai.ROW_LENGTHS,ROW_SPLITS:Ai.ROW_SPLITS,ROW_LIMITS:Ai.ROW_LIMITS,ROW_STARTS:Ai.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function AA(n){return n.length===0?0:n[0]===Ai.FIRST_DIM_SIZE?n.length-1:n.length}function DA(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],a=e[r+1];if(i>=0&&a>=0&&i!==1&&i!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wS=30;function Lb(n){return n<=wS?n:mw(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pb(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $u(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let a=0;a<i;++a)r=r.concat([n[a+1]/e[a],e[a]]);r=r.concat(n.slice(i+1))}return r}function ku(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?i.push(a):r.push(a);s.push(...r),s.push(0),s.push(...i)}return s}function Nu(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function Mb(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Bb(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xm=1.7580993408473768,bm=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vb=.3275911,Ub=.254829592,Wb=-.284496736,Gb=1.421413741,Hb=-1.453152027,jb=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Li(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function _A(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function OA(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function FA(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function SS(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function zA(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function LA(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function PA(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uv="->",CH=/->/g,uI=",",cI="...";function qb(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(CH,"").length)/Uv.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Uv}").`);const[s,r]=n.split(Uv);B(s.indexOf(cI)===-1,()=>`The ellipsis notation ("${cI}") is not supported yet.`);const i=s.split(uI),a=i.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let p=0;p<r.length;++p){const g=r[p];if(!i.some(x=>x.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let p=0;p<s.length;++p){const g=s[p];o.indexOf(g)===-1&&g!==uI&&o.push(g)}const l=new Array(i.length);for(let p=0;p<a;++p){if(new Set(i[p].split("")).size!==i[p].length)throw new Error(`Found duplicate axes in input component ${i[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let g=0;g<i[p].length;++g)l[p].push(o.indexOf(i[p][g]))}const c=o.length,d=r.length,f=[];for(let p=d;p<c;++p)f.push(p);return{allDims:o,summedDims:f,idDims:l}}function Xb(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Kb(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=i[a]:B(s[e[r][a]]===i[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(i)}, but got dimension ${i[a]}`)}}function Yb(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const i=[];for(let a=0;a<t.length;++a){const o=t[a],l=$H(e,o);for(const c of l)i.indexOf(c)===-1&&(s[a].push(c),i.push(c))}return{path:t,steps:s}}function Qb(n){return n.every((e,t)=>e===t)}function $H(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Zb(n,e,t=0){let s=[];if(typeof e=="number")B(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);B(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const a=e.reduce((o,l)=>l>0?o+l:o);e[i]=n.shape[t]-a}B(n.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function BA(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function VA(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UA(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function WA(n,e){return`size ${n} must be non-negative, not ${e}`}function GA(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function HA(n,e){const t=ue(n),s=ue(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function jA(n,e){const t=ue(n),s=ue(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dw(){return"segment ids must be >= 0"}function qA(){return"segment ids are not increasing"}function XA(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function KA(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(n,e){let t=!1,s;for(n<=wS?(s=n,t=!0):s=mw(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=mw(n,s+1);return s}function CS(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function Jb(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let f=0;f<s;++f)if(n.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${n.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const a=n.shape[t],o=[];let l=1,c=1,d=1;for(let f=0;f<s;++f)o.push(n.shape[f]),l*=n.shape[f];for(let f=s;f<t;f++)o.push(n.shape[f]),c*=n.shape[f];for(let f=s;f<r;f++)o.push(e.shape[f]);for(let f=t+1;f<i;f++)o.push(n.shape[f]),d*=n.shape[f];return{batchSize:l,sliceSize:d,outerSize:c,dimSize:a,outputShape:o}}const kH=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Jb,computeOutShape:CS,segOpComputeOptimalWindowSize:YA},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(n){try{return n.map(e=>Oi(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function QA(n){return n.map(e=>Ha(e))}const NH=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Ub,ERF_A2:Wb,ERF_A3:Gb,ERF_A4:Hb,ERF_A5:jb,ERF_P:Vb,PARALLELIZE_THRESHOLD:wS,get RowPartitionType(){return Ai},SELU_SCALE:bm,SELU_SCALEALPHA:xm,applyActivation:Tb,assertAndGetBroadcastShape:tt,assertAxesAreInnerMostDims:Gn,assertParamsConsistent:zb,assignToTypedArray:zA,axesAreInnerMostDims:U2,calculateShapes:va,checkEinsumDimSizes:Kb,checkPadOnDimRoundingMode:Xs,combineLocations:IR,combineRaggedTensorToTensorShapes:EA,complexWithEvenIndex:OA,complexWithOddIndex:FA,computeConv2DInfo:un,computeConv3DInfo:Wi,computeDefaultPad:F2,computeDilation2DInfo:nl,computeOptimalWindowSize:Lb,computeOutAndReduceShapes:On,computeOutShape:ir,computePool2DInfo:As,computePool3DInfo:jr,convertConv2DDataFormat:Tr,decodeEinsumEquation:qb,eitherStridesOrDilationsAreOne:ns,expandShapeToKeepDim:In,exponent:PA,exponents:LA,fromStringArrayToUint8:QA,fromUint8ToStringArray:Pi,getAxesPermutation:Zt,getBroadcastDims:Ho,getComplexWithIndex:SS,getEinsumComputePath:Yb,getEinsumPermutation:Xb,getFusedBiasGradient:Ib,getFusedDyActivation:Nb,getImageCenter:Pb,getInnerMostAxes:cn,getPermuted:ku,getRaggedRank:AA,getReductionAxes:ts,getReshaped:$u,getReshapedPermuted:Nu,getRowPartitionTypesHelper:RA,getSliceBeginCoords:Mb,getSliceSize:Bb,getSparseFillEmptyRowsIndicesDenseShapeMismatch:MA,getSparseFillEmptyRowsNegativeIndexErrorMessage:BA,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:VA,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:GA,getSparseReshapeInputOutputMismatchErrorMessage:jA,getSparseReshapeInputOutputMultipleErrorMessage:HA,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:UA,getSparseReshapeNegativeOutputDimErrorMessage:WA,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:KA,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Dw,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:qA,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:XA,getUndoAxesPermutation:xa,isIdentityPermutation:Qb,log:fP,mergeRealAndImagArrays:Li,prepareAndValidate:Db,prepareSplitSize:Zb,segment_util:kH,shouldFuse:Eb,slice_util:vH,splitRealAndImagArrays:_A,stridesOrDilationsArePositive:hu,tupleValuesAreOne:Wo,upcastType:ds,validateDefaultValueShape:DA,validateInput:oS,validateUpdateShape:jR,warn:Br},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */YG();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IH=fe();IH.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var br;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(br||(br={}));var hI;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(hI||(hI={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TH={};function ZA(n){return TH[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R(n,e,t,s,r){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const o=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?o+1:i.inputIndexEnd,c=o<0?e.inputNames.length+o:o;if(i.type==="tensor")return bs(e.inputNames[c],t,s,r);if(i.type==="tensors"){const p=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((x,b)=>{var v;return((v=p[b])===null||v===void 0?void 0:v.op)!=="NoOp"}).map(x=>bs(x,t,s,r))}const d=bs(e.inputNames[c],t,s,r),f=d.dataSync();return i.type==="number"?f[0]:pi(d.shape,f)}const a=e.attrParams[n];return a&&a.value}function bs(n,e,t,s){const[r,i]=vr(n,t);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const a=t.currentContextIds.find(o=>!!e[Ly(r,o)]);return a!==void 0?e[Ly(r,a)][i]:void 0}function dI(n,e,t){return e[Ly(n,t.currentContextId)]}function Ba(n,e){const[t,s,r]=vr(n,e);return[Ly(t,e&&e.currentContextId),s,r]}function Ly(n,e){return e?`${n}-${e}`:n}function vr(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const i=s[0],a=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[i,o,a]}return t&&e.parseNodeNameCache.set(n,r),r}function $y(n,e,t){let s=R("pad",n,e,t);if(s==="explicit"){s=R("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function Va(n){return n.kept?n:ja(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EH=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],RH=Object.freeze(Object.defineProperty({__proto__:null,json:EH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AH=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],DH=Object.freeze(Object.defineProperty({__proto__:null,json:AH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _H=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],OH=Object.freeze(Object.defineProperty({__proto__:null,json:_H},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FH=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],zH=Object.freeze(Object.defineProperty({__proto__:null,json:FH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LH=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],PH=Object.freeze(Object.defineProperty({__proto__:null,json:LH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MH=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],BH=Object.freeze(Object.defineProperty({__proto__:null,json:MH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VH=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],UH=Object.freeze(Object.defineProperty({__proto__:null,json:VH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WH=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],GH=Object.freeze(Object.defineProperty({__proto__:null,json:WH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HH=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],jH=Object.freeze(Object.defineProperty({__proto__:null,json:HH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qH=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],XH=Object.freeze(Object.defineProperty({__proto__:null,json:qH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KH=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],YH=Object.freeze(Object.defineProperty({__proto__:null,json:KH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QH=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],ZH=Object.freeze(Object.defineProperty({__proto__:null,json:QH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JH=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],e6=Object.freeze(Object.defineProperty({__proto__:null,json:JH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t6=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],n6=Object.freeze(Object.defineProperty({__proto__:null,json:t6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s6=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],r6=Object.freeze(Object.defineProperty({__proto__:null,json:s6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i6=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],a6=Object.freeze(Object.defineProperty({__proto__:null,json:i6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o6=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],l6=Object.freeze(Object.defineProperty({__proto__:null,json:o6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u6=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],c6=Object.freeze(Object.defineProperty({__proto__:null,json:u6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h6=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],d6=Object.freeze(Object.defineProperty({__proto__:null,json:h6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fI{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[RH,DH,OH,zH,PH,BH,UH,GH,jH,XH,YH,ZH,e6,n6,r6,a6,l6,c6,d6],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],i=[],a=[],o=s.reduce((b,v)=>(b[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?r.push(b[v.name]):v.op==="Const"?i.push(b[v.name]):(v.input==null||v.input.length===0)&&a.push(b[v.name]),b),{});let l=[];const c=[];let d={},f={};t!=null&&(d=this.mapSignatureEntries(t.inputs),f=this.mapSignatureEntries(t.outputs));const p=Object.keys(o);p.forEach(b=>{const v=o[b];v.inputNames.forEach((w,$)=>{const[I,,N]=Ba(w),E=o[I];if(E.outputs!=null){const D=E.outputs.indexOf(N);if(D!==-1){const O=`${I}:${D}`;v.inputNames[$]=O}}v.inputs.push(E),E.children.push(v)})}),Object.keys(f).length===0?p.forEach(b=>{const v=o[b];v.children.length===0&&c.push(v)}):Object.keys(f).forEach(b=>{const[v]=Ba(b),w=o[v];w!=null&&(w.signatureKey=f[b],c.push(w))}),Object.keys(d).length>0?Object.keys(d).forEach(b=>{const[v]=Ba(b),w=o[v];w&&(w.signatureKey=d[b],l.push(w))}):l=r;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((b,v)=>(b[v.signature.name]=this.mapFunction(v),b),{}));const x={nodes:o,inputs:l,outputs:c,weights:i,placeholders:r,signature:t,functions:g};return a.length>0&&(x.initNodes=a),x}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=ZA(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,i)=>{const a=i.type;let o;switch(i.type){case"string":o=_w(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=_w(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":o=Bw(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=Bw(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":o=Fw(e.attr,i.tfName,i.defaultValue||0),o===void 0&&i.tfDeprecatedName&&(o=Fw(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":o=Mw(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=Mw(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":o=Ow(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=Ow(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":o=Uw(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=Uw(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":o=Pw(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=Pw(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":o=Vw(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=Vw(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":o=zw(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=zw(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":o=Lw(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=Lw(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":o=pI(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=pI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return r[i.name]={value:o,type:a},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let i={};t!=null&&(i=t.reduce((f,p)=>(f[p.name]=this.mapNode(p),p.op==="Const"&&r.push(f[p.name]),f),{}));const a=[],o=[];e.signature.inputArg.forEach(f=>{const[p]=Ba(f.name),g={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:$S(f.type),type:"dtype"}},children:[]};g.signatureKey=f.name,a.push(g),i[p]=g}),Object.keys(i).forEach(f=>{const p=i[f];p.inputNames.forEach((g,x)=>{const[b,,v]=Ba(g),w=i[b];if(w.outputs!=null){const $=w.outputs.indexOf(v);if($!==-1){const I=`${b}:${$}`;p.inputNames[x]=I}}p.inputs.push(w),w.children.push(p)})});const c=e.ret;e.signature.outputArg.forEach(f=>{const[p,g]=Ba(c[f.name]),x=i[p];x!=null&&(x.defaultOutput=g,o.push(x))});const d=this.mapArgsToSignature(e);return{nodes:i,inputs:a,outputs:o,weights:r,placeholders:s,signature:d}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function f6(n){const e=fe().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function JA(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):f6(n);return e?t:t.toLowerCase()}function _w(n,e,t,s=!1){const r=n[e];return r!=null?JA(r.s,s):t}function Ow(n,e,t){const s=n[e];return s?s.b:t}function Fw(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function $S(n){switch(typeof n=="string"&&(n=br[n]),n){case br.DT_FLOAT:case br.DT_HALF:return"float32";case br.DT_INT32:case br.DT_INT64:case br.DT_INT8:case br.DT_UINT8:return"int32";case br.DT_BOOL:return"bool";case br.DT_DOUBLE:return"float32";case br.DT_STRING:return"string";case br.DT_COMPLEX64:case br.DT_COMPLEX128:return"complex64";default:return null}}function pI(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function zw(n,e,t){const s=n[e];return s&&s.type?$S(s.type):t}function Lw(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>$S(r)):t}function e3(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Pw(n,e,t){const s=n[e];return s&&s.shape?e3(s.shape):t}function Mw(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function Bw(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(i=>JA(i,s)):t}function Vw(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>e3(r)):t}function Uw(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p6{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(e){return bs(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return bs(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Fw(this.node.rawAttrs,e,t);if(s.s!=null)return _w(this.node.rawAttrs,e,t);if(s.b!=null)return Ow(this.node.rawAttrs,e,t);if(s.shape!=null)return Pw(this.node.rawAttrs,e,t);if(s.type!=null)return zw(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Mw(this.node.rawAttrs,e,t);if(s.list.s!=null)return Bw(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Vw(this.node.rawAttrs,e,t);if(s.list.b!=null)return Uw(this.node.rawAttrs,e,t);if(s.list.type!=null)return Lw(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cs=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:BE,abs:Xn,acos:nR,acosh:sR,add:Ce,addN:EM,all:O2,any:Fy,argMax:cu,argMin:rR,asin:iR,asinh:aR,atan:oR,atan2:lR,atanh:uR,avgPool:lb,avgPool3d:cR,basicLSTMCell:ZM,batchNorm:hm,batchNorm2d:hR,batchNorm3d:dR,batchNorm4d:fR,batchToSpaceND:ub,bincount:pR,bitwiseAnd:oB,booleanMaskAsync:HU,broadcastArgs:uB,broadcastTo:Hc,buffer:ft,cast:De,ceil:mR,clipByValue:lr,clone:ja,complex:Vo,concat:vn,concat1d:gR,concat2d:yR,concat3d:xR,concat4d:bR,conv1d:z2,conv2d:Go,conv2dTranspose:P2,conv3d:vR,conv3dTranspose:SR,cos:cb,cosh:M2,cosineWindow:hS,cumprod:zy,cumsum:B2,denseBincount:Tw,depthToSpace:CR,depthwiseConv2d:dm,diag:DB,dilation2d:$R,div:Pe,divNoNan:kR,dot:NR,dropout:QR,einsum:Bc,elu:fm,enclosingPowerOfTwo:ZR,ensureShape:UB,equal:Fi,erf:V2,euclideanNorm:ER,exp:js,expandDims:Un,expm1:RR,eye:W2,fft:$b,fill:id,floor:mm,floorDiv:_2,fused:fW,gather:gm,gatherND:tW,greater:Er,greaterEqual:sl,ifft:Qf,imag:hb,image:Hs,inTopKAsync:iW,irfft:iS,isFinite:AR,isInf:DR,isNaN:_R,leakyRelu:db,less:Xf,lessEqual:Su,linalg:aA,linspace:p4,localResponseNormalization:OR,log:Wr,log1p:fb,logSigmoid:FR,logSoftmax:G2,logSumExp:pb,logicalAnd:fa,logicalNot:mb,logicalOr:H2,logicalXor:zR,losses:GG,lowerBound:R4,matMul:Ct,max:mi,maxPool:gb,maxPool3d:LR,maxPoolWithArgmax:O4,maximum:Za,mean:$n,meshgrid:L4,min:qf,minimum:jo,mirrorPad:q2,mod:PR,moments:yb,movingAverage:XU,mul:Q,multiRNNCell:W4,multinomial:H4,neg:fn,norm:pm,notEqual:Yc,oneHot:X2,ones:Sr,onesLike:Gr,op:J,outerProduct:Y4,pad:zi,pad1d:J4,pad2d:tV,pad3d:sV,pad4d:iV,pool:MR,pow:Ya,prelu:bb,print:tR,prod:BR,raggedGather:fV,raggedRange:mV,raggedTensorToTensor:yV,rand:bV,randomGamma:VV,randomNormal:Y2,randomStandardNormal:GV,randomUniform:Cu,randomUniformInt:qV,range:Qc,real:Kf,reciprocal:VR,relu:ba,relu6:Q2,reshape:ie,reverse:xi,reverse1d:eU,reverse2d:nU,reverse3d:rU,reverse4d:aU,rfft:kb,round:Z2,rsqrt:J2,scalar:Qe,scatterND:YU,searchSorted:j2,selu:eS,separableConv2d:tS,setdiff1dAsync:dU,sigmoid:Ur,sign:UR,signal:WG,sin:nS,sinh:sS,slice:ct,slice1d:wb,slice2d:rS,slice3d:Sb,slice4d:Yf,softmax:Cb,softplus:ad,spaceToBatchND:xb,sparse:HG,sparseToDense:JU,spectral:UG,split:Cr,sqrt:Ss,square:Yt,squaredDifference:aS,squeeze:Mt,stack:$r,step:od,stridedSlice:WR,string:jG,sub:Me,sum:je,tan:GR,tanh:du,tensor:Di,tensor1d:Wn,tensor2d:gi,tensor3d:HR,tensor4d:DU,tensor5d:_U,tensor6d:OU,tensorScatterUpdate:zU,tile:hi,topk:qR,transpose:Dt,truncatedNormal:lS,unique:XR,unsortedSegmentSum:uS,unstack:bi,upperBound:UU,variable:KR,where:Rs,whereAsync:YR,zeros:Dn,zerosLike:_t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m6=(n,e,t,s=Cs)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(R("a",n,e,t),R("b",n,e,t))];case"AddN":return[s.addN(R("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(R("a",n,e,t),R("b",n,e,t))];case"Mul":return[s.mul(R("a",n,e,t),R("b",n,e,t))];case"RealDiv":case"Div":return[s.div(R("a",n,e,t),R("b",n,e,t))];case"DivNoNan":return[s.divNoNan(R("a",n,e,t),R("b",n,e,t))];case"FloorDiv":return[s.floorDiv(R("a",n,e,t),R("b",n,e,t))];case"Sub":return[s.sub(R("a",n,e,t),R("b",n,e,t))];case"Minimum":return[s.minimum(R("a",n,e,t),R("b",n,e,t))];case"Maximum":return[s.maximum(R("a",n,e,t),R("b",n,e,t))];case"Pow":return[s.pow(R("a",n,e,t),R("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(R("a",n,e,t),R("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g6=(n,e,t,s=Cs)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(R("x",n,e,t))];case"Acos":return[s.acos(R("x",n,e,t))];case"Acosh":return[s.acosh(R("x",n,e,t))];case"Asin":return[s.asin(R("x",n,e,t))];case"Asinh":return[s.asinh(R("x",n,e,t))];case"Atan":return[s.atan(R("x",n,e,t))];case"Atan2":return[s.atan2(R("x",n,e,t),R("y",n,e,t))];case"Atanh":return[s.atanh(R("x",n,e,t))];case"Ceil":return[s.ceil(R("x",n,e,t))];case"Complex":return[s.complex(R("real",n,e,t),R("imag",n,e,t))];case"Cos":return[s.cos(R("x",n,e,t))];case"Cosh":return[s.cosh(R("x",n,e,t))];case"Elu":return[s.elu(R("x",n,e,t))];case"Erf":return[s.erf(R("x",n,e,t))];case"Exp":return[s.exp(R("x",n,e,t))];case"Expm1":return[s.expm1(R("x",n,e,t))];case"Floor":return[s.floor(R("x",n,e,t))];case"Log":return[s.log(R("x",n,e,t))];case"Log1p":return[s.log1p(R("x",n,e,t))];case"Imag":return[s.imag(R("x",n,e,t))];case"Neg":return[s.neg(R("x",n,e,t))];case"Reciprocal":return[s.reciprocal(R("x",n,e,t))];case"Real":return[s.real(R("x",n,e,t))];case"Relu":return[s.relu(R("x",n,e,t))];case"Round":return[s.round(R("x",n,e,t))];case"Selu":return[s.selu(R("x",n,e,t))];case"Sigmoid":return[s.sigmoid(R("x",n,e,t))];case"Sin":return[s.sin(R("x",n,e,t))];case"Sign":return[s.sign(R("x",n,e,t))];case"Sinh":return[s.sinh(R("x",n,e,t))];case"Softplus":return[s.softplus(R("x",n,e,t))];case"Sqrt":return[s.sqrt(R("x",n,e,t))];case"Square":return[s.square(R("x",n,e,t))];case"Tanh":return[s.tanh(R("x",n,e,t))];case"Tan":return[s.tan(R("x",n,e,t))];case"ClipByValue":return[s.clipByValue(R("x",n,e,t),R("clipValueMin",n,e,t),R("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(R("x",n,e,t))];case"Rsqrt":return[s.rsqrt(bs(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(R("x",n,e,t),R("alpha",n,e,t))];case"Prelu":return[s.prelu(R("x",n,e,t),R("alpha",n,e,t))];case"IsNan":return[s.isNaN(bs(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(bs(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(bs(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ui(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){B(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=e[s];B(r<0||i<0||r===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function mI(n){return!(typeof n=="number"||n.some(e=>e<0))}function Tf(n,e,t){let s=Ww(n,t);const r=!mI(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(i=>{s=Ww(i.shape,s)}),!mI(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Ww(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],i=e[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y6{constructor(e,t,s,r,i,a,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Qe(0),cs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ui(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,cs(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Di([],[0].concat(this.elementShape));const s=this.readMany(e);return ui(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),$r(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Di([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return ui(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),vn(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,bi(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,a=[];ce(()=>{t=ie(t,[1,s,i]);for(let l=0;l<e.length;++l){const d=[0,l===0?0:r[l-1],0],f=[1,e[l],i];a[l]=ie(ct(t,d,f),this.elementShape)}return a});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pu{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);ui(t,i.shape,"TensorList shape mismatch: "),cs(i)}),this.idTensor=Qe(0),this.maxNumElements=r,cs(this.idTensor)}copy(){return new pu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);ui(e,this.elementShape,"TensorList shape mismatch: ");const r=Tf(this.elementShape,this.tensors,e);return ce(()=>{const i=this.tensors.map(a=>ie(a,r));return $r(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Tf(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,ui(r.shape,e,"TensorList shape mismatch: "),ie(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ui(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");cs(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new pu([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ui(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Tf(this.elementShape,this.tensors,t);return ie(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ui(this.elementShape,t.shape,"TensorList shape mismatch: "),cs(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ui(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Tf(this.elementShape,this.tensors,s);return e.length===0?Di([],[0].concat(r)):ce(()=>{const i=e.map(a=>ie(this.tensors[a],r));return $r(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ui(this.elementShape,t,"TensorList shape mismatch: ");const s=Tf(this.elementShape,this.tensors,t);return this.size()===0?Di([],[0].concat(s)):ce(()=>{const r=this.tensors.map(i=>ie(i,s));return vn(r,0)})}}function x6(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);ui(r,e,"TensorList shape mismatch: ");const i=bi(n);return new pu(i,e,s)}function b6(n,e,t,s){return new pu([],n,e,s)}function v6(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new pu([],t,n.dtype,s),a=bi(n,0);return e.forEach((o,l)=>{i.setItem(o,a[l])}),i}function w6(n,e,t){let s=0;const r=e.map(d=>(s+=d,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),a=Ww(i,t),o=s===0?0:n.size/s,l=ce(()=>{const d=[];n=ie(n,[1,s,o]);for(let f=0;f<e.length;++f){const g=[0,f===0?0:r[f-1],0],x=[1,e[f],o];d[f]=ie(ct(n,g,x),a)}return n.dispose(),d}),c=new pu([],t,n.dtype,e.length);for(let d=0;d<l.length;d++)c.setItem(d,l[d]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S6=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=R("thenBranch",n,e,t),r=R("elseBranch",n,e,t),i=R("cond",n,e,t),a=R("args",n,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=R("body",n,e,t),r=R("cond",n,e,t),i=R("args",n,e,t),a=await t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),o=i.map(d=>d.id);let l=await a[0].data();a.forEach(d=>{!d.kept&&o.indexOf(d.id)===-1&&d.dispose()});let c=i;for(;l[0];){const d=c;c=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const f=c.map(g=>g.id);d.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()});const p=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await p[0].data(),p.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()})}return c}case"LoopCond":{const s=R("pred",n,e,t);return[Va(s)]}case"Switch":{const s=R("pred",n,e,t);let r=R("data",n,e,t);return r.kept||(r=Va(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>bs(r,e,t)!==void 0);if(s){const r=bs(s,e,t);return[Va(r)]}return}case"Enter":{const s=R("frameName",n,e,t),r=R("tensor",n,e,t);return t.enterFrame(s),[Va(r)]}case"Exit":{const s=R("tensor",n,e,t);return t.exitFrame(),[Va(s)]}case"NextIteration":{const s=R("tensor",n,e,t);return t.nextIteration(),[Va(s)]}case"TensorArrayV3":{const s=R("size",n,e,t),r=R("dtype",n,e,t),i=R("elementShape",n,e,t),a=R("dynamicSize",n,e,t),o=R("clearAfterRead",n,e,t),l=R("identicalElementShapes",n,e,t),c=R("name",n,e,t),d=new y6(c,r,s,i,l,a,o);return t.addTensorArray(d),[d.idTensor,Qe(1)]}case"TensorArrayWriteV3":{const s=R("tensorArrayId",n,e,t),r=R("index",n,e,t),i=R("tensor",n,e,t),a=t.getTensorArray(s.id);return a.write(r,i),[a.idTensor]}case"TensorArrayReadV3":{const s=R("tensorArrayId",n,e,t),r=R("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=R("tensorArrayId",n,e,t),r=R("indices",n,e,t),i=R("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=R("tensorArrayId",n,e,t),r=R("indices",n,e,t),i=R("tensor",n,e,t),a=t.getTensorArray(s.id);return a.scatter(r,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=R("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),i=R("dtype",n,e,t);return[r.concat(i)]}case"TensorArraySplitV3":{const s=R("tensorArrayId",n,e,t),r=R("tensor",n,e,t),i=R("lengths",n,e,t),a=t.getTensorArray(s.id);return a.split(i,r),[a.idTensor]}case"TensorArraySizeV3":{const s=R("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[Qe(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=R("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=R("tensorListId",n,e,t),r=R("index",n,e,t),i=R("tensor",n,e,t),a=t.getTensorList(s.id);return a.setItem(r,i),[a.idTensor]}case"TensorListGetItem":{const s=R("tensorListId",n,e,t),r=R("index",n,e,t),i=R("elementShape",n,e,t),a=R("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=R("indices",n,e,t),r=R("tensor",n,e,t),i=R("elementShape",n,e,t),a=R("numElements",n,e,t),o=v6(r,s,i,a);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=R("elementShape",n,e,t),r=R("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const a=R(i,n,e,t),o=n.op==="TensorListReserve"?-1:a,l=b6(s,r,a,o);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=R("tensorListId",n,e,t),r=R("indices",n,e,t),i=R("elementShape",n,e,t),a=R("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,a,i)]}case"TensorListStack":{const s=R("tensorListId",n,e,t),r=R("elementShape",n,e,t),i=R("elementDType",n,e,t),a=R("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,i,a)]}case"TensorListFromTensor":{const s=R("tensor",n,e,t),r=R("elementShape",n,e,t),i=R("elementDType",n,e,t),a=x6(s,r,i);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=R("tensorListId",n,e,t),r=t.getTensorList(s.id),i=R("dtype",n,e,t),a=R("elementShape",n,e,t);return[r.concat(i,a)]}case"TensorListPushBack":{const s=R("tensorListId",n,e,t),r=R("tensor",n,e,t),i=t.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=R("tensorListId",n,e,t),r=R("elementShape",n,e,t),i=R("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=R("tensor",n,e,t),r=R("elementShape",n,e,t),i=R("lengths",n,e,t),a=w6(s,i,r);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=R("tensorListId",n,e,t),r=t.getTensorList(s.id);return[Qe(r.size(),"int32")]}case"TensorListResize":{const s=R("tensorListId",n,e,t),r=R("size",n,e,t),a=t.getTensorList(s.id).resize(r);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gI(n,e,t){const[s,r]=R("fusedOps",n,e,t),i=s==="biasadd",a=!i,o=r==="prelu",l=s==="fusedbatchnorm",c=R("numArgs",n,e,t);if(i){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=R("strides",n,e,t),f=$y(n,e,t),p=R("dataFormat",n,e,t).toUpperCase(),g=R("dilations",n,e,t);let[x,b]=R("args",n,e,t);a&&(b=x,x=void 0);const v=R("leakyreluAlpha",n,e,t);return{stride:d,pad:f,dataFormat:p,dilations:g,biasArg:x,preluArg:b,activationFunc:r,leakyreluAlpha:v}}const C6=(n,e,t,s=Cs)=>{switch(n.op){case"Conv1D":{const r=R("stride",n,e,t),i=R("pad",n,e,t),a=R("dataFormat",n,e,t).toUpperCase(),o=R("dilation",n,e,t);return[s.conv1d(R("x",n,e,t),R("filter",n,e,t),r,i,a,o)]}case"Conv2D":{const r=R("strides",n,e,t),i=$y(n,e,t),a=R("dataFormat",n,e,t).toUpperCase(),o=R("dilations",n,e,t);return[s.conv2d(R("x",n,e,t),R("filter",n,e,t),[r[1],r[2]],i,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:l,preluArg:c,activationFunc:d,leakyreluAlpha:f}=gI(n,e,t);return[s.fused.conv2d({x:R("x",n,e,t),filter:R("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:d,preluActivationWeights:c,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:l,preluArg:c,activationFunc:d,leakyreluAlpha:f}=gI(n,e,t);return[s.fused.depthwiseConv2d({x:R("x",n,e,t),filter:R("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:d,preluActivationWeights:c,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=R("outputShape",n,e,t),i=R("strides",n,e,t),a=$y(n,e,t);return[s.conv2dTranspose(R("x",n,e,t),R("filter",n,e,t),r,[i[1],i[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=R("strides",n,e,t),i=$y(n,e,t),a=R("dilations",n,e,t),o=R("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(R("input",n,e,t),R("filter",n,e,t),[r[1],r[2]],i,o,[a[1],a[2]])]}case"Conv3D":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("dataFormat",n,e,t).toUpperCase(),o=R("dilations",n,e,t);return[s.conv3d(R("x",n,e,t),R("filter",n,e,t),[r[1],r[2],r[3]],i,a,[o[1],o[2],o[3]])]}case"AvgPool":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t);return[s.avgPool(R("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t);return[s.maxPool(R("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t),o=R("includeBatchInIndex",n,e,t),{result:l,indexes:c}=s.maxPoolWithArgmax(R("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i,o);return[l,c]}case"AvgPool3D":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t);return[s.avgPool3d(R("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t);return[s.maxPool3d(R("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("dilations",n,e,t),o=r[1],l=r[2],c=a[1],d=a[2];return[s.dilation2d(R("x",n,e,t),R("filter",n,e,t),[o,l],i,[c,d],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $6=(n,e,t,s=Cs)=>{switch(n.op){case"Fill":{const r=R("shape",n,e,t),i=R("dtype",n,e,t),a=R("value",n,e,t);return[s.fill(r,a,i)]}case"LinSpace":{const r=R("start",n,e,t),i=R("stop",n,e,t),a=R("num",n,e,t);return[s.linspace(r,i,a)]}case"Multinomial":{const r=R("logits",n,e,t),i=R("numSamples",n,e,t),a=R("seed",n,e,t);return[s.multinomial(r,i,a)]}case"OneHot":{const r=R("indices",n,e,t),i=R("depth",n,e,t),a=R("onValue",n,e,t),o=R("offValue",n,e,t),l=R("dtype",n,e,t);return[s.oneHot(r,i,a,o,l)]}case"Ones":return[s.ones(R("shape",n,e,t),R("dtype",n,e,t))];case"OnesLike":return[s.onesLike(R("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(R("shape",n,e,t),R("dtype",n,e,t),R("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(R("shape",n,e,t),R("minval",n,e,t),R("maxval",n,e,t),R("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(R("shape",n,e,t),R("minval",n,e,t),R("maxval",n,e,t),R("seed",n,e,t))];case"Range":{const r=R("start",n,e,t),i=R("stop",n,e,t),a=R("step",n,e,t);return[s.range(r,i,a,R("dtype",n,e,t))]}case"TruncatedNormal":{const r=R("shape",n,e,t),i=R("mean",n,e,t),a=R("stdDev",n,e,t),o=R("seed",n,e,t);return[s.truncatedNormal(r,i,a,R("dtype",n,e,t),o)]}case"Zeros":return[s.zeros(R("shape",n,e,t),R("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(R("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n,e,t){const s=R("boxes",n,e,t),r=R("scores",n,e,t),i=R("maxOutputSize",n,e,t),a=R("iouThreshold",n,e,t),o=R("scoreThreshold",n,e,t),l=R("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:a,scoreThreshold:o,softNmsSigma:l}}const k6=async(n,e,t,s,r=Cs)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:d}=Wv(n,e,t),f=await r.image.nonMaxSuppressionWithScoreAsync(i,a,o,l,c,d);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=Wv(n,e,t),d=R("padToMaxOutputSize",n,e,t),f=await r.image.nonMaxSuppressionPaddedAsync(i,a,o,l,c,d);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=Wv(n,e,t);return[await r.image.nonMaxSuppressionAsync(i,a,o,l,c)]}case"Where":{const i=r.cast(R("condition",n,e,t),"bool"),a=[await r.whereAsync(i)];return i.dispose(),a}case"ListDiff":return r.setdiff1dAsync(R("x",n,e,t),R("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N6=(n,e,t,s=Cs)=>{switch(n.op){case"LowerBound":{const r=R("sortedSequence",n,e,t),i=R("values",n,e,t);return[s.lowerBound(r,i)]}case"TopKV2":{const r=R("x",n,e,t),i=R("k",n,e,t),a=R("sorted",n,e,t),o=s.topk(r,i,a);return[o.values,o.indices]}case"UpperBound":{const r=R("sortedSequence",n,e,t),i=R("values",n,e,t);return[s.upperBound(r,i)]}case"Unique":{const r=R("x",n,e,t),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=R("x",n,e,t),i=R("axis",n,e,t),a=s.unique(r,i);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I6=(n,e,t,s=Cs)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=R("default",n,e,t);return[bs(n.name,e,t)||r];case"Placeholder":return[bs(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=R("x",n,e,t);return[Va(d)]}case"IdentityN":return R("x",n,e,t).map(d=>Va(d));case"Snapshot":const i=R("x",n,e,t);return[Va(i)];case"Shape":return[s.tensor1d(R("x",n,e,t).shape,"int32")];case"ShapeN":return R("x",n,e,t).map(d=>s.tensor1d(d.shape));case"Size":return[s.scalar(R("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(R("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=R("x",n,e,t),o=R("data",n,e,t),l=R("message",n,e,t),c=R("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let d=0;d<o.length;d++)console.log(Array.prototype.slice.call(o[d].dataSync()).slice(0,c));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T6{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Qe(0),this.tensorMap=new Map,cs(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Qe(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ce(()=>{const r=bi(t),i=s.length,a=r.length;B(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let o=0;o<i;o++){const l=s[o],c=r[o];cs(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return ce(()=>{const r=[];for(let i=0;i<s.length;i++){const a=s[i],o=this.findWithDefault(a,t);r.push(o)}return $r(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E6=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const i=R("keyDType",n,e,t),a=R("valueDType",n,e,t),o=new T6(i,a);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=R("tableHandle",n,e,t,s),i=R("keys",n,e,t),a=R("values",n,e,t);return[await s.getHashTableById(r.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=R("tableHandle",n,e,t,s),i=R("keys",n,e,t),a=R("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=R("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R6=(n,e,t,s=Cs)=>{switch(n.op){case"ResizeBilinear":{const r=R("images",n,e,t),i=R("size",n,e,t),a=R("alignCorners",n,e,t),o=R("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[i[0],i[1]],a,o)]}case"ResizeNearestNeighbor":{const r=R("images",n,e,t),i=R("size",n,e,t),a=R("alignCorners",n,e,t),o=R("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],a,o)]}case"CropAndResize":{const r=R("image",n,e,t),i=R("boxes",n,e,t),a=R("boxInd",n,e,t),o=R("cropSize",n,e,t),l=R("method",n,e,t),c=R("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,i,a,o,l,c)]}case"ImageProjectiveTransformV3":{const r=R("images",n,e,t),i=R("transforms",n,e,t),a=R("outputShape",n,e,t),o=R("fillValue",n,e,t),l=R("interpolation",n,e,t),c=R("fillMode",n,e,t);return[s.image.transform(r,i,l.toLowerCase(),c.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A6=(n,e,t,s=Cs)=>{switch(n.op){case"Equal":return[s.equal(R("a",n,e,t),R("b",n,e,t))];case"NotEqual":return[s.notEqual(R("a",n,e,t),R("b",n,e,t))];case"Greater":return[s.greater(R("a",n,e,t),R("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(R("a",n,e,t),R("b",n,e,t))];case"Less":return[s.less(R("a",n,e,t),R("b",n,e,t))];case"LessEqual":return[s.lessEqual(R("a",n,e,t),R("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(R("a",n,e,t),R("b",n,e,t))];case"LogicalNot":return[s.logicalNot(R("a",n,e,t))];case"LogicalOr":return[s.logicalOr(R("a",n,e,t),R("b",n,e,t))];case"Select":case"SelectV2":return[s.where(R("condition",n,e,t),R("a",n,e,t),R("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(R("a",n,e,t),R("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D6=(n,e,t,s=Cs)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(R("a",n,e,t),R("b",n,e,t),R("transposeA",n,e,t),R("transposeB",n,e,t))];case"Einsum":return[s.einsum(R("equation",n,e,t),...R("tensors",n,e,t))];case"Transpose":return[s.transpose(R("x",n,e,t),R("perm",n,e,t))];case"_FusedMatMul":const[r,i]=R("fusedOps",n,e,t),a=r==="biasadd",o=i==="prelu",l=R("numArgs",n,e,t),c=R("leakyreluAlpha",n,e,t);if(a){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,f]=R("args",n,e,t);return[s.fused.matMul({a:R("a",n,e,t),b:R("b",n,e,t),transposeA:R("transposeA",n,e,t),transposeB:R("transposeB",n,e,t),bias:d,activation:i,preluActivationWeights:f,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(R("a",n,e,t),R("numLower",n,e,t),R("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _6=(n,e,t,s=Cs)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(R("x",n,e,t),R("axis",n,e,t),R("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(R("x",n,e,t),R("mean",n,e,t),R("variance",n,e,t),R("offset",n,e,t),R("scale",n,e,t),R("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(R("x",n,e,t),R("mean",n,e,t),R("variance",n,e,t),R("offset",n,e,t),R("scale",n,e,t),R("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(R("x",n,e,t),R("radius",n,e,t),R("bias",n,e,t),R("alpha",n,e,t),R("beta",n,e,t))];case"Softmax":return[s.softmax(R("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(R("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O6=(n,e,t,s=Cs)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=s.raggedGather(R("paramsNestedSplits",n,e,t),R("paramsDenseValues",n,e,t),R("indices",n,e,t),R("outputRaggedRank",n,e,t));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=s.raggedRange(R("starts",n,e,t),R("limits",n,e,t),R("splits",n,e,t));return[r,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(R("shape",n,e,t),R("values",n,e,t),R("defaultValue",n,e,t),R("rowPartitionTensors",n,e,t),R("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F6=(n,e,t,s=Cs)=>{switch(n.op){case"Max":{const o=R("axis",n,e,t),l=R("keepDims",n,e,t);return[s.max(R("x",n,e,t),o,l)]}case"Mean":{const o=R("axis",n,e,t),l=R("keepDims",n,e,t);return[s.mean(R("x",n,e,t),o,l)]}case"Min":{const o=R("axis",n,e,t),l=R("keepDims",n,e,t);return[s.min(R("x",n,e,t),o,l)]}case"Sum":{const o=R("axis",n,e,t),l=R("keepDims",n,e,t);return[s.sum(R("x",n,e,t),o,l)]}case"All":{const o=R("axis",n,e,t),l=R("keepDims",n,e,t);return[s.all(R("x",n,e,t),o,l)]}case"Any":{const o=R("axis",n,e,t),l=R("keepDims",n,e,t);return[s.any(R("x",n,e,t),o,l)]}case"ArgMax":{const o=R("axis",n,e,t);return[s.argMax(R("x",n,e,t),o)]}case"ArgMin":{const o=R("axis",n,e,t);return[s.argMin(R("x",n,e,t),o)]}case"Prod":{const o=R("axis",n,e,t),l=R("keepDims",n,e,t);return[s.prod(R("x",n,e,t),o,l)]}case"Cumprod":{const o=R("axis",n,e,t),l=R("exclusive",n,e,t),c=R("reverse",n,e,t);return[s.cumprod(R("x",n,e,t),o,l,c)]}case"Cumsum":{const o=R("axis",n,e,t),l=R("exclusive",n,e,t),c=R("reverse",n,e,t);return[s.cumsum(R("x",n,e,t),o,l,c)]}case"Bincount":const r=R("x",n,e,t),i=R("weights",n,e,t),a=R("size",n,e,t);return[s.bincount(r,i,a)];case"DenseBincount":{const o=R("x",n,e,t),l=R("weights",n,e,t),c=R("size",n,e,t),d=R("binaryOutput",n,e,t);return[s.denseBincount(o,l,c,d)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z6=(n,e,t,s=Cs)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=R("n",n,e,t),i=R("axis",n,e,t);let a=R("tensors",n,e,t);return a=a.slice(0,r),[s.concat(a,i)]}case"Gather":{const r=R("x",n,e,t),i=R("indices",n,e,t);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=R("axis",n,e,t),i=R("batchDims",n,e,t),a=R("x",n,e,t),o=R("indices",n,e,t);return[s.gather(a,s.cast(o,"int32"),r,i)]}case"Reverse":{const r=R("dims",n,e,t),i=[];for(let o=0;o<r.length;o++)r[o]&&i.push(o);const a=R("x",n,e,t);return[s.reverse(a,i)]}case"ReverseV2":{const r=R("axis",n,e,t),i=R("x",n,e,t);return[s.reverse(i,r)]}case"Slice":{const r=R("begin",n,e,t),i=R("size",n,e,t);return[s.slice(R("x",n,e,t),r,i)]}case"StridedSlice":{const r=R("begin",n,e,t),i=R("end",n,e,t),a=R("strides",n,e,t),o=R("beginMask",n,e,t),l=R("endMask",n,e,t),c=R("ellipsisMask",n,e,t),d=R("newAxisMask",n,e,t),f=R("shrinkAxisMask",n,e,t),p=R("x",n,e,t);return[s.stridedSlice(p,r,i,a,o,l,c,d,f)]}case"Pack":return ce(()=>{const r=R("axis",n,e,t),i=R("tensors",n,e,t),a=i[0].shape,o=s.squeeze(i[0]).shape,l=i.map(c=>{const d=yt(c.shape,a);if(!d&&!yt(s.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return d?c:s.reshape(c,a)});return[s.stack(l,r)]});case"Unpack":{const r=R("axis",n,e,t),i=R("tensor",n,e,t);return s.unstack(i,r)}case"Tile":{const r=R("reps",n,e,t);return[s.tile(R("x",n,e,t),r)]}case"Split":case"SplitV":{const r=R("axis",n,e,t),i=R("numOrSizeSplits",n,e,t),a=R("x",n,e,t);return s.split(a,i,r)}case"ScatterNd":{const r=R("indices",n,e,t),i=R("values",n,e,t),a=R("shape",n,e,t);return[s.scatterND(r,i,a)]}case"GatherNd":{const r=R("x",n,e,t),i=R("indices",n,e,t);return[s.gatherND(r,i)]}case"SparseToDense":{const r=R("sparseIndices",n,e,t),i=R("outputShape",n,e,t),a=R("sparseValues",n,e,t),o=R("defaultValue",n,e,t);return[s.sparseToDense(r,a,i,a.dtype===o.dtype?o:s.cast(o,a.dtype))]}case"TensorScatterUpdate":{const r=R("indices",n,e,t),i=R("values",n,e,t),a=R("tensor",n,e,t);return[s.tensorScatterUpdate(a,r,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L6=(n,e,t,s=Cs)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:a,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(R("indices",n,e,t),R("values",n,e,t),R("denseShape",n,e,t),R("defaultValue",n,e,t));return[r,i,a,o]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape(R("inputIndices",n,e,t),R("inputShape",n,e,t),R("newShape",n,e,t));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(R("data",n,e,t),R("indices",n,e,t),R("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(R("data",n,e,t),R("indices",n,e,t),R("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P6=(n,e,t,s=Cs)=>{switch(n.op){case"FFT":return[s.fft(R("x",n,e,t))];case"IFFT":return[s.ifft(R("x",n,e,t))];case"RFFT":return[s.rfft(R("x",n,e,t))];case"IRFFT":return[s.irfft(R("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M6=(n,e,t,s=Cs)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(R("input",n,e,t),R("pattern",n,e,t),R("rewrite",n,e,t),R("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams(R("data",n,e,t),R("dataSplits",n,e,t),R("separator",n,e,t),R("nGramWidths",n,e,t),R("leftPad",n,e,t),R("rightPad",n,e,t),R("padWidth",n,e,t),R("preserveShortSequences",n,e,t));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:a}=s.string.stringSplit(R("input",n,e,t),R("delimiter",n,e,t),R("skipEmpty",n,e,t));return[r,i,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(R("input",n,e,t),R("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B6=(n,e,t,s=Cs)=>{switch(n.op){case"Cast":return[s.cast(R("x",n,e,t),R("dtype",n,e,t))];case"ExpandDims":{const r=R("axis",n,e,t);return[s.expandDims(R("x",n,e,t),r)]}case"Squeeze":{const r=R("axis",n,e,t);return[s.squeeze(R("x",n,e,t),r)]}case"Reshape":return[s.reshape(R("x",n,e,t),R("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(R("x",n,e,t),R("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(R("x",n,e,t),R("padding",n,e,t),R("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(R("x",n,e,t),R("padding",n,e,t),R("constantValue",n,e,t))];case"SpaceToBatchND":{const r=R("blockShape",n,e,t),i=R("paddings",n,e,t);return[s.spaceToBatchND(R("x",n,e,t),r,i)]}case"BatchToSpaceND":{const r=R("blockShape",n,e,t),i=R("crops",n,e,t);return[s.batchToSpaceND(R("x",n,e,t),r,i)]}case"DepthToSpace":{const r=R("blockSize",n,e,t),i=R("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(R("x",n,e,t),r,i)]}case"BroadcastTo":return[s.broadcastTo(R("x",n,e,t),R("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(R("s0",n,e,t),R("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yI(n,e,t,s,r=ce){const i=((a,o,l)=>{switch(a.category){case"arithmetic":return r(()=>m6(a,o,l));case"basic_math":return r(()=>g6(a,o,l));case"control":return S6(a,o,l);case"convolution":return r(()=>C6(a,o,l));case"creation":return r(()=>$6(a,o,l));case"dynamic":return k6(a,o,l);case"evaluation":return r(()=>N6(a,o,l));case"image":return r(()=>R6(a,o,l));case"graph":return r(()=>I6(a,o,l));case"logical":return r(()=>A6(a,o,l));case"matrices":return r(()=>D6(a,o,l));case"normalization":return r(()=>_6(a,o,l));case"ragged":return r(()=>O6(a,o,l));case"reduction":return r(()=>F6(a,o,l));case"slice_join":return r(()=>z6(a,o,l));case"sparse":return r(()=>L6(a,o,l));case"spectral":return r(()=>P6(a,o,l));case"string":return r(()=>M6(a,o,l));case"transformation":return r(()=>B6(a,o,l));case"hash_table":return E6(a,o,l,s);case"custom":const c=ZA(a.op);if(c&&c.customExecutor)return c.customExecutor(new p6(a,o,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return iu(i)?i.then(a=>[].concat(a)):[].concat(i)}class xI{constructor(e={},t={},s={},r={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bI(n,e,t,s){const r=new Set,i=[];let a=null,o=null;const l=new Set,c=new Set(Object.keys(n).map(p=>vr(p)[0]));s=s||[];const d=new Set(s.map(p=>vr(p.name)[0])),f=[...e];for(;f.length>0;){const p=f.pop();if((jl(p)||X6(p)||K6(p))&&a==null&&(a=p,o=a.children.map(g=>g.name).filter(g=>r.has(g))),r.add(p.name),t[p.name]==null&&!c.has(p.name)&&!d.has(p.name)){if(p.inputs.length===0){i.push(p.name);continue}p.inputs.forEach(g=>{l.has(g.name)||(l.add(g.name),f.push(g))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:i,dynamicNode:a,syncInputs:o}}function V6(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(v=>vr(v)[0]).map(v=>n.nodes[v]),i=n.initNodes||[],a=v=>t.has(typeof v=="string"?v:v.name);function o(v){return[...new Map(v.map(w=>[w.name,w])).values()]}const l=o([...r,...n.weights,...i]).filter(a),c=o([...l,...Object.values(n.nodes)]).filter(a),d=new Map(c.map(v=>[v.name,v])),f={};for(const v of c){f[v.name]=f[v.name]||0;for(const w of v.children)a(w)||(f[w.name]=Number.POSITIVE_INFINITY),f[w.name]=(f[w.name]||0)+1}const p=Object.entries(f).filter(([,v])=>v===0).map(([v])=>v),g=[...p];for(;p.length>0;){const v=p.pop(),w=d.get(v);for(const $ of w.children.filter(a))--f[$.name]===0&&(g.push($.name),p.push($.name))}const x=g.map(v=>d.get(v)),b=U6(x,l);return W6(b,l),b}function U6(n,e){const t=new Map(n.map(a=>[a.name,a])),s=e.map(a=>a.name),r=new Set(s);for(;s.length>0;){const a=s.pop(),o=t.get(a);for(const l of o.children)!t.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return n.filter(a=>r.has(a.name))}class ey extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function W6(n,e){const t=new Map(n.map((o,l)=>[o.name,l])),s=new Set(e.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),i=new Set(n.map(o=>o.name)),a=o=>i.has(typeof o=="string"?o:o.name);for(const o of n){for(const l of o.children.filter(a)){if(!t.has(l.name))throw new ey(`Child ${l.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(l.name))throw new ey(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(const l of o.inputs){if(!t.has(l.name))throw new ey(`Input ${l.name} of node ${o.name} is unreachable.`);if(t.get(l.name)>t.get(o.name))throw new ey(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function G6(n){const e=new Map(n.map((o,l)=>[o.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((o,l)=>jl(o)?t:l),r=o=>{const l=s[e.get(o.name)];return l??-1},i=n.map((o,l)=>o.children.map(r).reduce((c,d)=>Math.max(c,d),s[l])),a=new Map;for(let o=0;o<n.length;++o){const l=i[o];if(l===t)continue;const c=n[o],d=n[l];a.has(d.name)||a.set(d.name,[]),a.get(d.name).push(c)}return a}const H6=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),j6=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),q6=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function jl(n){return H6.has(n.op)}function X6(n){return j6.has(n.op)}function K6(n){return q6.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Py{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Py(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),r=t.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=bI(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:a}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const c=t.map(f=>f.name),d=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${d}]. Missing the following inputs: [${r}]`)}const o=V6(this.graph,s),l=G6(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return cs(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(p=>this.graph.nodes[vr(p)[0]]),i=t.map(p=>vr(p)[0]),a=new Set(i);let o=i.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(r,o);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,o),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=fe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const d={},f={};return ce(()=>{const p=new xI(this.weightMap,d,f,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(w=>{const[$,I]=vr(w,p),N=[];N[I]=e[w],g[$]=N,this.keepIntermediateTensors&&(this.clonedTensorsMap[$]=this.cloneTensorList(N))});const x=this.getFrozenTensorIds(g),{orderedNodes:b,nodeLiveUntilMap:v}=c;for(const w of b){if(g[w.name])continue;const $=yI(w,g,p,this._resourceManager);if(iu($))throw new Error(`The execution of the op '${w.op}' returned a promise. Please use model.executeAsync() instead.`);g[w.name]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[w.name]=this.cloneTensorList($)),this.checkTensorForDisposalWithNodeLiveUntilInfo(w,g,p,x,a,v.get(w.name))}return this.parent==null&&p.dispose(x),t.map(w=>bs(w,g,p))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,i,a,o){if(!(jl(t)||a.has(e))){for(const l of s[e])l!=null&&(o[l.id]=(o[l.id]||0)+t.children.length);for(const l of t.inputs){if(jl(l))continue;const c=dI(l.name,s,r);if(c!=null)for(const d of c){if(!d||d.kept||i.has(d.id))continue;const f=o[d.id];f===1?(d.dispose(),delete o[d.id]):f!=null&&o[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,i,a){function o(l){return jl(l)||i.has(l.name)}if(!(jl(e)||a==null))for(const l of a){if(o(l))continue;const c=dI(l.name,t,s);for(const d of c)!d||d.kept||r.has(d.id)||d.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},i={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=fe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const a=new xI(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,a,t,s),l=t.map(p=>bs(p,o,a)),c=l.map(p=>p.id),d=Object.keys(e).map(p=>e[p].id),f=new Set([...c,...d,...this.weightIds]);return Object.values(o).forEach(p=>{p.forEach(g=>{g&&!g.isDisposed&&!f.has(g.id)&&g.dispose()})}),this.parent==null&&a.dispose(f),l}async executeFunctionAsync(e,t,s){const r=e.reduce((i,a,o)=>(i[this.inputs[o].name]=a,i),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const i=Object.keys(e),a=i.map(N=>this.graph.nodes[vr(N)[0]]),o=s.map(N=>vr(N)[0]),l=new Set(o);let c=o.map(N=>this.graph.nodes[N]);c.length===0&&(c=this._outputs);const{usedNodes:d,missingInputs:f,dynamicNode:p,syncInputs:g}=bI(e,c,this.weightMap,this._initNodes),x=[...a,...this.graph.weights,...this._initNodes||[]].map(N=>({node:N,contexts:t.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(N=>{const[E,D]=vr(N),O=[];O[D]=e[N],b[E]=O});const v={},w=this.getFrozenTensorIds(b),$={};for(;x.length>0;){const N=this.processStack(a,x,t,b,$,w,l,v,d);await Promise.all(N)}p==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const I=c.filter(N=>!jl(N)&&!bs(N.name,b,t)).map(N=>N.name);if(I.length>0){let N="";throw p!=null&&(N=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${i}]. Consider providing the following inputs: [${f}]. ${N}`)}return b}processStack(e,t,s,r,i,a,o,l,c){const d=[];for(;t.length>0;){const f=t.pop();s.currentContext=f.contexts;let p="";if(f.node.op==="Enter"&&R("isConstant",f.node,r,s)&&([p]=Ba(f.node.name,s)),r[f.node.name]==null){const g=yI(f.node,r,s,this._resourceManager);p||([p]=Ba(f.node.name,s));const x=s.currentContext;iu(g)?d.push(g.then(b=>(r[p]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(b)),s.currentContext=x,this.checkTensorForDisposal(p,f.node,r,s,a,o,l),this.processChildNodes(f.node,t,s,r,i,c),b))):(r[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),this.checkTensorForDisposal(p,f.node,r,s,a,o,l),this.processChildNodes(f.node,t,s,r,i,c))}else this.processChildNodes(f.node,t,s,r,i,c)}return d}processChildNodes(e,t,s,r,i,a){e.children.forEach(o=>{const[l]=Ba(o.name,s);i[l]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!bs(c,r,s))&&(i[l]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(c=>!!bs(c,r,s))&&(i[l]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=vr(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const a=i.attrParams.shape.value,o=a.length===s.shape.length&&s.shape.every((l,c)=>a[c]===-1||a[c]===l);B(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&B(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const i in e){const a=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[i];a!=null?r[a.name]=e[i]:r[i]=e[i]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=vr(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const i=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=vr(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class Y6{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q6="?tfjs-format=file",Z6="model.json";class J6{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=xA){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new Y6}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return iu(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await WE(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Py(fI.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=fI.Instance.transformGraph(e.modelInitializer);this.initializer=new Py(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Gt?[e]:e,s={};return t.forEach((r,i)=>s[this.structuredOutputKeys[i]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof Gt)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const a in i){const o=i[a];o.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,a)=>{var o,l,c;const d=(c=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[a])===null||c===void 0?void 0:c.resourceId;return d!=null?i[a]=this.resourceIdToCapturedInput[d]:i[a]=e[r++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const i=s[r],a=t[i];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&et(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Zc(n,e={},t=xA){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=ej(n));const s=new J6(n,e,t);return await s.load(),s}function ej(n){return n.endsWith("/")||(n=n+"/"),`${n}${Z6}${Q6}`}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qr=fe();qr.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);qr.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);qr.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);qr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);qr.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);qr.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);qr.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);qr.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);qr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);qr.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);qr.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);qr.registerFlag("WEBGPU_PRINT_SHADER",()=>"");qr.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tj{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nj{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,s=!1,r=!0){let i;const a=vI(e,t);return r?(this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).length>0?(i=this.freeBuffers.get(a).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(a)||this.usedBuffers.set(a,[]),this.usedBuffers.get(a).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const s=e.size,r=e.usage,i=vI(s,r),a=this.usedBuffers.get(i),o=a.indexOf(e);if(o<0)throw new Error("Cannot find the buffer in buffer manager");a[o]=a[a.length-1],a.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,t?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function vI(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sj=class{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,s,r){const i=SI(s),a=e*t*i,o=wI(e,t,s,r);if(this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.usedTextures.has(o)||this.usedTextures.set(o,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(o).length>0){this.numFreeTextures--;const c=this.freeTextures.get(o).shift();return this.usedTextures.get(o).push(c),c}this.numBytesAllocated+=a;const l=this.device.createTexture({size:[e,t],format:s,usage:r});return this.usedTextures.get(o).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,s=e.height,r=e.format,i=e.usage,a=wI(t,s,r,i);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;const o=this.usedTextures.get(a),l=o.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(l,1);const c=SI(r),d=t*s*c;this.numBytesUsed-=d}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function wI(n,e,t,s){return`${n}_${e}_${t}_${s}`}function SI(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rj(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,s="xyzwuv",r=n.map(a=>`${e}.${s[a]}`),i=new Array(t-1);i[t-2]=r[t-1];for(let a=t-3;a>=0;--a)i[a]=`(${i[a+1]} * ${r[a+1]})`;return i}const il=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Jc;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(Jc||(Jc={}));const ij=(n,e,t,s,r)=>{const i={dtype:s.dtype,shape:s.shape},a=oj(t,i,e),o=n.createShaderModule({code:a,label:e.constructor.name});let l=fe().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(d=>e.shaderKey.toLowerCase().includes(d)))&&(console.group(e.shaderKey),console.debug(a),console.groupEnd())}return r?n.createComputePipelineAsync({compute:{module:o,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},xt=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function _n(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function qa(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function _e(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function CI(n,e){let t;return t=`
     ${aj(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function aj(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function oj(n,e,t){const s=[],r=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${t3(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const x=t.pixelsOpType===Jc.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${ql(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${ql(n[0].dtype,t.outputComponent)}>;`,b=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${b},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${x}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const v=kI(t);return[$I,s.join(`
`),ky(e.shape),t.getUserCode(),CI(v,t)].join(`
`)}let i,a,o="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((x,b)=>{const v=_n(n[b].shape.length);o+=`${x.charAt(0).toLowerCase()+x.slice(1)}Shape : ${v}, `,i=n[b].shape.length-1,a=_n(i),o+=`${x.charAt(0).toLowerCase()+x.slice(1)}ShapeStrides: ${a}, `});const l=_n(e.shape.length);o+=`outShape : ${l}, `,i=e.shape.length-1,a=_n(i),o+=`
         outShapeStrides: ${a}, `,t.size&&(o+="size : i32, "),t.uniforms&&(o+=t.uniforms),o+="};",o=gj(o),s.push(o),t.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${ql(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((x,b)=>{s.push(`
      @group(0) @binding(${1+b}) var<storage, read> ${x}: array<${t.variableComponents?ql(n[b].dtype,t.variableComponents[b]):ql(n[b].dtype,t.outputComponent)}>;
        `)}),o!==""&&s.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=fj(e.shape,t.dispatchLayout),d=[$I,s.join(`
`)+uj,ky(e.shape),c,pj(e.shape.length)];t.atomic||d.push(mj(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((x,b)=>{d.push(`${ky(n[b].shape,x)}`)});const f=n.map((x,b)=>dj(x,e.shape,t.variableComponents?t.variableComponents[b]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);d.push(f),d.push(t.getUserCode());const p=kI(t);return d.push(CI(p,t)),d.join(`
`)}function lj(n,e,t){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const r=[],i=[];e.forEach(d=>{r.push(d.shape),i.push(d.dtype)}),r.push(t.shape),i.push(t.dtype);const a=e.map(d=>Ho(d.shape,t.shape)),o=e.map(d=>yt(d.shape,t.shape)).join("_"),l=a.map(d=>d.join("_")).join(";"),c=t3(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+r.map(d=>d.length).join(",")+i.join(",")+n.variableNames.join(",")+l+o+c,s}const $I=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,uj=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function ky(n,e=""){const t=n.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const i=Ye(n),a=_n(t),o=[];for(let c=0;c<t;c++)o.push(`d${c}`);if(i.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+i.map((c,d)=>{const f=`let ${o[d]} = index2 / uniforms.${r}.${qa(d)}`,p=d===i.length-1?`let ${o[d+1]} = index2 - ${o[d]} * uniforms.${r}.${qa(d)}`:`index2 = index2 - ${o[d]} * uniforms.${r}.${qa(d)}`;return`${f}; ${p};`}).join(""),`
    fn ${s}(index : i32) -> ${a} {
      ${l}
      return ${a}(${o.join(",")});
    }
  `}function cj(n,e){const t=n.name,s=n.shape.length,r=_n(s),i="get"+t.charAt(0).toUpperCase()+t.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,s),o=a.map(d=>`${d} : i32`).join(", ");if(s<1)return`
      fn ${i}() -> ${xt(e)} {
        return ${xt(e)}(${t}[0]);
      }
    `;const l=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let c=`${s}D`;return s===0&&(c="1D"),`
    fn ${i}(${o}) -> ${xt(e)} {
      return ${xt(e)}(${t}[getIndexFromCoords${c}(${r}(${a.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function hj(n,e,t,s){const r=n.name,i=r.charAt(0).toUpperCase()+r.slice(1),a="get"+i+"ByOutput",o=n.shape.length,l=e.length,c=_n(l);if(yt(n.shape,e)&&s)return`
    fn ${a}Index(globalIndex : i32) -> ${xt(t)} {
      return ${xt(t)}(${r}[globalIndex]);
    }

    fn ${a}Coords(coords : ${c}) -> ${xt(t)} {
      return ${xt(t)}(${r}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const d=Ho(n.shape,e),f=l-o;let p="";if(o===0)return`
    fn ${a}Index(globalIndex : i32) -> ${xt(t)}{
      return get${i}();
    }

    fn ${a}Coords(coords : ${c}) -> ${xt(t)}{
      return get${i}();
    }
  `;l<2&&d.length>=1?p="coords = 0;":p=d.map(v=>`coords.${qa(v+f)} = 0;`).join(`
`);let g="";if(l<2&&o>0)g="coords";else if(l>1){const v=_n(o),w=n.shape.map(($,I)=>`coords.${qa(I+f)}`).join(", ");g=`${v}(${w})`}else g="coords";const x=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,b=`${o}D`;return`
  fn ${a}Index(globalIndex : i32) -> ${xt(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${p}
    return ${xt(t)}(${r}[getIndexFromCoords${b}(${g}, ${x})${t===1?"":` / ${t}`}]);
  }

  fn ${a}Coords(coordsIn : ${c}) -> ${xt(t)} {
    var coords = coordsIn;
    ${p}
    return ${xt(t)}(${r}[getIndexFromCoords${b}(${g}, ${x})${t===1?"":` / ${t}`}]);
  }
`}function dj(n,e,t,s){let r=cj(n,t);return n.shape.length<=e.length&&(r+=hj(n,e,t,s)),r}function fj(n,e){const{x:t,y:s=[],z:r=[]}=e,i=n.length,a=t.length+s.length+r.length;if(a!==i)return"";if(t.length===i)return`fn getOutputCoords() -> ${_n(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let o="";const l=[t,s,r];for(let p=0;p<l.length;p++){const g=l[p];if(g.length!==0)if(g.length===1)o+=`let d${g[0]} = i32(globalId[${p}]);`;else{const x=rj(g,"uniforms.outShape");o+=`var index${p} = i32(globalId[${p}]);`;for(let b=0;b<x.length;b++)o+=`let d${g[b]} = index${p} / ${x[b]};`,b===x.length-1?o+=`let d${g[b+1]} = index${p} - d${g[b]} * ${x[b]};`:o+=`index${p} = index${p} - d${g[b]} * ${x[b]};`}}const c=[];for(let p=0;p<a;p++)c.push(`d${p}`);const d=_n(a);let f=`fn getOutputCoords() -> ${d} {
  ${o}
`;return c.length===0?f+=`return ${d}(0); }`:f+=`return ${d}(${c.join(",")}); }`,f}function pj(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:B(!1,()=>`Unsupported ${n}D shape`);break}return e}function t3(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function ql(n,e=1){if(n==="float32")return xt(e,"f32");if(n==="int32"||n==="bool")return xt(e,"i32");throw new Error(`type ${n} is not supported.`)}function mj(n,e,t){const s=n.length,r=ql(e,t);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${xt(t)}) {
      result[flatIndex] = ${r}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${xt(t,"i32")}) {
      result[flatIndex] = ${r}(value);
    }
    `;if(s>=2){const a=["d0","d1","d2","d3","d4","d5"].slice(0,s),o=_n(s);i+=`
      fn setOutputAtCoords(${a.map(l=>`${l} : i32`).join(", ")}, value : ${xt(t)}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${a.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${a.map(l=>`${l} : i32`).join(", ")}, value : ${xt(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return i}function gj(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,s=>"@align(16) "+s);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(s,r,i)=>`vec${r}, @align(16) ${i}`),n}function kI(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eu=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function Oe(n,e,t=[1,1,1],s=[1,1,1]){const[r,i,a]=[Math.ceil(eu(n.x.map(o=>e[o]))/(t[0]*s[0])),n.y?Math.ceil(eu(n.y.map(o=>e[o]))/(t[1]*s[1])):1,n.z?Math.ceil(eu(n.z.map(o=>e[o]))/(t[2]*s[2])):1];return[r,i,a]}function yj(n,e,t,s=!1){const r=[8,8,1],i=[4,4,1];return s||(n<=8&&(i[1]=1),e<=16&&t<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:i}}function n3(n,e,t=!1){if(t)return[8,8,1];const s=eu(n.x.map(i=>e[i])),r=eu(n.y.map(i=>e[i]));return s<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function s3(n,e,t=!1){if(t)return[4,4,1];const s=eu(n.x.map(i=>e[i])),r=eu(n.y.map(i=>e[i]));return s<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function Be(n){return{x:n.map((e,t)=>t)}}function NI(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function r3(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function i3(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&B(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var ra;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(ra||(ra={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xj=fe().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),bj=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,r=e.dispatch;if(r.every(a=>a<=t))return r;B(r[0]>t&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(r[0]));return i>t?(i=Math.ceil(Math.cbrt(r[0])),B(i<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class cd extends lx{nextDataId(){return cd.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!r3())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new tj(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new nj(this.device),this.textureManager=new sj(this.device),this.tensorMap=new f2(this,Vs()),fe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return t?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:s,shape:t,values:e,refCount:1}),r}move(e,t,s,r,i){if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:s,values:t,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,s)=>{this.pipelineCache[t]=e[s]})}async getBufferData(e){if(fe().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,s=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),fe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(B(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const s=this.tensorMap.get(e);return s.values=t,s.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:r}=t;if(s!=null||t.dtype==="string")return s;if(t.dtype==="complex64"){const b=this.readSync(r.real.dataId),v=this.readSync(r.imag.dataId),w=py(Li(b,v).buffer,"float32");return this.convertAndCacheOnCPU(e,w),w}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],a=t.resource,o=a.size;B(o%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=o/4,c=new ArrayBuffer(o),d=256,f=256,p=i.map(b=>new OffscreenCanvas(d,f)),g=new OffscreenCanvas(d,f);this.endComputePassEncoder(),p.map((b,v)=>{const w=b.getContext("webgpu");return w.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[v]}),w.getCurrentTexture()}).map((b,v)=>{const w=d*4,$=(L,z,P)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:a,bytesPerRow:w,offset:P},{texture:b},{width:L,height:z}),this.submitQueue();const _=g.getContext("2d",{willReadFrequently:!0});_.clearRect(0,0,L,z),_.drawImage(p[v],0,0);const H=_.getImageData(0,0,L,z).data,q=i[v],ee=new Uint8ClampedArray(c,P,L*z*4);for(let Y=0;Y<ee.length;Y+=4)if(q==="premultiplied")ee[Y+3]=H[Y+3];else{const G=H[Y];ee[Y]=H[Y+2],ee[Y+1]=H[Y+1],ee[Y+2]=G}},I=Math.floor(l/(d*f));let N=d,E=f,D=0;for(let L=0;L<I;L++)$(N,E,D),D+=d*f*4;const O=l%(d*f);E=Math.floor(O/d),E>0&&($(N,E,D),D+=E*(d*4)),N=O%d,N>0&&$(N,1,D)});const x=py(c,t.dtype);return this.convertAndCacheOnCPU(e,x),x}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(s!=null)return s;let r;if(t.dtype==="complex64"){const i=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),a=i[0],o=i[1];r=Li(a,o)}else{const i=await this.getBufferData(t.resource);r=py(i,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const t=e.size,s=e.usage,r=this.bufferManager.acquireBuffer(t,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,s){let r=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:s,shape:t,values:null,refCount:1,external:e.zeroCopy});const a=this.tensorMap.get(i),o=NI(a.dtype)*ue(a.shape);if(e.buffer.size<o)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${o})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(r=this.copyBuffer(r)),a.resource=r,Vs().makeTensorFromDataId(i,t,s,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:s,dtype:r,shape:i,resource:a}=t;if(r==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(a==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=a,l=o.size,c=o.usage,d=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,d,0,l),this.submitQueue();const f=this.makeTensorInfo(i,r),p=Vs().makeTensorFromTensorInfo(f),g=this.tensorMap.get(f.dataId);return g.resource=d,{tensorRef:p,buffer:d}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Oi(r));return ft(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ft(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Ka(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),a=Ka(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(i);return o.kernelMs=vE(l),o.getExtraProfileInfo=()=>l.map((c,d)=>({name:a[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,s){return t==="string"&&s!=null&&s.length>0&&lh(s[0])&&(s=s.map(i=>Ha(i))),{dataId:this.write(s,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const s=NI(t.dtype)*ue(t.shape);let r;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(r=this.bufferManager.acquireBuffer(s,i,!0),r.mapState==="unmapped"){const a=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),o=a.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),a.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,r,0,s),this.stagingPendingDisposal.push(a)}else{const a=r.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),r.unmap()}t.values=null}else r=this.bufferManager.acquireBuffer(s,i);t.resource=r}makeUniforms(e){let t=0,s=0;const r=[];let i=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:B(!1,()=>`Unsupported ${l.data.length}D shape`)}(s===5||s===6)&&(c=16),c>i&&(i=c),t=Math.ceil(t/c)*c,s=l.data.length,r.push(t),t+=l.data.length*4}),t=Math.ceil(t/i)*i;const a=new ArrayBuffer(t);e.forEach((l,c)=>{const d=r[c];l.type==="int32"?new Int32Array(a,d,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(a,d,l.data.length).set(l.data):new Float32Array(a,d,l.data.length).set(l.data)});const o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,a,0,t),this.uniformPendingDisposal.push(o),{offset:0,size:t,buffer:o}}runWebGPUProgram(e,t,s,r,i){if(i||(i=this.makeTensorInfo(e.outputShape,s)),ue(i.shape)===0)return this.tensorMap.get(i.dataId).values=es(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=bj(this.device,e);const a=t.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=lj(e,a,i);const o=fe().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=ij(this.device,e,a,i,o)),e.pipeline=this.pipelineCache[e.shaderKey],o||this.recordAndSubmit(e,i,t,r),i}recordAndSubmit(e,t,s,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],a=[];const o="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=s.concat(t).map(g=>g.shape);const p="int32";a.map(g=>{i.push({type:p,data:g});const x=Ye(g);i.push({type:p,data:x})})}else{const p=Ye(t.shape);i.push({type:o,data:p})}if(e.size){const p=ue(e.outputShape);i.push({type:o,data:[e.outputComponent?p/e.outputComponent:p]})}r&&(i=[...i,...r]);const l=[this.tensorToBinding(t),...s.map(p=>this.tensorToBinding(p)),this.makeUniforms(i)];s.forEach(p=>{this.commandQueueOwnedIds.add(p.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((p,g)=>({binding:g,resource:p}))}),d=this.activeTimers!=null;this.ensureCommandEncoderReady();const f={};d&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),f.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(f)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(f)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(d||fe().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===Jc.DRAW)&&(this.endComputePassEncoder(),d?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),s=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,t=xj){return fe().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&ue(s.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}cd.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */r3()&&R2("webgpu",async()=>{const n={powerPreference:fe().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),t.requiredFeatures=s;const r=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const i=await e.requestDevice(t),a="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new cd(i,a)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ut;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(ut||(ut={}));const vj="let resultTemp = a + b;",wj="let resultTemp = atan2(a, b);",Sj="let resultTemp = areal * breal - aimag * bimag;",Cj="let resultTemp = areal * bimag + aimag * breal;",$j="let resultTemp = a / b;",kj="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Nj=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,Ij=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,Tj=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,Ej=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,Rj=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,Aj=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,Dj="return f32(a >= 1.0 && b >= 1.0);",_j=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Oj="return f32(a >= 1.0 || b >= 1.0);",Fj=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,zj="let resultTemp = max(a, b);",Lj="let resultTemp = min(a, b);",Pj=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,Mj=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,Bj="let resultTemp = a * b;",Vj=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,Uj=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,Wj=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,Gj=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,Hj="if (a < 0.0) { return b * a; }  return a;",jj=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,qj="let resultTemp = (a - b) * (a - b);",Xj="let resultTemp = a - b;";function kS(n,e){let t;do{switch(n){case ut.ATAN2:t=wj;break;case ut.MAX:t=zj;break;case ut.MIN:t=Lj;break;case ut.MOD:t=e?Mj:Pj;break;case ut.NOT_EQUAL:t=e?Uj:Vj;break;case ut.POW:t=e?Gj:Wj;break;default:continue}let s,r,i;return e?(s="isnanVec4",r="vec4<f32>",i="vec4<bool>"):(s="isnan",r="f32",i="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${r}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${r}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${r}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case ut.ADD:t=vj;break;case ut.COMPLEX_MULTIPLY_IMAG:t=Cj;break;case ut.COMPLEX_MULTIPLY_REAL:t=Sj;break;case ut.DIV:t=$j;break;case ut.ELU_DER:t=kj;break;case ut.EQUAL:t=Nj;break;case ut.FLOOR_DIV:t=Ij;break;case ut.GREATER:t=Tj;break;case ut.GREATER_EQUAL:t=Ej;break;case ut.LESS:t=Rj;break;case ut.LESS_EQUAL:t=Aj;break;case ut.LOGICAL_AND:return e?_j:Dj;case ut.LOGICAL_OR:return e?Fj:Oj;case ut.MUL:t=Bj;break;case ut.PRELU:return e?jj:Hj;case ut.SQUARED_DIFFERENCE:t=qj;break;case ut.SUB:t=Xj;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ae;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(Ae||(Ae={}));const Kj="return abs(a);",Yj=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,Qj=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,Zj=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,Jj="return asinh(a);",e5=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,t5=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,n5="return ceil(a);",s5="return cos(a);",r5=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,i5="return exp(a) - 1.0;",a5="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",o5=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,l5=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${Vb};
  let a1 = ${Ub};
  let a2 = ${Wb};
  let a3 = ${Gb};
  let a4 = ${Hb};
  let a5 = ${jb};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,u5="return exp(a);",c5="return floor(a);",h5="return f32(!isnan(a) && !isinf(a));",d5="return f32(isinf(a));",f5="return f32(isnan(a));",p5="return a;",m5=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,g5=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,y5="return f32(!(a >= 1.0));",x5="return -a;",b5="if (a < 0.0) { return uniforms.alpha * a; } return a;",v5=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,w5="return 1.0 / a;",S5="return select(a, 0.0, a < 0.0);",C5="return clamp(a, 0.0, 6.0);",$5="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",k5=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,N5="return round(a);",I5="return inverseSqrt(a);",T5=`
  if (a >= 0.0) {
    return ${bm} * a;
  } else {
    return ${xm} * (exp(a) - 1.0);
  }
`,E5="return 1.0 / (1.0 + exp(-1.0 * a));",R5="return sign(a);",A5="return sin(a);",D5=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,_5=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,O5="return sqrt(a);",F5="return a * a;",z5=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,L5="return tan(a);",P5=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,M5="return f32(i32((a)));";function Wl(n,e){switch(n){case Ae.ABS:return Kj;case Ae.ACOS:return Yj;case Ae.ACOSH:return Qj;case Ae.ASIN:return Zj;case Ae.ASINH:return Jj;case Ae.ATAN:return e5;case Ae.ATANH:return t5;case Ae.COS:return s5;case Ae.COSH:return r5;case Ae.CEIL:return n5;case Ae.ELU:return e?o5:a5;case Ae.ERF:return l5;case Ae.EXP:return u5;case Ae.EXPM1:return i5;case Ae.FLOOR:return c5;case Ae.IS_FINITE:return h5;case Ae.IS_INF:return d5;case Ae.IS_NAN:return f5;case Ae.LINEAR:return p5;case Ae.LOG:return m5;case Ae.LOG1P:return g5;case Ae.LOGICAL_NOT:return y5;case Ae.NEG:return x5;case Ae.LEAKYRELU:return e?v5:b5;case Ae.RECIPROCAL:return w5;case Ae.RELU:return e?k5:S5;case Ae.RELU6:return e?$5:C5;case Ae.ROUND:return N5;case Ae.RSQRT:return I5;case Ae.SELU:return T5;case Ae.SIGMOID:return E5;case Ae.SIGN:return R5;case Ae.SIN:return A5;case Ae.SINH:return D5;case Ae.SOFTPLUS:return _5;case Ae.SQRT:return O5;case Ae.SQUARE:return F5;case Ae.STEP:return z5;case Ae.TAN:return L5;case Ae.TANH:return P5;case Ae.TO_INT:return M5;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(n,e=!1,t=!1,s=3){if(n===null)return"";let r="";if(n==="linear")r=Wl(Ae.LINEAR);else if(n==="relu")r=Wl(Ae.RELU,t);else if(n==="elu")r=Wl(Ae.ELU,t);else if(n==="relu6")r=Wl(Ae.RELU6,t);else if(n==="prelu")r=kS(ut.PRELU,t);else if(n==="sigmoid")r=Wl(Ae.SIGMOID,t);else if(n==="leakyrelu")r=Wl(Ae.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const a=xt(t?4:1);let o="";return e?o=`
      fn activation(a : ${a}, coords : vec${s}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${r}
      }`:o=`
      fn activation(a : ${a}, coords : vec${s}<i32>) -> ${a} {
        ${r}
      }`,o}function Iu(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a3(n,e,t=!1,s=!1,r=!1,i=1){B(n&&i===1||!n,()=>`transposeA ${n} is not compatible with component size ${i}`);const a=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,o=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${xt(i)} {
    var value = ${xt(i)}(0.0);
    ${t&&r?a:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${a}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${xt(i)} {
    var value = ${xt(i)}(0.0);
    ${o}
    return value;
  }
  `}function NS(n,e,t,s,r=!1,i=!1,a=!1,o=1){return`
  ${a3(t,s,r,i,a,o)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${xt(o)}) {
    ${r&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Iu(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const B5=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,V5=(n,e,t,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let r="",i="";for(let a=0;a<e;a++)r+=`let BCached${a} = mm_Bsub[k * ${e} + ${a}][tileCol];`,i+=`acc[i] = fma(BCached${a}, vec4<f32>(ACached[${a}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${r}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function e0(n,e,t=!1,s=32,r=!1,i=32,a=!1){const o=e[1]*n[1],l=e[0]*n[0],c=t?o:s,d=t?s:o,f=c/e[0],p=s/e[1],g=n[1],x=n[0];return B((t&&f===4&&n[1]===4||!t&&(f===3||f===4))&&c%e[0]===0&&s%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${f} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${f} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${f}<f32>, ${c/f}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/n[0]}>, ${s}>;

  ${_e()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${g};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${g};
    let globalCol = i32(globalId.x) * ${x};
    let batch = ${r?"0":"i32(globalId.z)"};
    let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${o};

    let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${g}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${p};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${B5(t,f)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${V5(t,f,g,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const II=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,U5=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function t0(n,e,t=!1,s=32,r=!1,i=32,a=!1,o=!1){const l=n[1]*e[1],c=n[0]*e[0],d=t?l:s,f=t?s:l;B(f%e[1]===0&&d%e[0]===0&&s%e[1]===0,()=>`tileAHight ${f} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const p=f/e[1],g=d/e[0],x=s/e[1],b=n[1],v=n[0],w=a?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
            ${II(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${v}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${v}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${b}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${v}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${b}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${b};
  let tileCol = i32(localId.x) * ${v};

  let globalRow = i32(globalId.y) * ${b};
  let globalCol = i32(globalId.x) * ${v};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${p};
  let tileColA = i32(localId.x) * ${g};
  let tileRowB = i32(localId.y) * ${x};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${II(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${x}; innerRow++) {
      for (var innerCol = 0; innerCol < ${v}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${v}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${v}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${b}; innerRow++) {
        ${U5(t)}
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${b}; innerRow++) {
    for (var innerCol = 0; innerCol < ${v}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${f}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${s}>;

    ${_e()} {
      let batch = ${r?"0":"i32(globalId.z)"};
      let batchA = ${r||!o?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${r||!o?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${v}>, ${b}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${b}; innerRow++) {
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${w}
    }
  `}const W5=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function G5(n,e=!1){B(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${_e()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${W5(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}let H5=class{constructor(e,t,s=!1,r=!1,i=null,a=null,o=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=s?e[1]:e[2];if(this.isVec4=(c%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const p=yj(t[1],c,t[2],s);this.workgroupSize=p.workgroupSize,this.elementsPerThread=p.elementsPerThread}this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const d=i!=null,f=o!=null;d&&this.variableNames.push("bias"),f&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=s,this.transposeB=r,this.addBias=d,this.activation=a,this.hasPreluActivationWeights=f,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,s){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const a=e%r===0,o=t%i===0,l=s%this.tileInner===0;return[a,o,l]}getUserCode(){return`
      ${eo(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${NS(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?e0(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?G5(this.workgroupSize,this.transposeA):t0(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j5(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${_e()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class q5{constructor(e,t=!1,s=!1,r=null,i=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize);const o=r!=null,l=a!=null;o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=s,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${t}_${s}`}getUserCode(){return`
      ${eo(this.activation,this.hasPreluActivationWeights)}
      ${NS(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${j5(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X5(n){const e=n[1],t=n[0],s=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${_e()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class K5{constructor(e,t,s,r=!1,i=!1,a=null,o=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const c=a!=null;c&&this.variableNames.push("bias");const d=l!=null;d&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=c,this.activation=o,this.hasPreluActivationWeights=d,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`
      ${eo(this.activation,this.hasPreluActivationWeights)}
      ${NS(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${X5(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y5{constructor(e,t,s=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,B(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Oe(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=r,this.shaderKey=`matMulSplitK_${s}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${a3(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${xt(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${il("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?e0(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):t0(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class Q5{constructor(e,t=null,s=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=r!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${eo(this.activation,this.hasPreluActivationWeights)}
    ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Iu(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z5=class{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||bu(r),i==="string"){const a=kn(i,ue(s));return a.fill(r),e.makeTensorInfo(s,i,a)}else{const a=new Z5(s),o=[{type:"float32",data:[r]}];return e.runWebGPUProgram(a,[],i,o)}}const J5={kernelName:Rx,backendName:"webgpu",kernelFunc:ar};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function He(n){const{inputs:e,attrs:t}=n,{x:s}=e,{shape:r}=t,i=ue(s.shape),a=m2(r,i),o=ue(a);return B(i===o,()=>`The new shape (${a}) has ${o} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:a,dtype:s.dtype}}const eq={kernelName:Qp,backendName:"webgpu",kernelFunc:He};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n0({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape.length,d=e.shape.length,f=t?n.shape[c-2]:n.shape[c-1],p=s?e.shape[d-1]:e.shape[d-2],g=t?n.shape[c-1]:n.shape[c-2],x=s?e.shape[d-2]:e.shape[d-1],b=n.shape.slice(0,-2),v=e.shape.slice(0,-2),w=ue(b),$=ue(v),N=tt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,x]);B(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[w,f,g]:[w,g,f],D=s?[$,x,p]:[$,p,x],O=He({inputs:{x:n},backend:r,attrs:{shape:E}}),L=He({inputs:{x:e},backend:r,attrs:{shape:D}}),z=[O,L],P=Math.max(w,$),_=[O,L],H=[{type:"int32",data:[g]},{type:"int32",data:[x]},{type:"int32",data:[f]}];let q,ee;const Y=[P,g,x];let G=fe().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(G<0){const re=fe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),he=re>0?re:r.thresholdToIncreaseWorkgroups,W=P*Math.ceil(g/32)*Math.ceil(x/32);W<=he||g<=8&&W<=he*2?P*g*x<=128?G=ra.MatMulReduceProgram:P===1&&p>=2e3?G=ra.MatMulSplitKProgram:G=ra.MatMulSmallOutputSizeProgram:G=ra.MatMulPackedProgram}switch(G){case ra.MatMulReduceProgram:q=new q5(Y,t,s,i,l,a);break;case ra.MatMulSplitKProgram:{if(ee=ar({backend:r,attrs:{shape:Y,value:0,dtype:n.dtype}}),q=new Y5(Y,p,t,s),i||l){ee=r.runWebGPUProgram(q,_,n.dtype,H,ee);const he=new Q5(ee.shape,i,l,a);let W=null;const ne=[ee];i&&ne.push(i),a&&ne.push(a),l==="leakyrelu"&&(W=[{type:"float32",data:[o]}],he.uniforms+=" alpha : f32,");const pe=r.runWebGPUProgram(he,ne,ee.dtype,W);z.push(ee);const de=He({inputs:{x:pe},backend:r,attrs:{shape:N}});z.push(pe);for(const we of z)r.disposeData(we.dataId);return de}break}case ra.MatMulSmallOutputSizeProgram:q=new K5(E,D,Y,t,s,i,l,a);break;case ra.MatMulPackedProgram:const re=r.adapterInfo.isIntel();q=new H5(E,Y,t,s,i,l,a,re);break;default:throw new Error(`Unsupported MatMulProgramType ${G}.`)}i&&_.push(i),a&&_.push(a),l==="leakyrelu"&&(H.push({type:"float32",data:[o]}),q.uniforms+=" alpha : f32,"),ee=r.runWebGPUProgram(q,_,n.dtype,H,ee);const te=He({inputs:{x:ee},backend:r,attrs:{shape:N}});z.push(ee);for(const re of z)r.disposeData(re.dataId);return te}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tq(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=s;return n0({a:r,b:i,transposeA:l,transposeB:c,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:f,activation:d})}const nq={kernelName:Vf,backendName:"webgpu",kernelFunc:tq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TI=class{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=tt(t,s),this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${kS(this.op,!1)}
      }

      ${_e("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let My=class{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=tt(t,s),this.dispatchLayout=Be(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=t.length>0&&t[t.length-1]%4===0,i=s.length>0&&s[s.length-1]%4===0;r&&i?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(ON(s)||s[s.length-1]===1)||i&&(ON(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${kS(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const r=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${r}];`:`let a = sharedBuf[${r}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${_e("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${_e("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kr(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const sq={kernelName:Rh,backendName:"webgpu",kernelFunc:kr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tu(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),a=t.tensorMap.get(i.dataId),o=kr({inputs:{x:s},backend:t}),l=kr({inputs:{x:r},backend:t});return a.complexTensorInfos={real:o,imag:l},i}const rq={kernelName:gx,backendName:"webgpu",kernelFunc:Tu};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hd=class{constructor(e,t,s=""){this.variableNames=["A"],this.size=!0;const r=128;this.workgroupSize=[r,1,1],this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Wl(this.op,!1)}
      }
      ${_e("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ot({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:s,backend:r})=>{const{x:i}=s,a=r,o=t||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){const c=a.tensorMap.get(i.dataId),d=e(c.values,o);return a.makeTensorInfo(i.shape,o,d)}const l=new hd(i.shape,n);return a.runWebGPUProgram(l,[i],o)}}function fs({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:s}){return({inputs:r,backend:i})=>{const{a,b:o}=r,l=i;if(t&&a.dtype==="complex64"){const f=l.tensorMap.get(a.dataId),p=l.tensorMap.get(o.dataId);let g,x;if(n!==ut.MUL)[g,x]=[[f.complexTensorInfos.real,p.complexTensorInfos.real],[f.complexTensorInfos.imag,p.complexTensorInfos.imag]].map(v=>{const[w,$]=v,I={dataId:w.dataId,dtype:w.dtype,shape:a.shape},N={dataId:$.dataId,dtype:$.dtype,shape:o.shape},E=new My(n,a.shape,o.shape);return l.runWebGPUProgram(E,[I,N],ds(w.dtype,$.dtype))});else{const v=new TI(ut.COMPLEX_MULTIPLY_REAL,a.shape,o.shape),w=new TI(ut.COMPLEX_MULTIPLY_IMAG,a.shape,o.shape),$=[{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:a.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:o.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:o.shape}];g=l.runWebGPUProgram(v,$,"float32"),x=l.runWebGPUProgram(w,$,"float32")}const b=Tu({inputs:{real:g,imag:x},backend:l});return l.disposeData(g.dataId),l.disposeData(x.dataId),b}const c=s||ds(a.dtype,o.dtype);if((a.dtype==="string"||o.dtype==="string"||l.shouldExecuteOnCPU([a,o]))&&e!=null){const f=l.tensorMap.get(a.dataId).values,p=l.tensorMap.get(o.dataId).values,g=a.dtype==="string"?Pi(f):f,x=a.dtype==="string"?Pi(p):p,[b,v]=e(a.shape,o.shape,g,x,c);return l.makeTensorInfo(v,c,b)}const d=new My(n,a.shape,o.shape);return l.runWebGPUProgram(d,[a,o],c)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qe(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&B(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o3(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const iq=n=>{const{x:e}=n.inputs,t=n.backend;qe(e,"abs");let s=new Float32Array(ue(e.shape));const r=t.data.get(e.dataId).values;return s=o3(r),t.makeOutput(s,e.shape,e.dtype)},aq={kernelName:up,backendName:"cpu",kernelFunc:iq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fn(n){return(e,t,s,r,i)=>{const a=tt(e,t),o=a.length,l=Ye(a),c=ue(a),d=es(i,c),f=e.length,p=t.length,g=Ye(e),x=Ye(t),b=Ho(e,a),v=Ho(t,a);if(b.length+v.length===0)for(let w=0;w<d.length;++w)d[w]=n(s[w%s.length],r[w%r.length]);else for(let w=0;w<d.length;++w){const $=uh(w,o,l),I=$.slice(-f);b.forEach(O=>I[O]=0);const N=ua(I,f,g),E=$.slice(-p);v.forEach(O=>E[O]=0);const D=ua(E,p,x);d[w]=n(s[N],r[D])}return[d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,o=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(o.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",a)},o}const oq={kernelName:gx,backendName:"cpu",kernelFunc:wr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function By(n,e,t="float32"){if(t==="complex64"){const r=By(n,e,"float32"),i=By(n,e,"float32");return wr({inputs:{real:r,imag:i},backend:n})}const s=ws(ue(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pa(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const lq={kernelName:Rh,backendName:"cpu",kernelFunc:pa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mu(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const uq={kernelName:Gx,backendName:"cpu",kernelFunc:mu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l3(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=wu([0],t),[i,a]=Fn((o,l)=>o!==l?1:0)(e,[],n,r,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function qo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return pa({inputs:{x:r},backend:t});const d=By(t,r.shape,r.dtype),f=qo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),p=wr({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),p}if(r.dtype==="complex64"){const d=mu({inputs:{input:r},backend:t}),f=qo({inputs:{x:d},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(d),f}if(!g2(r.dtype,i)){const d=pa({inputs:{x:r},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:i}}const a=t.data.get(r.dataId).values,[o,l,c]=l3(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,l,c)}const cq={kernelName:yh,backendName:"cpu",kernelFunc:qo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ss(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a,b:o}=r,l=i;qe([a,o],n);const c=l.data.get(a.dataId).values,d=l.data.get(o.dataId).values,f=a.dtype==="string"?Pi(c):c,p=a.dtype==="string"?Pi(d):d,g=s||a.dtype,[x,b]=e(a.shape,o.shape,f,p,g);return l.makeTensorInfo(b,g,x)}:({inputs:r,backend:i})=>{const{a,b:o}=r,l=i;if(a.dtype==="complex64"||o.dtype==="complex64"){const c=qo({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),f=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,g=l.data.get(f.dataId).values,x=l.data.get(p.dataId).values,b=qo({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),v=l.data.get(b.dataId),w=v.complexTensorInfos.real,$=v.complexTensorInfos.imag,I=l.data.get(w.dataId).values,N=l.data.get($.dataId).values,[E,D,O]=t(a.shape,o.shape,g,x,I,N),L=l.makeTensorInfo(O,"float32",E),z=l.makeTensorInfo(O,"float32",D),P=wr({inputs:{real:L,imag:z},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(b),l.disposeIntermediateTensorInfo(L),l.disposeIntermediateTensorInfo(z),P}else{const c=l.data.get(a.dataId).values,d=l.data.get(o.dataId).values,f=s||a.dtype,[p,g]=e(a.shape,o.shape,c,d,f);return l.makeTensorInfo(g,f,p)}}}function IS(n){return(e,t,s,r,i,a)=>{const o=tt(e,t),l=ue(o),c=o.length,d=Ye(o),f=es("float32",l),p=es("float32",l),g=Ho(e,o),x=Ho(t,o),b=Li(s,r),v=Li(i,a),w=e.length,$=Ye(e),I=t.length,N=Ye(t);if(g.length+x.length===0)for(let E=0;E<f.length;E++){const D=E%b.length,O=E%v.length,L=n(b[D*2],b[D*2+1],v[O*2],v[O*2+1]);f[E]=L.real,p[E]=L.imag}else for(let E=0;E<f.length;E++){const D=uh(E,c,d),O=D.slice(-w);g.forEach(H=>O[H]=0);const L=ua(O,w,$),z=D.slice(-I);x.forEach(H=>z[H]=0);const P=ua(z,I,N),_=n(b[L*2],b[L*2+1],v[P*2],v[P*2+1]);f[E]=_.real,p[E]=_.imag}return[f,p,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3=Fn((n,e)=>n+e),hq=IS((n,e,t,s)=>({real:n+t,imag:e+s})),eh=ss(vu,u3,hq),dq={kernelName:vu,backendName:"cpu",kernelFunc:eh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TS(n,e,t,s,r){const i=ue(s),a=ws(r,t);for(let o=0;o<n.length;o++){const l=n[o];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?a[l]+=e[o]:a[l]+=1)}return a}function c3(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],a=ft([r,t],e.dtype);for(let o=0;o<r;o++)for(let l=0;l<i;l++){const c=n.get(o,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?a.set(1,o,c):e.size>0?a.set(a.get(o,c)+e.get(o,l),o,c):a.set(a.get(o,c)+1,o,c))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h3=Fn((n,e)=>n&e),fq=ss(px,h3),pq={kernelName:px,backendName:"cpu",kernelFunc:fq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wa(n){return(e,t,s)=>{const r=kn(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qt(n,e,t){const s=wa(e);return al(n,s,t)}function al(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;qe(a,n);const o=i,l=o.data.get(a.dataId).values;let c;if(a.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=Pi(l)}else c=l;const d=t||a.dtype,f=e(c,d,r);return o.makeTensorInfo(a.shape,d,f)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d3=wa(n=>Math.ceil(n)),mq=al(xh,d3),gq={kernelName:xh,backendName:"cpu",kernelFunc:mq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f3(n,e,t,s){const r=kn(t,ue(e));if(s&&t!=="string"){let i=0;n.forEach(a=>{const o=ue(a.shape);r.set(a.vals,i),i+=o})}else{let i=0;n.forEach(a=>{const o=t==="string"?Pi(a.vals):a.vals;let l=0;for(let c=0;c<a.shape[0];++c){const d=c*e[1]+i;for(let f=0;f<a.shape[1];++f)r[d+f]=o[l++]}i+=a.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p3=Fn((n,e)=>n===e?1:0),m3=ss(kp,p3,null,"bool"),yq={kernelName:kp,backendName:"cpu",kernelFunc:m3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g3=wa(n=>Math.exp(n)),y3=al(kh,g3,"float32"),xq={kernelName:kh,backendName:"cpu",kernelFunc:y3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x3=wa(n=>Math.expm1(n)),bq=al(Nh,x3),vq={kernelName:Nh,backendName:"cpu",kernelFunc:bq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b3=wa(n=>Math.floor(n)),wq=al(Ih,b3),Sq={kernelName:Ih,backendName:"cpu",kernelFunc:wq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v3=Fn((n,e)=>Math.floor(n/e)),Cq=ss(Th,v3,null,"int32"),$q={kernelName:Th,backendName:"cpu",kernelFunc:Cq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3(n,e,t,s,r,i,a,o,l){const c=ft([s,i],t);for(let d=0;d<s;d++){const f=[];let p=0;for(let g=0;g<r;g++){const x=n[d*r+g];p+=x*a[g],f.push(x)}if(p<0||p>=l/i)throw new Error(`Invalid indices: ${f} does not index into ${o}`);for(let g=0;g<i;g++)c.values[d*i+g]=e.get(...e.indexToLoc(p*i+g))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(n,e,t){const s=ft(t,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),o=a[0],l=a[2],c=e.locToIndex([o,l]);a[2]=e.values[c];const d=n.locToIndex(a);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C3=Fn((n,e)=>n>e?1:0),kq=ss(Ep,C3,null,"bool"),Nq={kernelName:Ep,backendName:"cpu",kernelFunc:kq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $3=Fn((n,e)=>n>=e?1:0),Iq=ss(Eh,$3,null,"bool"),Tq={kernelName:Eh,backendName:"cpu",kernelFunc:Iq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k3=Fn((n,e)=>n<e?1:0),Eq=ss(Ap,k3,null,"bool"),Rq={kernelName:Ap,backendName:"cpu",kernelFunc:Eq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N3=Fn((n,e)=>n<=e?1:0),Aq=ss(Dp,N3,null,"bool"),Dq={kernelName:Dp,backendName:"cpu",kernelFunc:Aq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(n,e,t){const s=(e-n)/(t-1),r=ws(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T3=wa(n=>Math.log(n)),_q=al(Oh,T3),Oq={kernelName:Oh,backendName:"cpu",kernelFunc:_q};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E3(n,e,t,s){const r=es(s,ue(t));for(let i=0;i<r.length;++i){const a=i*e;let o=n[a];for(let l=0;l<e;++l){const c=n[a+l];(Number.isNaN(c)||c>o)&&(o=c)}r[i]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R3=Fn((n,e)=>Math.max(n,e)),Fq=ss(zh,R3),zq={kernelName:zh,backendName:"cpu",kernelFunc:Fq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A3=Fn((n,e)=>Math.min(n,e)),Lq=ss(Lh,A3),Pq={kernelName:Lh,backendName:"cpu",kernelFunc:Lq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ES=Fn((n,e)=>n*e),Mq=IS((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),s0=ss(Mh,ES,Mq),Bq={kernelName:Mh,backendName:"cpu",kernelFunc:s0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3(n,e,t){const s=Jo(-1,t);return ES([],e,s,n,t)}function Vq(n){const{inputs:e,backend:t}=n,{x:s}=e;qe(s,"neg");const r=t.data.get(s.dataId).values,[i,a]=D3(r,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}const Uq={kernelName:Wp,backendName:"cpu",kernelFunc:Vq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _3=Fn((n,e)=>n!==e?1:0),Wq=ss(Gp,_3,null,"bool"),Gq={kernelName:Gp,backendName:"cpu",kernelFunc:Wq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RS(n,e,t,s,r){const i=e.length,a=ue(e),o=Ye(e),l=Ye(r),c=es(t,ue(r));for(let d=0;d<a;++d){const f=uh(d,i,o),p=new Array(f.length);for(let x=0;x<p.length;x++)p[x]=f[s[x]];const g=ua(p,i,l);c[g]=n[d]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;qe(r,"transpose");const a=r.shape.length,o=new Array(a);for(let f=0;f<o.length;f++)o[f]=r.shape[i[f]];const l=s.data.get(r.dataId).values,c=RS(l,r.shape,r.dtype,i,o);return{dataId:s.write(c,o,r.dtype),shape:o,dtype:r.dtype}}const Hq={kernelName:Jl,backendName:"cpu",kernelFunc:ur};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3(n,e,t,s){const[r,i]=On(n,s),a=ds(e,"int32"),o=ws(ue(r),a),l=ue(i);for(let c=0;c<o.length;++c){const d=c*l;let f=1;for(let p=0;p<l;++p)f*=t[d+p];o[c]=f}return{outVals:o,outShape:r,outDtype:a}}function jq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;qe(r,"prod");const o=r.shape.length,l=pt(i,r.shape),c=Zt(l,o);let d=l,f=r;const p=[];c!=null&&(f=ur({inputs:{x:r},backend:t,attrs:{perm:c}}),p.push(f),d=cn(d.length,o));const g=t.data.get(f.dataId).values,{outVals:x,outShape:b,outDtype:v}=O3(f.shape,f.dtype,g,d);let w=b;return a&&(w=In(b,l)),p.forEach($=>t.disposeIntermediateTensorInfo($)),t.makeTensorInfo(w,v,x)}const qq={kernelName:Yp,backendName:"cpu",kernelFunc:jq};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xq(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=uh(r,e.length,Ye(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function Kq(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function Yq(n,e,t,s){const r=[];let i=0;const a=e.length-1+t.length,o=new Array(a).fill(null).map(()=>[0]);Kq(t,s);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const d=e[c+1];for(let f=1;f<l+1;++f)o[c].push(f*d)}for(let c=0;c<n.length;++c){let d=n[c],f=n[c]+1;for(let p=0;p<t.length;++p){const g=t[p],x=p+e.length-1;if(x>=0){const b=o[x],v=b[b.length-1]-g[d];for(let w=d;w<f;++w)o[x].push(g[w+1]+v)}d=g[d],f=g[f]}f!==d&&(r.push([d,f]),i+=f-d)}return{outSplits:o,valueSlices:r,numValues:i}}function Qq(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=kn("int32",s);e.push(r),n[t].forEach((i,a)=>r[a]=i)}return e}function EI(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function Zq(n,e,t,s,r,i){const a=EI(e,2)[1],o=EI(i,2)[1];let l=0;for(const c of t)for(let d=c[0];d<c[1];++d){for(let f=0;f<s;++f)r[l*o+f]=n[d*a+f];++l}}function Jq(n,e,t,s,r){const i=e.slice();i[0]=r;const a=kn(t,ue(i)),o=n.length,l=o===0?0:o/e[0];return Zq(n,e,s,l,a,i),[a,i]}function F3(n,e,t,s,r,i,a,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(Xq(i,a,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:d,valueSlices:f,numValues:p}=Yq(i,a,n,c),g=Qq(d),x=Jq(t,s,r,f,p);return[g,x[0],x[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RI=2147483647;function z3(n,e,t,s,r,i,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,l=r.length===0,c=a.length===0,d=[];o||d.push(e[0]),l||d.push(r[0]),c||d.push(a[0]);for(let v=1;v<d.length;++v)if(d[v]!==d[v-1])throw new Error("starts, limits, and deltas must have the same shape");const f=d.length===0?1:d[0],p=kn("int32",f+1);p[0]=0;for(let v=0;v<f;++v){const w=o?n[0]:n[v],$=l?s[0]:s[v],I=c?i[0]:i[v];if(I===0)throw new Error("Requires delta != 0");let N;if(I>0&&$<w||I<0&&$>w)N=0;else if(N=Math.ceil(Math.abs(($-w)/I)),N>RI)throw new Error(`Requires ((limit - start) / delta) <= ${RI}`);p[v+1]=p[v]+N}const g=p[f],x=kn(t,g);let b=0;for(let v=0;v<f;++v){const w=p[v+1]-p[v];let $=o?n[0]:n[v];const I=c?i[0]:i[v];for(let N=0;N<w;++N)x[b++]=$,$+=I}return[p,x]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ai=Ai;class Vy{constructor(e,t,s,r,i,a,o,l,c,d){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=RA(d),this.raggedRank=AA(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ai.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ai.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ai.VALUE_ROWIDS:return Vy.getMaxWidthValueRowID(t);case ai.ROW_SPLITS:return Vy.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${ai[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let a=1;a<t;++a){const o=e[a];o!==r&&(r=o,i=Math.max(a-s,i),s=a)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return DI(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;DA(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=EA(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let a=0;for(let o=0;o<r;++o,a+=t)i.push(a);for(let o=r;o<e;++o)i.push(-1);return B(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,a=[];for(let o=0;o<i-1;++o){const l=e[o+1]-e[o];let c=Math.min(r,l),d=t[o];d===-1&&(c=0);for(let f=0;f<c;++f)a.push(d),d+=s;for(let f=0;f<l-c;++f)a.push(-1)}if(i>0&&a.length!==e[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,a=[];if(i===0)return[];let o=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];a.push(c);for(let d=1;d<i;++d){const f=e[d];if(f===l)c>=0&&(++o,o<r?c+=s:c=-1);else{if(o=0,l=f,f>=t.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${t.length}`);c=t[f]}a.push(c)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case ai.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case ai.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${ai[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case ai.FIRST_DIM_SIZE:return e[0];case ai.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ai.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ai[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const i=DI(s,!1),a=kn(this.valuesDType,ue(i));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,r[c],s[c]);this.setOutput(this.raggedRank,l,a,i)}return[i,a]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,a=s;let o=r.slice();o=o.slice(e+1);const l=ue(o),c=t.length;let d=this.defaultValue;if(d.length!==l&&d.length!==1){const x=this.defaultValueShape;ce(()=>{const b=ie(d,x);d=Hc(b,o).dataSync()})}let f=0,p=0,g=0;for(let x=0;x<=c;++x){let b=x<c?t[x]:-1;if(b===g){++g;continue}if(p<g){const v=i.subarray(f*l),w=a.subarray(p*l),$=(g-p)*l;AI(w,v,$)}if(x>=c){const v=s.length;b=Math.floor(v/l)}if(b>g)if(this.defaultValue.length===1)a.subarray(g*l,b*l).fill(this.defaultValue[0]),g=b;else for(;b>g;){const v=a.slice(g*l);AI(v,d,l),++g}b<0?(f=x+1,p=g):(f=x,p=g,g=p+1)}}}function AI(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function DI(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function L3(n,e,t,s,r,i,a,o,l,c){return new Vy(n,e,t,s,r,i,a,o,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P3(n,e,t,s){const r=n===e,i=n<e&&t<0,a=e<n&&t>1;if(r||i||a)return ws(0,s);const o=Math.abs(Math.ceil((e-n)/t)),l=ws(o,s);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M3=wa(n=>1/Math.sqrt(n)),e8=al(Hh,M3),t8={kernelName:Hh,backendName:"cpu",kernelFunc:e8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ql(n,e,t,s,r,i,a,o,l,c){const d=[s/r,r],f=n.values,p=e.values;if(s===0)return ft(t,e.dtype);const g=l instanceof Qn?l:ft(d,e.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let x=0;x<i;x++){const b=[];let v=0;for(let w=0;w<a;w++){const $=f[x*a+w];b.push($),v+=$*o[w]}if(v<0||v>=s/r)throw new Error(`Invalid indices: ${b} does not index into ${t}`);for(let w=0;w<r;w++)c?g.values[v*r+w]+=p[x*r+w]:g.values[v*r+w]=e.rank===0?p[0]:p[x*r+w]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n8=wa(n=>1/(1+Math.exp(-n))),B3=qt(Yh,n=>1/(1+Math.exp(-n))),s8={kernelName:Yh,backendName:"cpu",kernelFunc:B3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3(n,e,t,s,r){const i=bS(s,e,t),a=ue(t),o=Ye(s);if(i){const f=vS(e,o);return r==="string"?n.slice(f,f+a):n.subarray(f,f+a)}const l=r==="string"?Pi(n):n,c=ft(s,r,l),d=ft(t,r);for(let f=0;f<d.size;++f){const p=d.indexToLoc(f),g=p.map((x,b)=>x+e[b]);d.set(c.get(...g),...p)}return r==="string"?QA(d.values):d.values}function gu(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s;qe(r,"slice");const[o,l]=ym(r,i,a);_b(r,o,l);const c=t.data.get(r.dataId).values,d=V3(c,o,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const r8={kernelName:nm,backendName:"cpu",kernelFunc:gu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U3(n,e,t,s,r,i,a){const o=e[0],l=i[0],c=new Array(l),d=new Array(o),f=e[1];if(l===0){if(o!==0)throw new Error(MA(o));const v=kn(t,0),w=kn(r,0);return[v,[0,f],w,c,d]}let p=!0,g=0;const x=new Array(l).fill(0);for(let v=0;v<o;++v){const w=n[v*f];if(w<0)throw new Error(BA(v,w));if(w>=l)throw new Error(VA(v,w,l));++x[w],p=p&&w>=g,g=w}let b=!0;for(let v=0;v<l;++v){const w=x[v]===0;c[v]=w,b=b&&!w,x[v]=Math.max(x[v],1),v>0&&(x[v]+=x[v-1])}if(b&&p){const v=n,w=s;for(let $=0;$<o;++$)d[$]=$;return[v,[o,f],w,c,d]}else{const v=x[l-1],w=kn(t,v*f),$=kn(r,v),I=new Array(l).fill(0);for(let N=0;N<o;++N){const E=n[N*f],D=I[E],O=(E===0?0:x[E-1])+D;I[E]++;for(let L=0;L<f;++L)w[O*f+L]=n[N*f+L];$[O]=s[N],d[N]=O}for(let N=0;N<l;++N)if(I[N]===0){const D=N===0?0:x[N-1];w[D*f+0]=N;for(let O=1;O<f;++O)w[D*f+O]=0;$[D]=a}return[w,[v,f],$,c,d]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W3(n,e,t,s,r){const i=ue(s),a=e[0],o=r.length,l=[];let c=1,d=-1;for(let v=0;v<o;++v){const w=r[v];if(w===-1){if(d!==-1)throw new Error(UA(d,v));d=v,l.push(1)}else{if(w<0)throw new Error(WA(v,w));c*=w,l.push(w)}}if(d!==-1){if(c<=0)throw new Error(GA());const v=Math.trunc(i/c);if(c*v!==i)throw new Error(HA(s,l));l[d]=v}if(ue(l)!==i)throw new Error(jA(s,l));const p=s.length,g=[];if(p>0){g[p-1]=1;for(let v=p-2;v>=0;--v)g[v]=g[v+1]*s[v+1]}const x=[];if(o>0){x[o-1]=1;for(let v=o-2;v>=0;--v)x[v]=x[v+1]*l[v+1]}const b=kn(t,a*o);for(let v=0;v<a;++v){let w=0;for(let $=0;$<p;++$)w+=n[v*p+$]*g[$];for(let $=0;$<o;++$)b[v*o+$]=Math.trunc(w/x[$]),w%=x[$]}return[b,[a,o],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(n,e,t,s,r,i=!1,a=0){const o=s.length,l=[e[0],n.length/e[0]],c=l[1],f=o>0?r[o-1]+1:0;if(f<0)throw new Error(Dw());const p=e.slice();p[0]=f;const g=p.reduce((I,N)=>I*N,1),x=kn(t,g);if(o===0)return f>0&&x.fill(a),[x,p];if(f<=0)throw new Error(Dw());let b=0,v=1,w=0,$=r[b];for(;;){let I=0;if(v<o){if(I=r[v],$===I){++v;continue}if($>=I)throw new Error(qA())}if($<0||$>=f)throw new Error(XA($,f));$>w&&x.fill(a,w*c,$*c);for(let N=b;N<v;++N){const E=s[N];if(E<0||E>=l[0])throw new Error(KA(N,s[N],l[0]));for(let D=0;D<c;D++)x[$*c+D]+=n[E*c+D]}if(i)for(let N=0;N<c;N++)x[$*c+N]/=v-b;if(b=v,++v,w=$+1,$=I,v>o)break}return w<f&&x.fill(a,w*c,f*c),[x,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i8=wa(n=>Math.sqrt(n)),a8=qt(Zh,n=>Math.sqrt(n)),o8={kernelName:Zh,backendName:"cpu",kernelFunc:a8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G3=Fn((n,e)=>{const t=n-e;return t*t}),l8=ss(Jh,G3),u8={kernelName:Jh,backendName:"cpu",kernelFunc:l8};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3=wa((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),c8=al(eb,H3),h8={kernelName:eb,backendName:"cpu",kernelFunc:c8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3(n,e,t,s){const r=ft(n,e.dtype);for(let i=0;i<r.size;i++){const a=r.indexToLoc(i),o=new Array(a.length);for(let l=0;l<o.length;l++)o[l]=a[l]*t[l]+s[l];r.set(e.get(...o),...a)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d8{constructor(e,t,s,r,i,a){this.separator=Ha(e),this.nGramWidths=t,this.leftPad=Ha(s),this.rightPad=Ha(r),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,a){for(let o=0;o<i;++o){const l=this.getPadWidth(a),c=Math.max(0,l-o),d=Math.max(0,l-(i-(o+1))),f=a-(c+d),p=t+(c>0?0:o-l);let g=0;g+=c*this.leftPad.length;for(let $=0;$<f;++$)g+=e[p+$].length;g+=d*this.rightPad.length;const x=c+d+f-1;g+=x*this.separator.length,s[r+o]=new Uint8Array(g);const b=s[r+o];let v=0;const w=$=>$.forEach(I=>b[v++]=I);for(let $=0;$<c;++$)w(this.leftPad),w(this.separator);for(let $=0;$<f-1;++$)w(e[p+$]),w(this.separator);if(f>0){w(e[p+f-1]);for(let $=0;$<d;++$)w(this.separator),w(this.rightPad)}else{for(let $=0;$<d-1;++$)w(this.rightPad),w(this.separator);w(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let d=t[c]>=l;if(d=d&&t[c]<=s,!d)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${s}]`);l=t[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,a=kn("int32",r);if(s===0||r===0){const l=new Array(s);for(let c=0;c<=i;++c)a[c]=0;return[l,a]}a[0]=0;for(let l=1;l<=i;++l){const c=t[l]-t[l-1];let d=0;this.nGramWidths.forEach(f=>{d+=this.getNumNGrams(c,f)}),this.preserveShort&&c>0&&d===0&&(d=1),a[l]=a[l-1]+d}const o=new Array(a[i]);for(let l=0;l<i;++l){const c=t[l];let d=a[l];if(this.nGramWidths.forEach(f=>{const p=t[l+1]-t[l],g=this.getNumNGrams(p,f);this.createNGrams(e,c,o,d,g,f),d+=g}),this.preserveShort&&d===a[l]){const f=t[l+1]-t[l];if(f===0)continue;const p=f+2*this.padWidth;this.createNGrams(e,c,o,d,1,p)}}return[o,a]}}function q3(n,e,t,s,r,i,a,o){return new d8(t,s,r,i,a,o).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f8(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let a=n.indexOf(i);for(;a!==-1;){const o=n.subarray(0,a);(!t||o.length!==0)&&s.push(o),n=n.subarray(a+1),a=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const a=n.subarray(r,i);(!t||a.length!==0)&&s.push(a),r=i+1}}function X3(n,e,t){const s=n.length,r=[];let i=0,a=0;const o=new Array(s);for(let p=0;p<s;++p){const g=r.length;f8(n[p],e,t,r);const x=r.length-g;o[p]=x,i+=x,a=Math.max(a,x)}const l=kn("int32",i*2),c=new Array(i),d=[s,a];let f=0;for(let p=0;p<s;++p)for(let g=0;g<o[p];++g)l[f*2]=p,l[f*2+1]=g,c[f]=r[f],++f;return[l,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K3(n,e){const t=kn("int32",n.length);for(let s=0;s<n.length;++s)t[s]=wP(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y3=Fn((n,e)=>n-e),p8=IS((n,e,t,s)=>({real:n-t,imag:e-s})),DS=ss(ed,Y3,p8),m8={kernelName:ed,backendName:"cpu",kernelFunc:DS};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=ft(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),a=new Array(n.rank);for(let l=0;l<a.length;l++)a[l]=i[l]%n.shape[l];const o=n.locToIndex(a);s.values[r]=n.values[o]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Of=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function Z3(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const o=s-t+1,l=e-t+1,c=Math.log(o),d=.5*Math.exp(2*c/3),f=.5*Math.sqrt(c*d*(o-d)/o)*Math.sign(l-o/2),p=Math.max(t,Math.floor(e-l*d/o+f)),g=Math.min(s,Math.floor(e+(o-l)*d/o+f));Z3(n,e,p,g)}const r=n[e];let i=t,a=s;for(Lc(n,t,e),Of(n[s],r)>0&&Lc(n,t,s);i<a;){for(Lc(n,i,a),i++,a--;Of(n[i],r)<0;)i=i+1;for(;Of(n[a],r)>0;)a=a-1}Of(n[t],r)===0?Lc(n,t,a):(a=a+1,Lc(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function J3(n,e,t,s,r){const i=e[e.length-1],[a,o]=[n.length/i,i],l=es(t,a*s),c=es("int32",a*s);for(let f=0;f<a;f++){const p=f*o,g=n.subarray(p,p+o);let x=new Array(g.length);g.forEach(($,I)=>x[I]={value:$,index:I}),s<x.length&&(Z3(x,s),x=x.slice(0,s)),r&&x.sort(Of);const b=f*s,v=l.subarray(b,b+s),w=c.subarray(b,b+s);for(let $=0;$<s;$++)v[$]=x[$].value,w[$]=x[$].index}const d=e.slice();return d[d.length-1]=s,[ft(d,t,l),ft(d,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eD(n,e,t,s){const r=pt(e,t)[0],i=[1,t[0],1];for(let x=0;x<r;x++)i[0]*=t[x];i[1]=t[r];for(let x=r+1;x<t.length;x++)i[2]*=t[x];const a=new Map,o=new Int32Array(t[r]),l=new Qn(i,s,n),c=[],d=i[0]===1&&i[2]===1;for(let x=0;x<t[r];x++){let b;if(d)b=n[x].toString();else{const w=[];for(let $=0;$<i[0];$++)for(let I=0;I<i[2];I++)w.push(l.get($,x,I));b=w.join(",")}const v=a.get(b);if(v!=null)o[x]=v;else{const w=a.size;a.set(b,w),o[x]=w,c.push(x)}}const f=i.slice();f[1]=a.size;const p=new Qn(f,s);c.forEach((x,b)=>{for(let v=0;v<i[0];v++)for(let w=0;w<i[2];w++)p.set(l.get(v,x,w),v,b,w)});const g=t.slice();return g[r]=f[1],{outputValues:p.values,outputShape:g,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD=Object.freeze(Object.defineProperty({__proto__:null,addImpl:u3,bincountImpl:TS,bincountReduceImpl:c3,bitwiseAndImpl:h3,castImpl:l3,ceilImpl:d3,concatImpl:f3,equalImpl:p3,expImpl:g3,expm1Impl:x3,floorDivImpl:v3,floorImpl:b3,gatherNdImpl:w3,gatherV2Impl:S3,greaterEqualImpl:$3,greaterImpl:C3,lessEqualImpl:N3,lessImpl:k3,linSpaceImpl:I3,logImpl:T3,maxImpl:E3,maximumImpl:R3,minimumImpl:A3,multiplyImpl:ES,negImpl:D3,notEqualImpl:_3,prodImpl:O3,raggedGatherImpl:F3,raggedRangeImpl:z3,raggedTensorToTensorImpl:L3,rangeImpl:P3,rsqrtImpl:M3,scatterImpl:Ql,sigmoidImpl:n8,simpleAbsImpl:o3,sliceImpl:V3,sparseFillEmptyRowsImpl:U3,sparseReshapeImpl:W3,sparseSegmentReductionImpl:AS,sqrtImpl:i8,squaredDifferenceImpl:G3,staticRegexReplaceImpl:H3,stridedSliceImpl:j3,stringNGramsImpl:q3,stringSplitImpl:X3,stringToHashBucketFastImpl:K3,subImpl:Y3,tileImpl:Q3,topKImpl:J3,transposeImpl:RS,uniqueImpl:eD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:g8,castImpl:y8,ceilImpl:x8,concatImpl:b8,equalImpl:v8,expImpl:w8,expm1Impl:S8,floorImpl:C8,floorDivImpl:$8,gatherNdImpl:k8,gatherV2Impl:N8,greaterEqualImpl:I8,greaterImpl:T8,lessEqualImpl:E8,lessImpl:R8,logImpl:A8,maxImpl:D8,maximumImpl:_8,minimumImpl:O8,multiplyImpl:F8,negImpl:z8,notEqualImpl:L8,prodImpl:P8,rangeImpl:M8,rsqrtImpl:B8,scatterImpl:V8,simpleAbsImpl:U8,sliceImpl:W8,stridedSliceImpl:G8,stringNGramsImpl:H8,subImpl:j8,tileImpl:q8,topKImpl:X8,transposeImpl:K8}=tD;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y8=Ot({opType:Ae.ABS,cpuKernelImpl:U8}),Q8={kernelName:up,backendName:"webgpu",kernelFunc:Y8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z8=Ot({opType:Ae.ACOS}),J8={kernelName:ch,backendName:"webgpu",kernelFunc:Z8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eX=Ot({opType:Ae.ACOSH}),tX={kernelName:hh,backendName:"webgpu",kernelFunc:eX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nX=fs({opType:ut.ADD,cpuKernelImpl:g8,supportsComplex:!0}),sX={kernelName:vu,backendName:"webgpu",kernelFunc:nX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rX=class{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const t=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${_e("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iX(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return kr({inputs:{x:s[0]},backend:t});const r=s.map(o=>o.dtype).reduce((o,l)=>ds(o,l)),i=s.map(o=>o.shape),a=new rX(i);return t.runWebGPUProgram(a,s,r)}const aX={kernelName:cp,backendName:"webgpu",kernelFunc:iX};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oX{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){B(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${_e()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lX=class{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=_n(this.outputShape.length),t=nD(this.newDim);return`
      ${_e("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}};function nD(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let s=0;s<n.length;s++)t[n[s]]=`coords.${qa(s)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,a=t,o=r.shape.length,l=new Array(o);for(let d=0;d<l.length;d++)l[d]=r.shape[i[d]];if(t.shouldExecuteOnCPU([r])){const f=a.tensorMap.get(r.dataId).values,p=K8(f,r.shape,r.dtype,i,l);return t.makeTensorInfo(l,r.dtype,p)}if(r.shape.length===2&&yt(i,[1,0])){const d=new oX(r.shape,i);return a.runWebGPUProgram(d,[r],r.dtype)}const c=new lX(r.shape,i);return a.runWebGPUProgram(c,[r],r.dtype)}const uX={kernelName:Jl,backendName:"webgpu",kernelFunc:ma};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cX=class{constructor(e,t,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=On(this.inputShape,[1]);this.outputShape=r.length===0?[1]:r,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${_e("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${r}
        }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hX={mean:"float32",all:"bool",any:"bool"};function Eu(n,e,t,s,r){const i=n.shape.length,a=[],o=pt(e,n.shape);let l=o;const c=Zt(l,i);let d=n;c!=null&&(d=ma({inputs:{x:n},attrs:{perm:c},backend:r}),l=cn(l.length,i),a.push(d)),Gn(s,l,i);const[f,p]=On(d.shape,l);let g=f;t&&(g=In(f,o));let x;if((s==="max"||s==="prod")&&r.shouldExecuteOnCPU([d])){const b=r.tensorMap.get(d.dataId).values;switch(s){case"max":const v=D8(b,ue(p),g,n.dtype);x=r.makeTensorInfo(g,n.dtype,v);break;case"prod":const{outVals:w,outShape:$,outDtype:I}=P8(d.shape,d.dtype,b,l);x=r.makeTensorInfo($,I,w);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const b=ue(p),w=ue(d.shape)/b,$={windowSize:b,inSize:b,batchSize:w,outSize:1},I=hX[s]||ob(n.dtype),N=[{type:"int32",data:[b]}],E=new cX($,s,r.device.limits.maxComputeWorkgroupSizeX),D=r.runWebGPUProgram(E,[d],I,N);a.push(D),x=He({inputs:{x:D},attrs:{shape:g},backend:r})}return a.forEach(b=>r.disposeData(b.dataId)),x}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:a}=s;return Eu(r,a,i,"all",t)}const fX={kernelName:ux,backendName:"webgpu",kernelFunc:dX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:a}=s;return Eu(r,a,i,"any",t)}const mX={kernelName:cx,backendName:"webgpu",kernelFunc:pX};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sD=class{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op=s==="min"?"<":">";const[i,a]=On(e,r);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=Be(this.outputShape),ue(a)<32?(this.type="plain",this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Oe(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${qa(this.inputShape.length-1)}`,s=()=>{let r="";if(this.outputShape.length===1)this.inputShape.length!==1&&(r+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)r+=`outputCoords.${qa(i)},`;return r};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${_e("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${_e("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=pt(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const c=[];o!=null&&(l=ma({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(l),a=cn(a.length,l.shape.length)),Gn("argMax",[a[0]],l.shape.length);const d=new sD(l.shape,a[0],"max"),f=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=t.runWebGPUProgram(d,[l],"int32",f);return c.forEach(g=>t.disposeData(g.dataId)),p}const yX={kernelName:hp,backendName:"webgpu",kernelFunc:gX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=pt(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const c=[];o!=null&&(l=ma({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(l),a=cn(a.length,l.shape.length)),Gn("argMin",[a[0]],l.shape.length);const d=new sD(l.shape,a[0],"min"),f=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=t.runWebGPUProgram(d,[l],"int32",f);return c.forEach(g=>t.disposeData(g.dataId)),p}const bX={kernelName:dp,backendName:"webgpu",kernelFunc:xX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vX=Ot({opType:Ae.ASIN}),wX={kernelName:dh,backendName:"webgpu",kernelFunc:vX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SX=Ot({opType:Ae.ASINH}),CX={kernelName:fh,backendName:"webgpu",kernelFunc:SX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $X=Ot({opType:Ae.ATAN}),kX={kernelName:ph,backendName:"webgpu",kernelFunc:$X};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NX=fs({opType:ut.ATAN2}),IX={kernelName:gh,backendName:"webgpu",kernelFunc:NX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TX=Ot({opType:Ae.ATANH}),EX={kernelName:mh,backendName:"webgpu",kernelFunc:TX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RX{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zf=class{constructor(e,t,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool2D_${t}_${s}_${r}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}},_S=class{constructor(e,t,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool3D_${t}_${s}_${r}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s;return Eu(r,i,a,"max",t)}const AX={kernelName:Lp,backendName:"webgpu",kernelFunc:rD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:a}=s;return Eu(r,a,i,"mean",t)}const DX={kernelName:Bp,backendName:"webgpu",kernelFunc:iD};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aD(n,e,t,s){if(e.filterWidth===1&&e.filterHeight===1&&yt(e.inShape,e.outShape))return kr({inputs:{x:n},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const a=n.shape.length,o=He({inputs:{x:n},backend:s,attrs:{shape:[n.shape[a-3]*n.shape[a-2],n.shape[a-1]]}});let l;t==="avg"?l=iD({inputs:{x:o},backend:s,attrs:{axis:0,keepDims:!1}}):(B(t==="max",()=>`Invalid pool type ${t}`),l=rD({inputs:{x:o},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const c=He({inputs:{x:l},backend:s,attrs:{shape:e.outShape}});return s.disposeData(o.dataId),s.disposeData(l.dataId),c}let r;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?r=new RX(e):(t==="avg"?r=new Zf(e,"avg"):(B(t==="max",()=>`Invalid pool type ${t}`),r=new Zf(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(r,[n],n.dtype,i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _X(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,d=As(r.shape,i,a,1,o,l);return aD(r,d,"avg",t)}const OX={kernelName:fp,backendName:"webgpu",kernelFunc:_X};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:c}=s,d=[1,1,1],f=jr(r.shape,i,a,d,o,c,l),p=new _S(f,"avg"),g=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return t.runWebGPUProgram(p,[r],r.dtype,g)}const zX={kernelName:pp,backendName:"webgpu",kernelFunc:FX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LX=class{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},PX=class{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MX(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:c,dimRoundingMode:d}=s,f=jr(a.shape,o,l,1,c,d),p=new PX(f),g=1/(f.filterDepth*f.filterHeight*f.filterWidth),x=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"float32",data:[g]}];return t.runWebGPUProgram(p,[r],a.dtype,x)}const BX={kernelName:dx,backendName:"webgpu",kernelFunc:MX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VX(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;i3([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,d=As(a.shape,o,l,1,c),f=new LX(d),p=1/(d.filterHeight*d.filterWidth),g=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[p]}];return t.runWebGPUProgram(f,[r],a.dtype,g)}const UX={kernelName:hx,backendName:"webgpu",kernelFunc:VX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WX(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return n0({a:r,b:i,transposeA:a,transposeB:o,backend:t})}const GX={kernelName:mp,backendName:"webgpu",kernelFunc:WX};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let HX=class{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${_n(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=_n(this.rank),t=jX(this.rank);let s;return this.start.length===1?s=this.outputShape.map((i,a)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((i,a)=>`sourceLoc.${Gw[a]} = uniforms.start.${qa(a)} + coords.${Gw[a]};`),`
      ${_e("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}};const Gw=["x","y","z","w","u","v"];function jX(n){if(n===1)return"sourceLoc";if(n<=6)return Gw.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dd(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s,[o,l]=ym(r,i,a);if(_b(r,o,l),t.shouldExecuteOnCPU([r])||r.dtype==="string"){const f=t.tensorMap.get(r.dataId),p=W8(f.values,o,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,p)}if(ue(l)===0)return t.makeTensorInfo(l,r.dtype,[]);const c=new HX(o,l),d=[{type:"int32",data:o}];return t.runWebGPUProgram(c,[r],r.dtype,d)}const qX={kernelName:nm,backendName:"webgpu",kernelFunc:dd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XX=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;B(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const o=i.reduce(($,I)=>$*I),l=$u(r.shape,i,o),c=ku(l.length,i.length),d=Nu(r.shape,i,o),f=Mb(a,i.length),p=Bb(d,a,i.length),g=[],x=He({inputs:{x:r},backend:t,attrs:{shape:l}}),b=ma({inputs:{x},backend:t,attrs:{perm:c}}),v=He({inputs:{x:b},backend:t,attrs:{shape:d}}),w=dd({inputs:{x:v},backend:t,attrs:{begin:f,size:p}});return g.push(x),g.push(b),g.push(v),g.forEach($=>t.disposeData($.dataId)),w},KX={kernelName:gp,backendName:"webgpu",kernelFunc:XX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YX=`
  fn bincount_write(index: i32, value: f32) {
    ${il("&result[index]","value","float32")}
  }
`,QX=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class oD{constructor(e,t,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?QX:YX}
  ${_e("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=ue(r.shape),c=ue(i.shape)>0,d=[a],f=i.dtype,p=ar({backend:t,attrs:{shape:d,value:0,dtype:f}}),g=new oD([o],c),x=[{type:"int32",data:[a]}],b=c?[r,i]:[r];return t.runWebGPUProgram(g,b,f,x,p)}const JX={kernelName:fx,backendName:"webgpu",kernelFunc:ZX};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eK{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${_e("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tK(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e;if(t.shouldExecuteOnCPU([s,r])){const d=t.tensorMap.get(s.dataId),f=t.tensorMap.get(r.dataId),p=d.values,g=f.values,x=tt(Array.from(p),Array.from(g));return t.makeTensorInfo([x.length],"int32",Int32Array.from(x))}const i=ue(s.shape),a=ue(r.shape),o=Math.max(i,a),l=new eK(o),c=[{type:"int32",data:[i]},{type:"int32",data:[a]}];return t.runWebGPUProgram(l,[s,r],"int32",c)}const nK={kernelName:mx,backendName:"webgpu",kernelFunc:tK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lD=fs({opType:ut.NOT_EQUAL,dtype:"bool",cpuKernelImpl:L8}),sK={kernelName:Gp,backendName:"webgpu",kernelFunc:lD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vm(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.tensorMap.get(s.dataId);return kr({inputs:{x:r.complexTensorInfos.real},backend:t})}const rK={kernelName:Gx,backendName:"webgpu",kernelFunc:vm};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iK(n,e){const t=new hd(n.shape,Ae.TO_INT),s=e.runWebGPUProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return kr({inputs:{x:r},backend:t});const a=Dn(r.shape),o=Hw({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=Tu({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeData(o.dataId),l}if(r.dtype==="complex64"){const a=vm({inputs:{input:r},backend:t}),o=Hw({inputs:{x:a},backend:t,attrs:{dtype:i}});return t.disposeData(a.dataId),o}if(!g2(r.dtype,i)){const a=kr({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const a=t.tensorMap.get(r.dataId).values,[o,l,c]=y8(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,l,c)}if(i==="int32")return iK(r,t);if(i==="bool"){const a=t.makeTensorInfo([],"bool",es("bool",1)),l=lD({inputs:{a:r,b:a},backend:t});return t.disposeData(a.dataId),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const aK={kernelName:yh,backendName:"webgpu",kernelFunc:Hw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oK=Ot({opType:Ae.CEIL,cpuKernelImpl:x8}),lK={kernelName:xh,backendName:"webgpu",kernelFunc:oK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uK{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${_e("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cK=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${_e("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;const l=[{type:"float32",data:[i]},{type:"float32",data:[a]}];return ue(r.shape)%4===0?o=new uK(r.shape):o=new cK(r.shape),t.runWebGPUProgram(o,[r],r.dtype,l)}const dK={kernelName:bh,backendName:"webgpu",kernelFunc:hK};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fK=class{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _I(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function pK(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.tensorMap.get(s.dataId),i=new fK(s.shape),a=[_I(s,r.complexTensorInfos.real),_I(s,r.complexTensorInfos.imag)];return t.runWebGPUProgram(i,a,a[0].dtype)}const mK={kernelName:yp,backendName:"webgpu",kernelFunc:pK};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gK=class{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=ir(e,1),this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const s=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${_e("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.tensorMap.get(s.dataId);return kr({inputs:{x:r.complexTensorInfos.imag},backend:t})}const yK={kernelName:Ox,backendName:"webgpu",kernelFunc:r0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ff(n,e,t){const s=n[0].dtype;if(s==="complex64"){const x=n.map(I=>vm({inputs:{input:I},backend:t})),b=n.map(I=>r0({inputs:{input:I},backend:t})),v=Ff(x,e,t),w=Ff(b,e,t),$=Tu({inputs:{real:v,imag:w},backend:t});return x.forEach(I=>t.disposeData(I.dataId)),b.forEach(I=>t.disposeData(I.dataId)),t.disposeData(v.dataId),t.disposeData(w.dataId),$}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const x=n.map(E=>{const O=[-1,ue(E.shape.slice(e))];return He({inputs:{x:E},backend:t,attrs:{shape:O}})}),b=x.map(E=>({vals:t.readSync(E.dataId),shape:E.shape})),v=ir(x.map(E=>E.shape),1),w=x[0].shape[0]===1,$=b8(b,v,s,w),I=ir(n.map(E=>E.shape),e),N=t.makeTensorInfo(I,s,$);return x.forEach(E=>t.disposeData(E.dataId)),N}const i=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>i){const x=[];for(let v=0;v<n.length;v+=i){const w=n.slice(v,v+i);x.push(Ff(w,e,t))}const b=Ff(x,e,t);for(const v of x)t.disposeData(v.dataId);return b}const{tensors2D:a,outShape:o}=xK(n,e,t),l=a.map(x=>x.shape),c=new gK(l),d=[],f=new Array(l.length-1);if(f.length>0){f[0]=l[0][1],d.push({type:"int32",data:[f[0]]});for(let x=1;x<f.length;x++)f[x]=f[x-1]+l[x][1],d.push({type:"int32",data:[f[x]]})}const p=t.runWebGPUProgram(c,a,a[0].dtype,d);a.forEach(x=>t.disposeData(x.dataId));const g=He({inputs:{x:p},backend:t,attrs:{shape:o}});return t.disposeData(p.dataId),g}function xK(n,e,t){const s=ir(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>He({inputs:{x:i},backend:t,attrs:{shape:[ue(i.shape.slice(0,e)),ue(i.shape.slice(e))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=pt(r,e[0].shape)[0],a=e.map(c=>c.shape);zb(a,i);const o=ir(e.map(c=>c.shape),i);if(ue(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(c=>ue(c.shape)>0);return l.length===1?kr({inputs:{x:l[0]},backend:t}):Ff(l,i,t)}const bK={kernelName:xp,backendName:"webgpu",kernelFunc:uD};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vK(n,e,t,s,r=!1,i=null,a=!1,o=4,l=4,c=4){const d=z=>{switch(z){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},f=z=>{switch(z){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},p=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,g=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,x=n?"uniforms.xShape[1]":"uniforms.xShape[2]",b=n?"uniforms.xShape[2]":"uniforms.xShape[3]",v=n?"row":"col",w=n?"col":"row",$=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${v} / outWidth;
      let outCol = ${v} % outWidth;

      let WRow = ${w} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${w} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${w} % inChannels;
      var resData = ${xt(o)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${x} && xCol >= 0 && xCol < ${b}) {
        ${p}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${d(o)}
      }
      return resData;`,I=n?e&&s?`
      ${$}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${$}
      }
      return ${xt(o)}(0.0);`:s&&t?`
      ${$}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${$}
      }
      return ${xt(o)}(0.0);`,N=`${f(l)}`,E=xt(c),D=xt(n?o:l),O=xt(n?l:o);return`
      ${eo(i,a,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${D} {
        ${n?I:N}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${O} {
        ${n?N:I}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${E}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${g}
        ${Iu(r,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class wK{constructor(e,t,s,r,i=!1,a=null,o=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=n3(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=s3(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),o&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=i,this.activation=a,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=r%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?e0(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):t0(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${vK(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SK{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=s,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${eo(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Iu(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${_e("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CK{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${_e("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${r};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uy(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function $K({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const l=t.dataFormat==="channelsLast",c=!l,d=!1,f=l&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",p=[];let g,x;if(f){const w=t.inHeight*t.inWidth*t.inChannels;g=He({inputs:{x:n},backend:s,attrs:{shape:[1,t.batchSize,w]}}),x=He({inputs:{x:e},backend:s,attrs:{shape:[1,w,t.outChannels]}})}else g=He({inputs:{x:n},backend:s,attrs:{shape:l?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),x=He({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(p.push(g),p.push(x),i!=null){const w=Uy(i.shape,l);w!=null&&(i=He({inputs:{x:i},backend:s,attrs:{shape:w}}),p.push(i))}if(r!=null){const w=Uy(r.shape,l);w!=null&&(r=He({inputs:{x:r},backend:s,attrs:{shape:w}}),p.push(r))}const b=n0({a:l?g:x,b:l?x:g,transposeA:c,transposeB:d,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),v=He({inputs:{x:b},backend:s,attrs:{shape:t.outShape}});p.push(b);for(const w of p)s.disposeData(w.dataId);return v}function kK({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:c,inChannels:d,strideWidth:f,strideHeight:p,padInfo:g,outWidth:x,outHeight:b,dilationWidth:v,dilationHeight:w,dataFormat:$}=t,I=$==="channelsLast",N=l*c*d,E=b*x,D=I?[t.batchSize,E,N]:[t.batchSize,N,E],O=new CK(D,I),L=[{type:"int32",data:[g.top,g.left]},{type:"int32",data:[p,f]},{type:"int32",data:[w,v]},{type:"int32",data:[x]},{type:"int32",data:[d*l]},{type:"int32",data:[d]}],z=s.runWebGPUProgram(O,[n],n.dtype,L),P=[];P.push(z);const _=He({inputs:{x:e},backend:s,attrs:{shape:[1,N,-1]}});if(P.push(_),i!=null){const G=Uy(i.shape,I);G!=null&&(i=He({inputs:{x:i},backend:s,attrs:{shape:G}}),P.push(i))}if(r!=null){const G=Uy(r.shape,I);G!=null&&(r=He({inputs:{x:r},backend:s,attrs:{shape:G}}),P.push(r))}const ee=n0({a:I?z:_,b:I?_:z,transposeA:!I,transposeB:!1,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),Y=He({inputs:{x:ee},backend:s,attrs:{shape:t.outShape}});P.push(ee);for(const G of P)s.disposeData(G.dataId);return Y}function cD({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const l=r!=null,c=i!=null,d=t.dataFormat==="channelsLast",f=d&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",p=fe().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(f||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return $K({x:n,filter:e,convInfo:t,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});const g=fe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),x=g>-1?g:s.thresholdToIncreaseWorkgroups,b=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(fe().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||b<=x)return kK({x:n,filter:e,convInfo:t,backend:s,bias:r,preluActivationWeights:i,leakyreluAlpha:a,activation:o});let v;const w=[t.padInfo.top,t.padInfo.left],$=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...w]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(p)v=new SK(t,l,o,c);else{const D=d?t.outHeight*t.outWidth:t.outChannels,O=d?t.outChannels:t.outHeight*t.outWidth,L=t.filterHeight*t.filterWidth*t.inChannels;$.push({type:"int32",data:[D]},{type:"int32",data:[O]},{type:"int32",data:[L]});const z=s.adapterInfo.isIntel();v=new wK(t,D,O,L,l,o,c,z)}const I=[],N=[n,e];l&&(!d&&r.shape.length===1&&(r=He({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),I.push(r)),N.push(r)),c&&(!d&&i.shape.length===1&&(i=He({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),I.push(i)),N.push(i)),o==="leakyrelu"&&($.push({type:"float32",data:[a]}),v.uniforms+=" alpha : f32,");const E=s.runWebGPUProgram(v,N,n.dtype,$);for(const D of I)s.disposeData(D.dataId);return E}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NK(n){const{inputs:e,attrs:t,backend:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:d}=t,f=Tr(l),p=un(r.shape,i.shape,a,c,o,d,!1,f);return cD({x:r,filter:i,convInfo:p,backend:s})}const IK={kernelName:bp,backendName:"webgpu",kernelFunc:NK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TK=class{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,r=`
    ${_e()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${r}
    `:`
    ${_e("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},EK=class{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${_e("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},RK=class{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${_e("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},AK=class{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${_e("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:d}=s,f=Tr(l),p=un(r.shape,d,a,1,o,c,!1,f),g=new EK(p),x=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return t.runWebGPUProgram(g,[r,i],r.dtype,x)}const _K={kernelName:yx,backendName:"webgpu",kernelFunc:DK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OK(n=4){const e=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${xt(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${xt(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${xt(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${xt(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${xt(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${xt(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${xt(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class FK{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,B(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=n3(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=s3(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?e0(this.elementsPerThread,this.workgroupSize):t0(this.elementsPerThread,this.workgroupSize);return`
    ${OK(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:d}=s,f=Tr(c),p=un(a,i.shape,o,1,l,d,!1,f),g=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let x;if(fe().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||p.dataFormat!=="channelsLast")x=new TK(p);else{x=new FK(p);const b=p.inHeight*p.inWidth,v=p.inChannels,w=p.filterHeight*p.filterWidth*p.outChannels;g.push({type:"uint32",data:[b]},{type:"uint32",data:[v]},{type:"uint32",data:[w]})}return t.runWebGPUProgram(x,[r,i],"float32",g)}const LK={kernelName:vp,backendName:"webgpu",kernelFunc:zK};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PK{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,c=Wi(r.shape,i.shape,a,l,o),d=[c.padInfo.front,c.padInfo.top,c.padInfo.left],f=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],p=new PK(c),g=ds(r.dtype,i.dtype);return t.runWebGPUProgram(p,[r,i],g,f)}const BK={kernelName:wp,backendName:"webgpu",kernelFunc:MK};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s,c=Wi(r.shape,l,a,1,o),d=new RK(c),f=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return t.runWebGPUProgram(d,[r,i],i.dtype,f)}const UK={kernelName:xx,backendName:"webgpu",kernelFunc:VK};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WK(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,pad:o,inputShape:l}=s,c=Wi(l,i.shape,a,1,o),d=new AK(c),f=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return t.runWebGPUProgram(d,[r,i],r.dtype,f)}const GK={kernelName:bx,backendName:"webgpu",kernelFunc:WK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HK=Ot({opType:Ae.COS}),jK={kernelName:vh,backendName:"webgpu",kernelFunc:HK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qK=Ot({opType:Ae.COSH}),XK={kernelName:wh,backendName:"webgpu",kernelFunc:qK};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KK=class{constructor(e,t,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,s[0],s[1],e],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=r==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,o,l]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r};
        let width_scale = ${o};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YK=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:c}=s,d=new KK(r.shape[3],i.shape,o,l),f=[{type:"float32",data:[c]}];return t.runWebGPUProgram(d,[r,i,a],"float32",f)},QK={kernelName:wx,backendName:"webgpu",kernelFunc:YK};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Jf;(function(n){n.Prod="*",n.Sum="+"})(Jf||(Jf={}));let OI=class{constructor(e,t,s,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Jf.Prod?"1.0":"0.0",s=this.exclusive?t:`getX(${FI(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",a="";return this.exclusive?(i=this.reverse?`end != ${r-1}`:"end != 0",a=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${r}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`
      ${_e("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${zI(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${a};
           ${zI(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${FI(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function FI(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function zI(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(n,e,t,s,r,i){const a=e.shape.length,o=Zt([s],a);let l=e;o!=null&&(l=ma({inputs:{x:e},backend:t,attrs:{perm:o}}));const c=cn(1,a)[0];if(c!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=l.shape[c];let f=kr({inputs:{x:l},backend:t});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const g=new OI(n,l.shape,!1,i),x=f,b=[{type:"float32",data:[p]}];f=t.runWebGPUProgram(g,[f],f.dtype,b),t.disposeData(x.dataId)}if(r){const p=new OI(n,l.shape,r,i),g=f,x=[{type:"float32",data:[0]}];f=t.runWebGPUProgram(p,[f],f.dtype,x),t.disposeData(g.dataId)}if(o!=null){const p=xa(o),g=ma({inputs:{x:f},backend:t,attrs:{perm:p}});return t.disposeData(f.dataId),t.disposeData(l.dataId),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return hD(Jf.Prod,r,t,i,a,o)}const JK={kernelName:vx,backendName:"webgpu",kernelFunc:ZK};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return hD(Jf.Sum,r,t,i,a,o)}const t7={kernelName:Sp,backendName:"webgpu",kernelFunc:e7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s,l=r.shape.length===1,d=ue(i.shape)>0,f=i.dtype,p=l?[r.shape[0]]:[r.shape[0],r.shape[1]],g=l?[a]:[r.shape[0],a],x=ar({backend:t,attrs:{shape:g,value:0,dtype:f}}),b=new oD(p,d,o),v=[{type:"int32",data:[a]}],w=d?[r,i]:[r];return t.runWebGPUProgram(b,w,f,v,x)}const s7={kernelName:Sx,backendName:"webgpu",kernelFunc:n7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let r7=class{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s,o=r.shape[0],l=a==="NHWC"?r.shape[1]:r.shape[2],c=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],f=l*i,p=c*i,g=d/(i*i),x=a==="NHWC"?[o,f,p,g]:[o,g,f,p],b=[{type:"int32",data:[i]}],v=new r7(x,a);return t.runWebGPUProgram(v,[r],r.dtype,b)}const a7={kernelName:Cx,backendName:"webgpu",kernelFunc:i7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o7{constructor(e,t,s,r=!1,i=null,a=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`
      ${eo(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${_e()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Iu(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dD{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Be(i),this.dispatch=Oe(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),B(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${eo(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${_e("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Iu(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fD=class{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${eo(this.activation,this.hasPreluActivation,!1,4)}

      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Iu(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:d}=s,f=Tr(l);let p=c;p==null&&(p=[1,1]);const g=un(r.shape,i.shape,a,p,o,d,!0,f),x=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}],b=g.dataFormat==="channelsLast";let v;return!b&&g.inHeight>16&&g.inWidth>16&&g.strideHeight===1&&g.strideWidth===1&&g.dilationWidth===1&&g.dilationHeight===1&&g.inChannels===g.outChannels?v=new o7(g.outShape,g.filterHeight,g.filterWidth):b&&g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(v=new dD(g),x.push({type:"int32",data:[v.virtualWidth]})):(v=new fD(g),x.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),t.runWebGPUProgram(v,[r,i],r.dtype,x)}const u7={kernelName:Cp,backendName:"webgpu",kernelFunc:l7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let c7=class{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},h7=class{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:d}=s,f=un(r.shape,d,a,o,l,c,!0),p=new c7(f),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outChannels/f.inChannels]}];return t.runWebGPUProgram(p,[r,i],"float32",g)}const f7={kernelName:$x,backendName:"webgpu",kernelFunc:d7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p7(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:d}=s,f=un(d,i.shape,a,o,l,c,!0),p=new h7(f),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.outChannels/f.inChannels]}];return t.runWebGPUProgram(p,[r,i],r.dtype,g)}const m7={kernelName:kx,backendName:"webgpu",kernelFunc:p7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let g7=class{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y7(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=ue(s.shape),a=He({inputs:{x:s},backend:t,attrs:{shape:[i]}}),o=new g7(i),l=t.runWebGPUProgram(o,[a],a.dtype),c=He({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeData(a.dataId),t.disposeData(l.dataId),c}const x7={kernelName:Nx,backendName:"webgpu",kernelFunc:y7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let b7=class{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${_e("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,c=nl(r.shape,i.shape,a,o,"NHWC",l),d=[c.padInfo.top,c.padInfo.left],f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],p=new b7(c);return t.runWebGPUProgram(p,[r,i],r.dtype,f)}const w7={kernelName:$p,backendName:"webgpu",kernelFunc:v7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S7{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Be(e.outShape),this.dispatch=Oe(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${_e("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${il("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class C7{constructor(e,t,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Be(e.outShape),this.dispatch=Oe(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${_e("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${il("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,dy:a}=e,{strides:o,pad:l,dilations:c}=s,d=nl(r.shape,i.shape,o,l,"NHWC",c),f=i.dtype,p=new C7(d,i.shape,f),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[ue(d.outShape)]}],x=ar({backend:t,attrs:{shape:i.shape,value:0,dtype:f}});return t.runWebGPUProgram(p,[r,i,a],f,g,x)}const k7={kernelName:Ey,backendName:"webgpu",kernelFunc:$7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,dy:a}=e,{strides:o,pad:l,dilations:c}=s,d=nl(r.shape,i.shape,o,l,"NHWC",c),f=r.dtype,p=new S7(d,f),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[ue(d.outShape)]}],x=ar({backend:t,attrs:{shape:d.inShape,value:0,dtype:f}});return t.runWebGPUProgram(p,[r,i,a],f,g,x)}const I7={kernelName:Ty,backendName:"webgpu",kernelFunc:N7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T7{constructor(e,t,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Jc.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=s,this.shaderKey=`draw_${t}_${s}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${_e("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E7(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:a}=s,[o,l]=r.shape.slice(0,2),{imageOptions:c}=a||{},d=c?.alpha||1,f=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[o,l],g=new T7(p,r.dtype,f);i.width=l,i.height=o;const x="webgpu";let b=i.getContext(x),v;b||(v=new OffscreenCanvas(l,o),b=v.getContext(x));const w=r.shape.length===3?r.shape[2]:1;b.configure({device:t.device,format:f,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const $="int32",I=t.makeTensorInfo(p,$),N=t.tensorMap.get(I.dataId);N.resource=b.getCurrentTexture(),N.external=!0;const E=[{type:"uint32",data:[w]},{type:"float32",data:[d]}];if(t.runWebGPUProgram(g,[r],$,E,I),v){const D=i.getContext("2d");if(!D)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");D.drawImage(v,0,0)}return t.disposeData(I.dataId),r}const R7={kernelName:b2,backendName:"webgpu",kernelFunc:E7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pD=fs({opType:ut.MUL,cpuKernelImpl:F8,supportsComplex:!0}),A7={kernelName:Mh,backendName:"webgpu",kernelFunc:pD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return Eu(r,i,a,"sum",t)}const D7={kernelName:sm,backendName:"webgpu",kernelFunc:mD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:l}=qb(r,i.length);Kb(a.length,l,i);const{path:c,steps:d}=Yb(o,l),f=d.length;let p=null,g=a.length;const x=[];for(let b=0;b<f;++b){for(const v of d[b]){const{permutationIndices:w,expandDims:$}=Xb(g,l[v]);let I;Qb(w)?I=i[v]:(I=ma({inputs:{x:i[v]},backend:t,attrs:{perm:w}}),x.push(I));const N=I.shape.slice();for(let E=0;E<$.length;++E)N.splice($[E],0,1);yt(I.shape,N)||(I=He({inputs:{x:I},backend:t,attrs:{shape:N}}),x.push(I)),p===null?p=I:(p=pD({inputs:{a:I,b:p},backend:t}),x.push(p))}b<f-1&&(c[b]>=0&&(p=mD({inputs:{x:p},backend:t,attrs:{axis:c[b]-(a.length-g),keepDims:!1}}),x.push(p)),g--)}for(const b of x)b!==p&&t.disposeData(b.dataId);return p}const O7={kernelName:Ix,backendName:"webgpu",kernelFunc:_7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F7=Ot({opType:Ae.ELU}),z7={kernelName:Ch,backendName:"webgpu",kernelFunc:F7};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L7=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=new My(ut.ELU_DER,s.shape,r.shape);return t.runWebGPUProgram(i,[s,r],s.dtype)},P7={kernelName:Tx,backendName:"webgpu",kernelFunc:L7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M7=fs({opType:ut.EQUAL,dtype:"bool",cpuKernelImpl:v8}),B7={kernelName:kp,backendName:"webgpu",kernelFunc:M7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V7=Ot({opType:Ae.ERF}),U7={kernelName:$h,backendName:"webgpu",kernelFunc:V7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W7=Ot({opType:Ae.EXP,cpuKernelImpl:w8,dtype:"float32"}),G7={kernelName:kh,backendName:"webgpu",kernelFunc:W7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,a=i.shape.length,o=i.shape.slice();let l=r;return r<0&&(B(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),o.splice(l,0,1),He({inputs:{x:i},backend:s,attrs:{shape:o}})}const H7={kernelName:Np,backendName:"webgpu",kernelFunc:jw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j7=Ot({opType:Ae.EXPM1,cpuKernelImpl:S8}),q7={kernelName:Nh,backendName:"webgpu",kernelFunc:j7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LI=class{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gD(n,e,t){const s=t.tensorMap.get(n.dataId),r=ue(n.shape),i=n.shape[n.shape.length-1],a=r/i,o=[],l=He({inputs:{x:n},backend:t,attrs:{shape:[a,i]}});o.push(l);const c=l.shape,d=new LI("real",c),f=new LI("imag",c),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],g=e?2*Math.PI:-2*Math.PI,x=e?c[1]:1,b=[{type:"float32",data:[g]},{type:"float32",data:[x]}],v=t.runWebGPUProgram(d,p,"float32",b);o.push(v);const w=t.runWebGPUProgram(f,p,"float32",b);o.push(w);const $=Tu({inputs:{real:v,imag:w},backend:t});o.push($);const I=He({inputs:{x:$},backend:t,attrs:{shape:n.shape}});return o.forEach(N=>t.disposeData(N.dataId)),I}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X7(n){const{inputs:e,backend:t}=n,{input:s}=e;return gD(s,!1,t)}const K7={kernelName:Ex,backendName:"webgpu",kernelFunc:X7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Y7=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q7={kernelName:Ax,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new Y7(t.shape);return s.runWebGPUProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z7=Ot({opType:Ae.FLOOR,cpuKernelImpl:C8}),J7={kernelName:Ih,backendName:"webgpu",kernelFunc:Z7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eY=fs({opType:ut.FLOOR_DIV,cpuKernelImpl:$8,dtype:"int32"}),tY={kernelName:Th,backendName:"webgpu",kernelFunc:eY};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nY=class{constructor(e,t,s=!1){this.pixelsOpType=Jc.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${_e("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sY={kernelName:Ry,backendName:"webgpu",kernelFunc:rY};let Dc,Gv=fe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function rY(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s;if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,[d,f]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],p=[f,d,i],g=fe().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&a,x=a||o;if(c||l||x){let $;if(g)$=t.device.importExternalTexture({source:r});else{if(x){const q=fe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Dc==null||q!==Gv)&&(Gv=q,Dc=document.createElement("canvas").getContext("2d",{willReadFrequently:Gv})),Dc.canvas.width=d,Dc.canvas.height=f,Dc.drawImage(r,0,0,d,f),r=Dc.canvas}const P=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,H=t.textureManager.acquireTexture(p[1],p[0],"rgba8unorm",P);t.queue.copyExternalImageToTexture({source:r},{texture:H},[p[1],p[0]]),$=H}const I=ue(p),N=Ye(p),E=new nY(p,i,g),D=[{type:"uint32",data:[I]},{type:"uint32",data:[i]},{type:"uint32",data:[...N]}],O=t.makeTensorInfo([f,d],"int32"),L=t.tensorMap.get(O.dataId);L.resource=$;const z=t.runWebGPUProgram(E,[O],"int32",D);return t.disposeData(O.dataId),z}const b=r.data;let v=b;if(i!=null&&i!==4){v=new Uint8Array(r.width*r.height*i);const $=b.length;let I=0;for(let N=0;N<$;N++)N%4<i&&(v[I++]=b[N])}const w=t.makeTensorInfo(p,"int32",new Int32Array(v));return t.uploadToGPU(w.dataId),w}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iY=class{constructor(e,t,s,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],tt(e,t),tt(e,s),this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),r!=null&&(tt(e,r),this.variableNames.push("offset")),i!=null&&(tt(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${_e("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aY={kernelName:Ip,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s,scale:r,offset:i,mean:a,variance:o}=n,{varianceEpsilon:l}=e,c=t,d=[s,a,o];let f=null;i!=null&&(f=i.shape,d.push(i));let p=null;r!=null&&(p=r.shape,d.push(r));const g=new iY(s.shape,a.shape,o.shape,f,p),x=[{type:"float32",data:[l]}];return c.runWebGPUProgram(g,d,s.dtype,x)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:x}=s,b=Tr(d),v=un(r.shape,i.shape,l,f,c,p,!1,b);return cD({x:r,filter:i,convInfo:v,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:x,activation:g})}const lY={kernelName:Uf,backendName:"webgpu",kernelFunc:oY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=s;let x=d;x==null&&(x=[1,1]),B(ns(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const b=un(r.shape,i.shape,l,x,c,f,!0),v=[r,i],w=a!=null,$=o!=null;w&&v.push(a),$&&v.push(o);const I=[{type:"int32",data:[b.padInfo.top,b.padInfo.left]},{type:"int32",data:[b.inHeight,b.inWidth]}];let N;return b.outHeight>4&&b.outWidth>4&&b.strideWidth<=2&&b.inChannels===b.outChannels&&b.dilationHeight===1&&b.dilationWidth===1&&b.inChannels%4===0?(N=new dD(b,w,p,$),I.push({type:"int32",data:[N.virtualWidth]})):(N=new fD(b,w,p,$),I.push({type:"int32",data:[b.filterHeight]},{type:"int32",data:[b.filterWidth]},{type:"int32",data:[b.strideHeight,b.strideWidth]},{type:"int32",data:[b.dilationHeight,b.dilationWidth]})),p==="leakyrelu"&&(I.push({type:"float32",data:[g]}),N.uniforms+=" alpha : f32,"),t.runWebGPUProgram(N,v,"float32",I)}const cY={kernelName:Wf,backendName:"webgpu",kernelFunc:uY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hY=class{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${_n(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dY(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,a=i[i.length-1],o=ue(s.shape),[l,c,d,f]=Db(s,r),p=He({inputs:{x:r},backend:t,attrs:{shape:[c,a]}}),g=He({inputs:{x:s},backend:t,attrs:{shape:[ue(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const $=t.readSync(r.dataId),I=t.bufferSync(s),N=k8($,I,s.dtype,c,a,d,f,s.shape,o);return t.makeTensorInfo(l,s.dtype,N.values)}const x=new hY(a,[c,d]),b=[{type:"int32",data:[a]},{type:"int32",data:f}],v=t.runWebGPUProgram(x,[g,p],g.dtype,b),w=He({inputs:{x:v},backend:t,attrs:{shape:l}});return t.disposeData(p.dataId),t.disposeData(g.dataId),t.disposeData(v.dataId),w}const fY={kernelName:Dx,backendName:"webgpu",kernelFunc:dY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pY=class{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=mY(this.aShape);return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}};function mY(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let s=0;s<n.length;s++)s===2?t.push("indexZ"):t.push(`${e[s]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s,l=pt(a,r.shape)[0],c=Jb(r,i,l,o),d=ue(i.shape),f=[],p=He({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=He({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,d/c.batchSize]}});f.push(p),f.push(g);const x=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([r,i])){const I=t.tensorMap.get(g.dataId).values,N=ft(g.shape,g.dtype,I),D=t.tensorMap.get(p.dataId).values,O=ft(p.shape,p.dtype,D),L=N8(O,N,x);return f.forEach(z=>t.disposeData(z.dataId)),t.makeTensorInfo(c.outputShape,L.dtype,L.values)}const b=new pY(p.shape,x),v=t.runWebGPUProgram(b,[p,g],p.dtype);f.push(v);const w=He({inputs:{x:v},backend:t,attrs:{shape:c.outputShape}});return f.forEach($=>t.disposeData($.dataId)),w}const gY={kernelName:Tp,backendName:"webgpu",kernelFunc:yD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yY=fs({opType:ut.GREATER,cpuKernelImpl:T8,dtype:"bool"}),xY={kernelName:Ep,backendName:"webgpu",kernelFunc:yY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bY=fs({opType:ut.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:I8}),vY={kernelName:Eh,backendName:"webgpu",kernelFunc:bY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wY(n){const{inputs:e,backend:t}=n,{input:s}=e;return gD(s,!0,t)}const SY={kernelName:_x,backendName:"webgpu",kernelFunc:wY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CY=Ot({opType:Ae.IS_FINITE,dtype:"bool"}),$Y={kernelName:Ah,backendName:"webgpu",kernelFunc:CY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kY=Ot({opType:Ae.IS_INF,dtype:"bool"}),NY={kernelName:Dh,backendName:"webgpu",kernelFunc:kY};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IY=Ot({opType:Ae.IS_NAN,dtype:"bool"}),TY={kernelName:_h,backendName:"webgpu",kernelFunc:IY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,a=[{type:"float32",data:[i]}],o=new hd(r.shape,Ae.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(o,[r],"float32",a)}const RY={kernelName:Rp,backendName:"webgpu",kernelFunc:EY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AY=fs({opType:ut.LESS,dtype:"bool",cpuKernelImpl:R8}),DY={kernelName:Ap,backendName:"webgpu",kernelFunc:AY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Y=fs({opType:ut.LESS_EQUAL,dtype:"bool",cpuKernelImpl:E8}),OY={kernelName:Dp,backendName:"webgpu",kernelFunc:_Y};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FY{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zY(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=(r-s)/(i-1),o=new FY(i),l=[{type:"float32",data:[s]},{type:"float32",data:[a]}];return e.runWebGPUProgram(o,[],"float32",l)}const LY={kernelName:Fx,backendName:"webgpu",kernelFunc:zY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PY=Ot({opType:Ae.LOG,cpuKernelImpl:A8}),MY={kernelName:Oh,backendName:"webgpu",kernelFunc:PY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BY=Ot({opType:Ae.LOG1P}),VY={kernelName:Fh,backendName:"webgpu",kernelFunc:BY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UY=fs({opType:ut.LOGICAL_AND,dtype:"bool"}),WY={kernelName:_p,backendName:"webgpu",kernelFunc:UY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GY=Ot({opType:Ae.LOGICAL_NOT}),HY={kernelName:Op,backendName:"webgpu",kernelFunc:GY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jY=fs({opType:ut.LOGICAL_OR}),qY={kernelName:Fp,backendName:"webgpu",kernelFunc:jY};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xD=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;let XY=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${xD}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}};class KY{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,B(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Oe(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${_e()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${xD}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s;let c;i>16?c=new XY(r.shape):c=new KY(r.shape,i);const d=[{type:"int32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[o]},{type:"float32",data:[l]}];return t.runWebGPUProgram(c,[r],r.dtype,d)}const QY={kernelName:zp,backendName:"webgpu",kernelFunc:YY};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ZY=class{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:c,beta:d}=s,f=new ZY(r.shape),p=[{type:"int32",data:[o]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[d]}];return t.runWebGPUProgram(f,[r,i,a],r.dtype,p)}const e9={kernelName:zx,backendName:"webgpu",kernelFunc:JY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t9=fs({opType:ut.MAX,cpuKernelImpl:_8}),n9={kernelName:zh,backendName:"webgpu",kernelFunc:t9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,d=As(r.shape,i,a,1,o,l);return aD(r,d,"max",t)}const r9={kernelName:Pp,backendName:"webgpu",kernelFunc:s9};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:c}=s,d=[1,1,1],f=jr(r.shape,i,a,d,o,c,l),p=new _S(f,"max"),g=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return t.runWebGPUProgram(p,[r],r.dtype,g)}const a9={kernelName:Mp,backendName:"webgpu",kernelFunc:i9};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let o9=class{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},l9=class{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:c,dimRoundingMode:d}=s,f=[1,1,1],p=jr(a.shape,o,l,f,c,d),g=new _S(p,"max",!0);let x=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];const b=t.runWebGPUProgram(g,[a],"int32",x),v=new l9(p);x=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const w=t.runWebGPUProgram(v,[r,b],a.dtype,x);return t.disposeData(b.dataId),w}const c9={kernelName:Px,backendName:"webgpu",kernelFunc:u9};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h9(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;i3([i,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=s,p=As(o.shape,l,c,1,d,f),g=new Zf(p,"max",!0);let x=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];const b=t.runWebGPUProgram(g,[o],"int32",x),v=new o9(p);x=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const w=t.runWebGPUProgram(v,[r,b],o.dtype,x);return t.disposeData(b.dataId),w}const d9={kernelName:Lx,backendName:"webgpu",kernelFunc:h9};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f9(n){const{inputs:e,backend:t,attrs:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=s,{x:l}=e;B(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];B(ns(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=As(l.shape,r,i,c,a),f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];let p=new Zf(d,"max",!1);const g=t.runWebGPUProgram(p,[l],l.dtype,f);p=new Zf(d,"max",!0,!0,o);const x=t.runWebGPUProgram(p,[l],"int32",f);return[g,x]}const p9={kernelName:Mx,backendName:"webgpu",kernelFunc:f9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return Eu(r,i,a,"min",t)}const g9={kernelName:Vp,backendName:"webgpu",kernelFunc:m9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y9=fs({opType:ut.MIN,cpuKernelImpl:O8}),x9={kernelName:Lh,backendName:"webgpu",kernelFunc:y9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let b9=class{constructor(e,t,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,i)=>r[0]+e[i]+r[1]),this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((r,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((c,d)=>`uniforms.pad${d}[0]`).join(","),s=this.xShape.map((c,d)=>`uniforms.pad${d}[0] + uniforms.xShape${e>1?`[${d}]`:""}`).join(","),r=e===1?"start":"start[i]",i=e===1?"end":"end[i]",a=e===1?"outC":"outC[i]",o=_n(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let start = ${o}(${t});
          let end = ${o}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a} < ${r}) {
              ${a} = ${r} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${i}) {
              ${a} = (${i} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v9={kernelName:Up,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{paddings:r,mode:i}=e,a=t,o=r.map(d=>({type:"int32",data:[d[0],d[1]]})),l=new b9(s.shape,r,i);return a.runWebGPUProgram(l,[s],s.dtype,o)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w9=fs({opType:ut.MOD}),S9={kernelName:Ph,backendName:"webgpu",kernelFunc:w9};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let C9=class{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${_e("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $9{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${_e("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bD(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=He({inputs:{x:r},backend:t,attrs:{shape:[ue(r.shape)/r.shape[i],r.shape[i]]}}),o=new $9(a.shape),l=t.runWebGPUProgram(o,[a],r.dtype),c=He({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeData(a.dataId),t.disposeData(l.dataId),c}const k9={kernelName:am,backendName:"webgpu",kernelFunc:bD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N9(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,l=o?r:bD({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=l.shape[0],d=l.shape[1],f=new C9(c,i),p=[{type:"float32",data:[a]},{type:"int32",data:[d]}],g=t.runWebGPUProgram(f,[l],"int32",p);return o||t.disposeData(l.dataId),g}const I9={kernelName:Bx,backendName:"webgpu",kernelFunc:N9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T9(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.tensorMap.get(s.dataId),[a,o]=z8(i.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,a)}const r=new hd(s.shape,Ae.NEG);return t.runWebGPUProgram(r,[s],s.dtype)}const E9={kernelName:Wp,backendName:"webgpu",kernelFunc:T9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R9(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,c=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:f}=Rb(c,d,a,o,l);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const A9={kernelName:Vx,backendName:"webgpu",kernelFunc:R9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D9(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s,d=t.readSync(r.dataId),f=t.readSync(i.dataId),p=a,g=o,x=l,b=c,{selectedIndices:v,selectedScores:w}=Ab(d,f,p,g,x,b);return[t.makeTensorInfo([v.length],"int32",new Int32Array(v)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const _9={kernelName:Ux,backendName:"webgpu",kernelFunc:D9};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let O9=class{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${_e("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F9(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:l}=s,c=ue(r.shape),d=new O9(c,a),f=He({inputs:{x:r},backend:t,attrs:{shape:[c]}}),p=[{type:"float32",data:[o]},{type:"float32",data:[l]}],g=t.runWebGPUProgram(d,[f],i,p);t.disposeData(f.dataId);const x=[...r.shape,a],b=He({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeData(g.dataId),b}const z9={kernelName:jp,backendName:"webgpu",kernelFunc:F9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wy(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=vm({inputs:{input:s},backend:t}),i=Wy({inputs:{x:r},backend:t}),a=r0({inputs:{input:s},backend:t}),o=Wy({inputs:{x:a},backend:t}),l=Tu({inputs:{real:i,imag:o},backend:t});return t.disposeData(r.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),t.disposeData(o.dataId),l}else return ar({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const L9={kernelName:um,backendName:"webgpu",kernelFunc:Wy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vD(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=vm({inputs:{input:s},backend:t}),i=vD({inputs:{x:r},backend:t}),a=r0({inputs:{input:s},backend:t}),o=Wy({inputs:{x:a},backend:t}),l=Tu({inputs:{real:i,imag:o},backend:t});return t.disposeData(r.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),t.disposeData(o.dataId),l}else return ar({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const P9={kernelName:Hp,backendName:"webgpu",kernelFunc:vD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M9(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return jw({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{cr(i,d.shape,"All tensors passed to stack must have matching shapes"),B(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(d=>{const f=jw({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(f),f}),c=uD({inputs:l,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeData(d.dataId)),c}const B9={kernelName:qp,backendName:"webgpu",kernelFunc:M9};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wD(n,e=!1){const t=n.length,s=_n(t),r=n.map((f,p)=>`uniforms.pad${p}[0]`).join(","),i=n.map((f,p)=>`uniforms.pad${p}[0] + uniforms.xShape${t>1?`[${p}]`:""}`).join(","),a=t>1?`${s}(${r})`:`${r}`,o=t>1?`${s}(${i})`:`${i}`,l=t>1?"any(paddedCoords < start)":"paddedCoords < start",c=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",d=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${a};
        let end = ${o};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${d}));
        }
  `}let V9=class{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,r)=>s[0]+e[r]+s[1]),this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((s,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${wD(this.xShape)}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U9=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;if(i.every(c=>yt(c,[0,0])))return kr({inputs:{x:r},backend:t});if(ue(r.shape)===0){const c=i.map((d,f)=>d[0]+r.shape[f]+d[1]);return ar({backend:t,attrs:{shape:c,value:a,dtype:r.dtype}})}const o=[{type:"float32",data:[a]}];i.map(c=>o.push({type:"int32",data:[c[0],c[1]]}));const l=new V9(r.shape,i);return t.runWebGPUProgram(l,[r],r.dtype,o)},W9={kernelName:Xp,backendName:"webgpu",kernelFunc:U9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G9=fs({opType:ut.POW}),H9={kernelName:Bh,backendName:"webgpu",kernelFunc:G9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j9(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=new My(ut.PRELU,s.shape,r.shape);return t.runWebGPUProgram(i,[s,r],"float32")}const q9={kernelName:Kp,backendName:"webgpu",kernelFunc:j9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return Eu(r,i,a,"prod",t)}const K9={kernelName:Yp,backendName:"webgpu",kernelFunc:X9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y9=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:a}=t,o=M8(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},Q9={kernelName:Wx,backendName:"webgpu",kernelFunc:Y9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z9=fs({opType:ut.DIV}),J9={kernelName:Sh,backendName:"webgpu",kernelFunc:Z9};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eQ=Ot({opType:Ae.RECIPROCAL}),tQ={kernelName:Vh,backendName:"webgpu",kernelFunc:eQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nQ=Ot({opType:Ae.RELU}),sQ={kernelName:Uh,backendName:"webgpu",kernelFunc:nQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rQ=Ot({opType:Ae.RELU6}),iQ={kernelName:Wh,backendName:"webgpu",kernelFunc:rQ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aQ=class{constructor(e,t,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oQ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,size:a,halfPixelCenters:o}=s,[l,c]=a,d=i&&l>1?1:0,f=i&&c>1?1:0,g=[{type:"float32",data:[d,f]},{type:"float32",data:[o?.5:0]}],x=new aQ(r.shape,l,c);return t.runWebGPUProgram(x,[r],"float32",g)}const lQ={kernelName:Jp,backendName:"webgpu",kernelFunc:oQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uQ=class{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cQ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,[,o,l]=r.shape,[,c,d]=i.shape,f=[a&&c>1?o-1:o,a&&d>1?l-1:l],p=[a&&c>1?c-1:c,a&&d>1?d-1:d],g=f[0]/p[0],x=f[1]/p[1],b=1/g,v=1/x,w=Math.ceil(b)*2+2,$=Math.ceil(v)*2+2,I=new uQ(r.shape,a),N=[{type:"int32",data:f},{type:"int32",data:p},{type:"float32",data:[g]},{type:"float32",data:[x]},{type:"float32",data:[b]},{type:"float32",data:[v]},{type:"int32",data:[w]},{type:"int32",data:[$]}];return t.runWebGPUProgram(I,[i],i.dtype,N)}const hQ={kernelName:jx,backendName:"webgpu",kernelFunc:cQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dQ=class{constructor(e,t,s,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fQ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,c]=o,d=i&&l>1?1:0,f=i&&c>1?1:0,g=[{type:"float32",data:[d,f]},{type:"float32",data:[i?.5:0]}],x=new dQ(r.shape,l,c,a);return t.runWebGPUProgram(x,[r],r.dtype,g)}const pQ={kernelName:Zp,backendName:"webgpu",kernelFunc:fQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mQ=class{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gQ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,[,o,l]=r.shape,[,c,d]=i.shape,f=[a&&c>1?o-1:o,a&&d>1?l-1:l],p=[a&&c>1?c-1:c,a&&d>1?d-1:d],g=f[0]/p[0],x=f[1]/p[1],b=1/g,v=1/x,w=Math.ceil(b)*2+2,$=Math.ceil(v)*2+2,I=new mQ(r.shape,a),N=[{type:"int32",data:f},{type:"int32",data:p},{type:"float32",data:[b]},{type:"float32",data:[v]},{type:"int32",data:[w]},{type:"int32",data:[$]}];return t.runWebGPUProgram(I,[i],i.dtype,N)}const yQ={kernelName:Hx,backendName:"webgpu",kernelFunc:gQ};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xQ=class{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,a=r.shape.length;if(a===0)return kr({inputs:{x:r},backend:t});const o=r.shape,l=[1,1,1,1];o.forEach((v,w)=>{const $=w+4-a;l[$]=v});const c=pt(i,r.shape),d=[0,0,0,0];c.forEach(v=>{const w=v+4-a;d[w]=1});const f=[{type:"int32",data:d}],p=He({inputs:{x:r},backend:t,attrs:{shape:l}}),g=new xQ(l),x=t.runWebGPUProgram(g,[p],p.dtype,f);t.disposeData(p.dataId);const b=He({inputs:{x},backend:t,attrs:{shape:o}});return t.disposeData(x.dataId),b}const vQ={kernelName:em,backendName:"webgpu",kernelFunc:bQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let wQ=class{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${_e("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SQ={kernelName:ib,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,l=new wQ(s.shape,i),[c,d]=Pb(a,s.shape[1],s.shape[2]),f=[{type:"float32",data:[c]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];return typeof i=="number"?f.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):f.push({type:"float32",data:i}),o.runWebGPUProgram(l,[s],s.dtype,f)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CQ=Ot({opType:Ae.ROUND}),$Q={kernelName:Gh,backendName:"webgpu",kernelFunc:CQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kQ=Ot({opType:Ae.RSQRT,cpuKernelImpl:B8}),NQ={kernelName:Hh,backendName:"webgpu",kernelFunc:kQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Mf=class{constructor(e,t,s,r,i,a,o,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=o,this.sumDupeIndices=l,this.dispatchLayout=Be(e),this.dispatch=Oe(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${s}_${r}_${this.sliceDimGreaterThanOne}_${o}_${l}_${i.length}`;const c=_n(i.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";this.dispatchLayout.x.length===1?(r="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(r="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const o=`getUpdates(${Array.from({length:this.updatesRank},(c,d)=>`coords[${d}]`).join(", ")})`;return`
    ${i}
      ${_e("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${ql(this.type)}(${o});
          let flatIndex = getOutputIndexFromCoords(${r});

          ${this.sumDupeIndices?il("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IQ(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=va(i,r,a),p=[f/c,c];if(f===0)return t.makeTensorInfo(a,r.dtype);const g=He({inputs:{x:r},backend:t,attrs:{shape:[l,o]}}),x=He({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),b=x.dtype,v=ar({backend:t,attrs:{shape:p,value:0,dtype:b}}),w=ue(x.shape),$=[{type:"int32",data:[o]},{type:"int32",data:d},{type:"int32",data:[w]}],I=new Mf(x.shape,o,g.shape.length,x.shape.length,d,p,b),N=t.runWebGPUProgram(I,[x,g],b,$,v),E=He({inputs:{x:N},backend:t,attrs:{shape:a}});return t.disposeData(g.dataId),t.disposeData(x.dataId),t.disposeData(N.dataId),E}const TQ={kernelName:qx,backendName:"webgpu",kernelFunc:IQ};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EQ=class{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${_e("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RQ(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=new EQ([i.shape[0],i.shape[1]],a),l=[{type:"int32",data:[r.shape[1]]}];return t.runWebGPUProgram(o,[r,i],"int32",l)}const AQ={kernelName:Kx,backendName:"webgpu",kernelFunc:RQ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DQ=class{constructor(e,t,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let o=0;o<this.outputShape.length;o++)a.push(`${r[o]}`),o<this.cRank&&i.push(`${r[o]}`);e=i.join(),t=a.join()}return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,a=new DQ(s.shape.length,r.shape,r.shape.length);return t.runWebGPUProgram(a,[s,r,i],ds(r.dtype,i.dtype))}const OQ={kernelName:tm,backendName:"webgpu",kernelFunc:_Q};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FQ=Ot({opType:Ae.SELU}),zQ={kernelName:jh,backendName:"webgpu",kernelFunc:FQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LQ=Ot({opType:Ae.SIGMOID}),PQ={kernelName:Yh,backendName:"webgpu",kernelFunc:LQ};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MQ=Ot({opType:Ae.SIGN}),BQ={kernelName:Kh,backendName:"webgpu",kernelFunc:MQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VQ=Ot({opType:Ae.SIN}),UQ={kernelName:qh,backendName:"webgpu",kernelFunc:VQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WQ=Ot({opType:Ae.SINH}),GQ={kernelName:Xh,backendName:"webgpu",kernelFunc:WQ};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HQ=Ot({opType:Ae.SOFTPLUS}),jQ={kernelName:Qh,backendName:"webgpu",kernelFunc:HQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qQ{constructor(e,t,s,r,i,a){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const o=new Array(r.length);for(let l=0;l<o.length;l++)o[l]=r[i[l]];this.outputShape=o,this.newDim=i,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${_n(r.length)}, paddedXShapeStrides : ${_n(a)}, `,s.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=_n(this.outputShape.length),t=nD(this.newDim);return`
      ${ky(this.paddedXShape,"PaddedX")}
      ${_e("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${wD(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XQ=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;B(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const o=i.reduce(($,I)=>$*I),l=[[0,0]];l.push(...a);for(let $=1+i.length;$<r.shape.length;++$)l.push([0,0]);const c=l.map(($,I)=>$[0]+r.shape[I]+$[1]),d=$u(c,i,o,!1),f=ku(d.length,i.length,!1),p=Nu(c,i,o,!1),g=Ye(c),x=new qQ(r.shape,c,l,d,f,g.length),b=[{type:"int32",data:d},{type:"int32",data:g}];l.map($=>b.push({type:"int32",data:[$[0],$[1]]}));const v=t.runWebGPUProgram(x,[r],r.dtype,b),w=He({inputs:{x:v},backend:t,attrs:{shape:p}});return t.disposeData(v.dataId),w},KQ={kernelName:rm,backendName:"webgpu",kernelFunc:XQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YQ{constructor(e,t,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=Be([t]),this.dispatch=Oe(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${il("&result[outIndex]","value",this.type)}
      }
    }
  `}}class QQ{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Be(t),this.dispatch=Oe(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${il("&result[segmentId]","1","int32")}
      }
    }
  `}}class ZQ{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=Be(e),this.dispatch=Oe(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SD(n,e,t,s=!1,r){const a=ue(n.shape)/n.shape[0],o=n.dtype,l=ue(e.shape),c=r.readSync(t.dataId),f=l>0?c[l-1]+1:0;let p;const g=n.shape.slice();g[0]=f;const x=l*a,b=ar({backend:r,attrs:{shape:g,value:0,dtype:o}});p=new YQ(g,x,o);let v=[{type:"int32",data:[a]},{type:"int32",data:[x]}];const w=r.runWebGPUProgram(p,[n,e,t],o,v,b);if(s)return w;const $=ar({backend:r,attrs:{shape:[f],value:0,dtype:"int32"}});p=new QQ(f,t.shape);const I=r.runWebGPUProgram(p,[t],"int32",null,$),N=ar({backend:r,attrs:{shape:g,value:0,dtype:o}});p=new ZQ(g,o),v=[{type:"int32",data:[a]}];const E=r.runWebGPUProgram(p,[w,I],o,v,N);return r.disposeData(w.dataId),r.disposeData(I.dataId),E}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JQ(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;return SD(s,r,i,!1,t)}const eZ={kernelName:Yx,backendName:"webgpu",kernelFunc:JQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tZ(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;return SD(s,r,i,!0,t)}const nZ={kernelName:Qx,backendName:"webgpu",kernelFunc:tZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sZ=class{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[r]*t[r];this.outputShape=s,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=rZ(this.rank,"uniforms.");return`
      ${_e("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}};function rZ(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n;r++)s.push(`(${t[r]} % ${e}aShape[${r}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(t.shouldExecuteOnCPU([r])||r.dtype==="string"||r.shape.length>=5){const l=t.readSync(r.dataId),c=r.dtype==="string"?l.map(p=>Oi(p)):l,d=ft(r.shape,r.dtype,c),f=q8(d,i);return t.makeTensorInfo(f.shape,f.dtype,f.values)}const a=new sZ(r.shape,i);return t.runWebGPUProgram(a,[r],r.dtype)}const iZ={kernelName:sd,backendName:"webgpu",kernelFunc:OS};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZ(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=va(i,r,o),g=!1;if(i.dtype==="string"){const L=t.bufferSync(r),z=t.bufferSync(i),P=Oi(t.readSync(a.dataId)[0]),_=V8(L,z,o,p,d,c,l,f,P,g);return t.makeTensorInfo(o,_.dtype,_.values)}const x=[p/d,d],b=He({inputs:{x:r},backend:t,attrs:{shape:[c,l]}}),v=i.shape.length?He({inputs:{x:i},backend:t,attrs:{shape:[c,d]}}):kr({inputs:{x:i},backend:t}),w=v.dtype,$=t.makeTensorInfo([],w,ws(1,w)),I=He({inputs:{x:a},backend:t,attrs:{shape:Array(x.length).fill(1)}}),N=OS({inputs:{x:I},backend:t,attrs:{reps:x}}),E=ue([c,d]),D=[{type:"int32",data:[l]},{type:"int32",data:f},{type:"int32",data:[E]}];switch(c){case 0:break;case 1:{const L=new Mf([c,d],l,b.shape.length,v.shape.length,f,x,w,g);t.runWebGPUProgram(L,[v,b],w,D,N)}break;default:{const L=new Mf([c,d],l,b.shape.length,$.shape.length,f,x,w,g);t.runWebGPUProgram(L,[$,b],w,D,N)}{const L=new Mf([c,d],l,b.shape.length,v.shape.length,f,x,w);t.runWebGPUProgram(L,[v,b],w,D,N)}}const O=He({inputs:{x:N},backend:t,attrs:{shape:o}});return t.disposeData(b.dataId),t.disposeData(v.dataId),t.disposeData(I.dataId),t.disposeData($.dataId),t.disposeData(N.dataId),O}const oZ={kernelName:Zx,backendName:"webgpu",kernelFunc:aZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=pt(a,r.shape)[0],l=Zb(r,i,o),c=r.shape.length,d=new Array(c).fill(0),f=r.shape.slice();return l.map(p=>{const g=[...f];g[o]=p;const x=dd({inputs:{x:r},backend:t,attrs:{begin:d,size:g}});return d[o]+=p,x})}const uZ={kernelName:im,backendName:"webgpu",kernelFunc:lZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cZ=Ot({opType:Ae.SQRT}),hZ={kernelName:Zh,backendName:"webgpu",kernelFunc:cZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dZ={kernelName:Jx,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e,r=new hd(t.shape,Ae.SQUARE);return s.runWebGPUProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fZ=fs({opType:ut.SQUARED_DIFFERENCE}),pZ={kernelName:Jh,backendName:"webgpu",kernelFunc:fZ};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mZ({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=new hd(s.shape,Ae.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(r,[s],s.dtype,i)}const gZ={kernelName:rd,backendName:"webgpu",kernelFunc:mZ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yZ=class{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=_n(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let r=0;t=this.outputShape.map((i,a)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${r-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${_e("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=s,{finalShapeSparse:g,finalShape:x,isIdentity:b,sliceDim0:v,isSimpleSlice:w,begin:$,end:I,strides:N}=Fb(r.shape,i,a,o,l,c,d,f,p);let E;if(b)E=He({inputs:{x:r},backend:t,attrs:{shape:x}});else if(v||w){B(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const D=Ob($,I,N),O=dd({inputs:{x:r},backend:t,attrs:{begin:$,size:D}});E=He({inputs:{x:O},backend:t,attrs:{shape:x}}),t.disposeData(O.dataId)}else if(t.shouldExecuteOnCPU([r])){const O=t.readSync(r.dataId),L=ft(r.shape,r.dtype,O),z=G8(g,L,N,$);E=t.makeTensorInfo(x,r.dtype,z.values)}else{const O=new yZ(g),L=[{type:"int32",data:$},{type:"int32",data:N}],z=t.runWebGPUProgram(O,[r],r.dtype,L);E=He({inputs:{x:z},backend:t,attrs:{shape:x}}),t.disposeData(z.dataId)}return E}const bZ={kernelName:tb,backendName:"webgpu",kernelFunc:xZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vZ(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:d,dataSplits:f}=e,p=t.readSync(d.dataId),g=t.readSync(f.dataId),[x,b]=H8(p,g,r,i,a,o,l,c);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(f.shape,"int32",b)]}const wZ={kernelName:nb,backendName:"webgpu",kernelFunc:vZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SZ=fs({opType:ut.SUB,cpuKernelImpl:j8,supportsComplex:!0}),CZ={kernelName:ed,backendName:"webgpu",kernelFunc:SZ};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Z=Ot({opType:Ae.TAN}),kZ={kernelName:td,backendName:"webgpu",kernelFunc:$Z};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NZ=Ot({opType:Ae.TANH}),IZ={kernelName:nd,backendName:"webgpu",kernelFunc:NZ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:a}=e,{sliceRank:o,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=va(a,i,r.shape),p=[f/c,c];if(f===0)return t.makeTensorInfo(r.shape,i.dtype);const g=[],x=He({inputs:{x:i},backend:t,attrs:{shape:[l,o]}});g.push(x);const b=He({inputs:{x:a},backend:t,attrs:{shape:[l,c]}});g.push(b);const v=He({inputs:{x:r},backend:t,attrs:{shape:p}});g.push(v);const w=OS({inputs:{x:v},backend:t,attrs:{reps:Array(p.length).fill(1)}}),$=new Mf([l,c],o,x.shape.length,b.shape.length,d,p,r.dtype,!1),I=ue([l,c]),N=[{type:"int32",data:[o]},{type:"int32",data:d},{type:"int32",data:[I]}],E=t.runWebGPUProgram($,[b,x],v.dtype,N,w);g.push(E);const D=He({inputs:{x:E},backend:t,attrs:{shape:r.shape}});return g.forEach(O=>t.disposeData(O.dataId)),D}const EZ={kernelName:Xx,backendName:"webgpu",kernelFunc:TZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RZ=class{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${_e("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},AZ=class{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${_e("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _c(n,e){e!==null&&n.disposeData(e.dataId)}function PI(n){let e=1;for(;e<n;)e*=2;return e}function DZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s,o=r.shape,l=o[o.length-1];if(t.shouldExecuteOnCPU([r])){const E=t.readSync(r.dataId),[D,O]=X8(E,o,r.dtype,i,a);return[t.makeTensorInfo(D.shape,D.dtype,D.values),t.makeTensorInfo(O.shape,O.dtype,O.values)]}if(i===0)return o[o.length-1]=0,[t.makeTensorInfo(o,r.dtype,[]),t.makeTensorInfo(o,"int32",[])];if(l===1)return[r,ar({attrs:{shape:o,dtype:"int32",value:0},backend:t})];const d=ue(o)/l,f=He({inputs:{x:r},attrs:{shape:[d,l]},backend:t}),p=PI(i),g=PI(l);let x=null;const b=()=>x===null?[f,f]:[f,x],v=(E,D,O)=>{const L=b(),z=new RZ(O),_=[{type:"int32",data:[l]},{type:"int32",data:[x===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[E]},{type:"int32",data:[D]}],H=x;x=t.runWebGPUProgram(z,L,"int32",_),_c(t,H)};for(let E=1;E<p;E*=2){const D=E*2;for(let O=E;O>=1;O/=2)v(D,O,[d,g])}for(let E=g;E>p;E/=2){const D=b(),O=new AZ([d,E/2]),z=[{type:"int32",data:[l]},{type:"int32",data:[x===null?1:0]},{type:"int32",data:[p]}],P=x;x=t.runWebGPUProgram(O,D,"int32",z),_c(t,P);const _=p/2,H=_*2;for(let q=_;q>=1;q/=2)v(H,q,x.shape)}let w=x;x=dd({inputs:{x},backend:t,attrs:{begin:0,size:[d,i]}}),_c(t,w);let $=yD({inputs:{x:f,indices:x},backend:t,attrs:{axis:1,batchDims:1}});_c(t,f);const I=o.slice(0,-1);I.push(i),w=x,x=He({inputs:{x},attrs:{shape:I},backend:t}),_c(t,w);const N=$;return $=He({inputs:{x:$},attrs:{shape:I},backend:t}),_c(t,N),[$,x]}const _Z={kernelName:sb,backendName:"webgpu",kernelFunc:DZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OZ=class{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${_e("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FZ(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=s,[d,f,p,g]=r.shape,[x,b]=c??[f,p],v=[d,x,b,g],w=new OZ(v),$=a==="nearest"?1:2;let I;switch(o){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}const N=[{type:"int32",data:[$]},{type:"int32",data:[I]},{type:"float32",data:[l]}];return t.runWebGPUProgram(w,[r,i],"float32",N)}const zZ={kernelName:rb,backendName:"webgpu",kernelFunc:FZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LZ(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,l=r.shape[i],c=new Array(o-1);let d=0;for(let b=0;b<o;b++)b!==i&&(c[d++]=a.shape[b]);const f=[],p=new Array(o).fill(0),g=a.shape.slice();g[i]=1;const x=new Array(l);for(let b=0;b<x.length;b++){p[i]=b;const v=dd({inputs:{x:a},backend:t,attrs:{begin:p,size:g}}),w=He({inputs:{x:v},backend:t,attrs:{shape:c}});x[b]=w,f.push(v)}return f.forEach(b=>t.disposeData(b.dataId)),x}const PZ={kernelName:om,backendName:"webgpu",kernelFunc:LZ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MZ{constructor(e,t,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=Be(e),this.dispatch=Oe(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${_e("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${il("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s,o=r.shape.length,l=[];let c=0;const d=Zt([c],o);let f=r;d!=null&&(f=ma({inputs:{x:r},backend:t,attrs:{perm:d}}),l.push(f),c=cn(1,o)[0]);const p=CS(f.shape,c,a),g=ue([f.shape[c]]),x=He({inputs:{x:f},backend:t,attrs:{shape:[-1,g]}});l.push(x);const b=r.dtype,v=[x.shape[0],a],w=ar({backend:t,attrs:{shape:v,value:0,dtype:b}}),$=new MZ(x.shape,v,b),I=[{type:"int32",data:[a]},{type:"int32",data:[ue(x.shape)]}],N=t.runWebGPUProgram($,[x,i],b,I,w),E=He({inputs:{x:N},backend:t,attrs:{shape:p}});l.push(N);let D=E;if(d!=null){l.push(E);const O=xa(d);D=ma({inputs:{x:D},backend:t,attrs:{perm:O}})}return l.forEach(O=>t.disposeData(O.dataId)),D}const VZ={kernelName:lm,backendName:"webgpu",kernelFunc:BZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UZ=[nq,Q8,J8,tX,sX,aX,fX,mX,yX,bX,wX,CX,kX,IX,EX,OX,zX,BX,UX,GX,KX,JX,nK,aK,lK,dK,rq,mK,bK,IK,_K,LK,BK,UK,GK,jK,XK,QK,JK,t7,s7,a7,f7,m7,u7,x7,w7,k7,I7,R7,O7,z7,P7,B7,U7,G7,H7,q7,K7,J5,Q7,sY,J7,tY,aY,lY,cY,fY,gY,xY,vY,sq,SY,yK,$Y,NY,TY,RY,DY,OY,LY,VY,MY,WY,HY,qY,QY,e9,AX,n9,r9,d9,a9,c9,p9,DX,g9,x9,v9,S9,I9,A7,E9,A9,_9,sK,z9,P9,B9,W9,H9,q9,K9,Q9,rK,J9,tQ,sQ,iQ,eq,lQ,hQ,pQ,yQ,vQ,SQ,$Q,NQ,TQ,AQ,OQ,zQ,PQ,BQ,UQ,GQ,qX,gZ,bZ,wZ,k9,jQ,KQ,eZ,nZ,oZ,uZ,hZ,dZ,pZ,CZ,D7,kZ,IZ,EZ,iZ,_Z,zZ,uX,PZ,VZ,L9];for(const n of UZ)E2(n);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var CD=function(n,e){return(CD=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s}||function(t,s){for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(t[r]=s[r])})(n,e)};function $D(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}CD(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var sn=function(){return(sn=Object.assign||function(n){for(var e,t=1,s=arguments.length;t<s;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}).apply(this,arguments)};function Rt(n,e,t,s){return new(t||(t=Promise))(function(r,i){function a(c){try{l(s.next(c))}catch(d){i(d)}}function o(c){try{l(s.throw(c))}catch(d){i(d)}}function l(c){var d;c.done?r(c.value):(d=c.value,d instanceof t?d:new t(function(f){f(d)})).then(a,o)}l((s=s.apply(n,[])).next())})}function At(n,e){var t,s,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function o(l){return function(c){return function(d){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,s&&(r=2&d[0]?s.return:d[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,d[1])).done)return r;switch(s=0,r&&(d=[2&d[0],r.value]),d[0]){case 0:case 1:r=d;break;case 4:return a.label++,{value:d[1],done:!1};case 5:a.label++,s=d[1],d=[0];continue;case 7:d=a.ops.pop(),a.trys.pop();continue;default:if(r=a.trys,!((r=r.length>0&&r[r.length-1])||d[0]!==6&&d[0]!==2)){a=0;continue}if(d[0]===3&&(!r||d[1]>r[0]&&d[1]<r[3])){a.label=d[1];break}if(d[0]===6&&a.label<r[1]){a.label=r[1],r=d;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(d);break}r[2]&&a.ops.pop(),a.trys.pop();continue}d=e.call(n,a)}catch(f){d=[6,f],s=0}finally{t=r=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}([l,c])}}}function Zl(n,e,t){if(t||arguments.length===2)for(var s,r=0,i=e.length;r<i;r++)!s&&r in e||(s||(s=Array.prototype.slice.call(e,0,r)),s[r]=e[r]);return n.concat(s||Array.prototype.slice.call(e))}var ga=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],ep=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function Gy(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function kD(n){return Rt(this,void 0,void 0,function(){var e,t;return At(this,function(s){switch(s.label){case 0:return e=document.createElement("canvas"),n instanceof Gt?[4,xS(n,e)]:[3,2];case 1:return s.sent(),[3,3];case 2:e.width=Gy(n.width),e.height=Gy(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),s.label=3;case 3:return[2,e]}})})}function ND(n){return Rt(this,void 0,void 0,function(){var e,t,s,r,i,a;return At(this,function(o){switch(o.label){case 0:return n instanceof Gt?(e=n.shape.slice(0,2),t=e[0],s=e[1],r=ImageData.bind,[4,xS(n)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,o.sent(),s,t]))];case 2:return i=document.createElement("canvas"),a=i.getContext("2d"),i.width=Gy(n.width),i.height=Gy(n.height),a.drawImage(n,0,0),[2,a.getImageData(0,0,i.width,i.height)]}})})}function WZ(n){return Rt(this,void 0,void 0,function(){var e,t;return At(this,function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,kD(n)]:[3,2];case 1:return t=s.sent(),[3,3];case 2:t=n,s.label=3;case 3:return e=t,[2,bA(e,4)]}})})}function ID(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var Ef={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},GZ=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return Rt(this,void 0,void 0,function(){return At(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return Rt(this,void 0,void 0,function(){return At(this,function(e){return[2,ND(this.mask)]})})},n.prototype.toTensor=function(){return Rt(this,void 0,void 0,function(){return At(this,function(e){return[2,WZ(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function HZ(n){return ID(n),"person"}var jZ=function(){function n(e){var t,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new YL.Pose({locateFile:function(r,i){if(e.solutionPath){var a=e.solutionPath.replace(/\/+$/,"");return"".concat(a,"/").concat(r)}return"".concat(i,"/").concat(r)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(r){if(s.height=r.image.height,s.width=r.image.width,r.poseLandmarks==null)s.poses=[];else{var i=s.translateOutput(r.poseLandmarks,r.poseWorldLandmarks);r.segmentationMask&&(i.segmentation={maskValueToLabel:HZ,mask:new GZ(r.segmentationMask)}),s.poses=[i]}})}return n.prototype.translateOutput=function(e,t){var s=this,r={keypoints:e.map(function(i,a){return{x:i.x*s.width,y:i.y*s.height,z:i.z,score:i.visibility,name:ep[a]}})};return t!=null&&(r.keypoints3D=t.map(function(i,a){return{x:i.x,y:i.y,z:i.z,score:i.visibility,name:ep[a]}})),r},n.prototype.estimatePoses=function(e,t,s){return Rt(this,void 0,void 0,function(){var r,i;return At(this,function(a){switch(a.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Gt?(i=ImageData.bind,[4,xS(e)]):[3,2];case 1:return r=new(i.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,a.label=3;case 3:return e=r,[4,this.poseSolution.send({image:e},s)];case 4:return a.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function qZ(n){return Rt(this,void 0,void 0,function(){var e,t;return At(this,function(s){switch(s.label){case 0:return e=function(r){if(r==null)return sn({},Ef);var i=sn({},r);return i.runtime="mediapipe",i.enableSegmentation==null&&(i.enableSegmentation=Ef.enableSegmentation),i.enableSmoothing==null&&(i.enableSmoothing=Ef.enableSmoothing),i.smoothSegmentation==null&&(i.smoothSegmentation=Ef.smoothSegmentation),i.modelType==null&&(i.modelType=Ef.modelType),i}(n),[4,(t=new jZ(e)).initialize()];case 1:return s.sent(),[2,t]}})})}function th(n){return n instanceof Gt?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function TD(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function FS(n){return n instanceof Gt?n:bA(n)}function ED(n,e,t){return qw(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function qw(n,e){B(n.width!==0,function(){return"".concat(e," width cannot be 0.")}),B(n.height!==0,function(){return"".concat(e," height cannot be 0.")})}function Hv(n,e,t){var s=t.rotationVectorStartKeypointIndex,r=t.rotationVectorEndKeypointIndex,i=n.locationData,a=i.relativeKeypoints[s].x*e.width,o=i.relativeKeypoints[s].y*e.height,l=i.relativeKeypoints[r].x*e.width,c=i.relativeKeypoints[r].y*e.height,d=2*Math.sqrt((l-a)*(l-a)+(c-o)*(c-o)),f=function(p,g,x){var b,v=p.locationData,w=x.rotationVectorStartKeypointIndex,$=x.rotationVectorEndKeypointIndex;b=x.rotationVectorTargetAngle?x.rotationVectorTargetAngle:Math.PI*x.rotationVectorTargetAngleDegree/180;var I=v.relativeKeypoints[w].x*g.width,N=v.relativeKeypoints[w].y*g.height,E=v.relativeKeypoints[$].x*g.width,D=v.relativeKeypoints[$].y*g.height;return TD(b-Math.atan2(-(D-N),E-I))}(n,e,t);return{xCenter:a/e.width,yCenter:o/e.height,width:d/e.width,height:d/e.height,rotation:f}}function RD(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function jv(n,e,t,s,r,i,a){return n[e][r]*(n[t][i]*n[s][a]-n[t][a]*n[s][i])}function Bs(n,e,t){var s=(e+1)%4,r=(e+2)%4,i=(e+3)%4,a=(t+1)%4,o=(t+2)%4,l=(t+3)%4;return jv(n,s,r,i,a,o,l)+jv(n,r,i,s,a,o,l)+jv(n,i,s,r,a,o,l)}function MI(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var s=[],r=0,i=n;r<i.length;r++){var a=i[r],o=a.x-.5,l=a.y-.5,c=t.ignoreRotation?0:e.rotation,d=Math.cos(c)*o-Math.sin(c)*l,f=Math.sin(c)*o+Math.cos(c)*l;d=d*e.width+e.xCenter,f=f*e.height+e.yCenter;var p=a.z*e.width,g=sn({},a);g.x=d,g.y=f,g.z=p,s.push(g)}return s}function AD(n,e){var t=function(s,r,i,a){var o=r-s,l=a-i,c=l/o;return{scale:c,offset:i-s*c}}(0,255,e[0],e[1]);return ce(function(){return Ce(Q(n,t.scale),t.offset)})}function Xw(n,e,t){var s,r,i,a,o,l,c,d,f,p,g,x,b,v,w=e.outputTensorSize,$=e.keepAspectRatio,I=e.borderMode,N=e.outputTensorFloatRange,E=th(n),D=function(z,P){return P?{xCenter:P.xCenter*z.width,yCenter:P.yCenter*z.height,width:P.width*z.width,height:P.height*z.height,rotation:P.rotation}:{xCenter:.5*z.width,yCenter:.5*z.height,width:z.width,height:z.height,rotation:0}}(E,t),O=function(z,P,_){if(_===void 0&&(_=!1),!_)return{top:0,left:0,right:0,bottom:0};var H=P.height,q=P.width;qw(P,"targetSize"),qw(z,"roi");var ee,Y,G=H/q,te=z.height/z.width,re=0,he=0;return G>te?(ee=z.width,Y=z.width*G,he=(1-te/G)/2):(ee=z.height/G,Y=z.height,re=(1-G/te)/2),z.width=ee,z.height=Y,{top:he,left:re,right:re,bottom:he}}(D,w,$),L=(s=D,r=E.width,i=E.height,a=!1,o=s.width,l=s.height,c=a?-1:1,d=Math.cos(s.rotation),f=Math.sin(s.rotation),p=s.xCenter,g=s.yCenter,x=1/r,b=1/i,(v=new Array(16))[0]=o*d*c*x,v[1]=-l*f*x,v[2]=0,v[3]=(-.5*o*d*c+.5*l*f+p)*x,v[4]=o*f*c*b,v[5]=l*d*b,v[6]=0,v[7]=(-.5*l*d-.5*o*f*c+g)*b,v[8]=0,v[9]=0,v[10]=o*x,v[11]=0,v[12]=0,v[13]=0,v[14]=0,v[15]=1,RD(v));return{imageTensor:ce(function(){var z=FS(n),P=gi(ED(L,E,w),[1,8]),_=I==="zero"?"constant":"nearest",H=Hs.transform(Un(De(z,"float32")),P,"bilinear",_,0,[w.height,w.width]);return N!=null?AD(H,N):H}),padding:O,transformationMatrix:L}}function BI(n,e,t,s){return s===1?.5*(n+e):n+(e-n)*t/(s-1)}function XZ(n){return ce(function(){var e=function(r){return ce(function(){return[ct(r,[0,0,0],[1,-1,1]),ct(r,[0,0,1],[1,-1,-1])]})}(n),t=e[0],s=e[1];return{boxes:Mt(s),logits:Mt(t)}})}function DD(n){return n!=null&&n.currentTime!=null}function VI(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,a=0;a<n.length;++a){var o=n[a];t=Math.min(t,o.x),s=Math.max(s,o.x),r=Math.min(r,o.y),i=Math.max(i,o.y),e.locationData.relativeKeypoints.push({x:o.x,y:o.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:r,xMax:s,yMax:i,width:s-t,height:i-r},e}function KZ(n,e,t,s){return Rt(this,void 0,void 0,function(){var r,i,a,o,l;return At(this,function(c){switch(c.label){case 0:return n.sort(function(d,f){return Math.max.apply(Math,f.score)-Math.max.apply(Math,d.score)}),r=gi(n.map(function(d){return[d.locationData.relativeBoundingBox.yMin,d.locationData.relativeBoundingBox.xMin,d.locationData.relativeBoundingBox.yMax,d.locationData.relativeBoundingBox.xMax]})),i=Wn(n.map(function(d){return d.score[0]})),[4,Hs.nonMaxSuppressionAsync(r,i,e,t)];case 1:return[4,(a=c.sent()).array()];case 2:return o=c.sent(),l=n.filter(function(d,f){return o.indexOf(f)>-1}),et([r,i,a]),[2,l]}})})}function _D(n,e){return n.map(function(t){var s=sn(sn({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(s.z=t.z*e.width),s})}function YZ(n,e,t){return Rt(this,void 0,void 0,function(){var s,r,i,a,o,l,c,d,f,p,g,x,b,v,w,$,I,N,E,D,O,L,z,P;return At(this,function(_){switch(_.label){case 0:if(s=Mt(e,[0]),r=s.shape,i=r[0],a=r[1],o=r[2],n.length!==o)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(o));return l=[],[4,s.buffer()];case 1:for(c=_.sent(),d=0;d<n.length;d++)if(f=n[d],p=sn({},f),l.push(p),g=Math.trunc(p.x*a),x=Math.trunc(p.y*i),!(g<0||g>=a||x<0||g>=i)){for(b=Math.trunc((t.kernelSize-1)/2),v=Math.max(0,g-b),w=Math.min(a,g+b+1),$=Math.max(0,x-b),I=Math.min(i,x+b+1),N=0,E=0,D=0,O=0,L=$;L<I;++L)for(z=v;z<w;++z)P=c.get(L,z,d),N+=P,O=Math.max(O,P),E+=z*P,D+=L*P;O>=t.minConfidenceToRefine&&N>0&&(p.x=E/a/N,p.y=D/i/N)}return s.dispose(),[2,l]}})})}function UI(n,e){var t=e.left,s=e.top,r=e.left+e.right,i=e.top+e.bottom;return n.map(function(a){return sn(sn({},a),{x:(a.x-t)/(1-r),y:(a.y-s)/(1-i),z:a.z/(1-r)})})}function QZ(n,e,t){return Gf()==="webgl"?function(s,r,i){var a=i.combineWithPreviousRatio.toFixed(2),o={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(a,`);

      setOutput(outputValue);
    }
`)},l=ou();return ce(function(){var c=l.compileAndRun(o,[s,r]);return Vs().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(n,e,t):ce(function(){var s=Me(e,.5),r=Yt(s),i=Me(1,jo(1,Q(r,Ce(5.68842,Q(r,Ce(-.748699,Q(r,Ce(-57.8051,Q(r,Ce(291.309,Q(r,-624.717)))))))))));return Ce(e,Q(Me(n,e),Q(i,t.combineWithPreviousRatio)))})}function ZZ(n,e,t){return Rt(this,void 0,void 0,function(){var s,r,i,a,o;return At(this,function(l){switch(l.label){case 0:return s=n[0],r=n[1],i=function(c,d,f){return ce(function(){var p,g,x,b;f.reverseOutputOrder?(g=Mt(ct(c,[0,f.boxCoordOffset+0],[-1,1])),p=Mt(ct(c,[0,f.boxCoordOffset+1],[-1,1])),b=Mt(ct(c,[0,f.boxCoordOffset+2],[-1,1])),x=Mt(ct(c,[0,f.boxCoordOffset+3],[-1,1]))):(p=Mt(ct(c,[0,f.boxCoordOffset+0],[-1,1])),g=Mt(ct(c,[0,f.boxCoordOffset+1],[-1,1])),x=Mt(ct(c,[0,f.boxCoordOffset+2],[-1,1])),b=Mt(ct(c,[0,f.boxCoordOffset+3],[-1,1]))),g=Ce(Q(Pe(g,f.xScale),d.w),d.x),p=Ce(Q(Pe(p,f.yScale),d.h),d.y),f.applyExponentialOnBoxSize?(x=Q(js(Pe(x,f.hScale)),d.h),b=Q(js(Pe(b,f.wScale)),d.w)):(x=Q(Pe(x,f.hScale),d.h),b=Q(Pe(b,f.wScale),d.h));var v=Me(p,Pe(x,2)),w=Me(g,Pe(b,2)),$=Ce(p,Pe(x,2)),I=Ce(g,Pe(b,2)),N=vn([ie(v,[f.numBoxes,1]),ie(w,[f.numBoxes,1]),ie($,[f.numBoxes,1]),ie(I,[f.numBoxes,1])],1);if(f.numKeypoints)for(var E=0;E<f.numKeypoints;++E){var D=f.keypointCoordOffset+E*f.numValuesPerKeypoint,O=void 0,L=void 0;f.reverseOutputOrder?(O=Mt(ct(c,[0,D],[-1,1])),L=Mt(ct(c,[0,D+1],[-1,1]))):(L=Mt(ct(c,[0,D],[-1,1])),O=Mt(ct(c,[0,D+1],[-1,1])));var z=Ce(Q(Pe(O,f.xScale),d.w),d.x),P=Ce(Q(Pe(L,f.yScale),d.h),d.y);N=vn([N,ie(z,[f.numBoxes,1]),ie(P,[f.numBoxes,1])],1)}return N})}(r,e,t),a=ce(function(){var c=s;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=lr(s,-t.scoreClippingThresh,t.scoreClippingThresh)),c=Ur(c)):c}),[4,JZ(i,a,t)];case 1:return o=l.sent(),et([i,a]),[2,o]}})})}function JZ(n,e,t){return Rt(this,void 0,void 0,function(){var s,r,i,a,o,l,c,d,f,p,g,x;return At(this,function(b){switch(b.label){case 0:return s=[],[4,n.data()];case 1:return r=b.sent(),[4,e.data()];case 2:for(i=b.sent(),a=0;a<t.numBoxes;++a)if(!(t.minScoreThresh!=null&&i[a]<t.minScoreThresh||(o=a*t.numCoords,l=eJ(r[o+0],r[o+1],r[o+2],r[o+3],i[a],t.flipVertically,a),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((d=l.locationData).relativeKeypoints=[],f=t.numKeypoints*t.numValuesPerKeypoint,p=0;p<f;p+=t.numValuesPerKeypoint)g=o+t.keypointCoordOffset+p,x={x:r[g+0],y:t.flipVertically?1-r[g+1]:r[g+1]},d.relativeKeypoints.push(x);s.push(l)}return[2,s]}})})}function eJ(n,e,t,s,r,i,a){return{score:[r],ind:a,locationData:{relativeBoundingBox:{xMin:e,yMin:i?1-t:n,xMax:s,yMax:i?1-n:t,width:s-e,height:t-n}}}}function tJ(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function WI(n,e,t,s){return Rt(this,void 0,void 0,function(){var r,i,a,o,l,c,d,f;return At(this,function(p){switch(p.label){case 0:return t=t||e.flipHorizontally||!1,s=s||e.flipVertically||!1,r=n.size,i=r/e.numLandmarks,[4,n.data()];case 1:for(a=p.sent(),o=[],l=0;l<e.numLandmarks;++l)c=l*i,(f={x:0,y:0}).x=t?e.inputImageWidth-a[c]:a[c],i>1&&(f.y=s?e.inputImageHeight-a[c+1]:a[c+1]),i>2&&(f.z=a[c+2]),i>3&&(f.score=tJ(e.visibilityActivation,a[c+3])),o.push(f);for(d=0;d<o.length;++d)(f=o[d]).x=f.x/e.inputImageWidth,f.y=f.y/e.inputImageHeight,f.z=f.z/e.inputImageWidth/(e.normalizeZ||1);return[2,o]}})})}function GI(n,e,t){var s=n.width,r=n.height,i=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(i=function(c,d){return d.rotation!=null?c+=d.rotation:d.rotationDegree!=null&&(c+=Math.PI*d.rotationDegree/180),TD(c)}(i,t)),i===0)n.xCenter=n.xCenter+s*t.shiftX,n.yCenter=n.yCenter+r*t.shiftY;else{var a=(e.width*s*t.shiftX*Math.cos(i)-e.height*r*t.shiftY*Math.sin(i))/e.width,o=(e.width*s*t.shiftX*Math.sin(i)+e.height*r*t.shiftY*Math.cos(i))/e.height;n.xCenter=n.xCenter+a,n.yCenter=n.yCenter+o}{var l=Math.max(s*e.width,r*e.height);s=l/e.width,r=l/e.height}return n.width=s*t.scaleX,n.height=r*t.scaleY,n}function nJ(n,e){return n.map(function(t){var s=sn(sn({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),s})}var Fo=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var s;return this.initialized?s=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(s=e,this.initialized=!0),this.rawValue=e,this.storedValue=s,s},n.prototype.applyWithAlpha=function(e,t,s){return this.alpha=t,this.apply(e,s)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),qv=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Fo(this.getAlpha(this.minCutOff)),this.dx=new Fo(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,s){if(e==null)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;this.lastTimestamp!==0&&r!==0&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*s*this.frequency:0,a=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),o=this.minCutOff+this.beta*Math.abs(a),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(a):null;return this.x.applyWithAlpha(e,this.getAlpha(o),l)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),Kw=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var r=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Zl([],e,!0);i=1/s}return e.map(function(a,o){var l=sn(sn({},a),{x:r.xFilters[o].apply(a.x,t,i),y:r.yFilters[o].apply(a.y,t,i)});return a.z!=null&&(l.z=r.zFilters[o].apply(a.z,t,i)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(s){return new qv(t.config)}),this.yFilters=e.map(function(s){return new qv(t.config)}),this.zFilters=e.map(function(s){return new qv(t.config)}))},n}(),Xv=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Fo(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,s){if(e==null)return e;var r,i=Math.trunc(t);if(this.lastTimestamp>=i)return e;if(this.lastTimestamp===-1)r=1;else{for(var a=e*s-this.lastValue*this.lastValueScale,o=i-this.lastTimestamp,l=a,c=o,d=(1+this.window.length)*(1e6/30),f=0,p=this.window;f<p.length;f++){var g=p[f];if(c+g.duration>d)break;l+=g.distance,c+=g.duration}var x=l/(1e-6*c);r=1-1/(1+this.config.velocityScale*Math.abs(x)),this.window.unshift({distance:a,duration:o}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=s,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,r)},n}(),sJ=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var r=this;if(e==null)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Zl([],e,!0);i=1/s}return this.initializeFiltersIfEmpty(e),e.map(function(a,o){var l=sn(sn({},a),{x:r.xFilters[o].apply(a.x,t,i),y:r.yFilters[o].apply(a.y,t,i)});return a.z!=null&&(l.z=r.zFilters[o].apply(a.z,t,i)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(s){return new Xv(t.config)}),this.yFilters=e.map(function(s){return new Xv(t.config)}),this.zFilters=e.map(function(s){return new Xv(t.config)}))},n}(),Kv=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new sJ(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new Kw(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,s,r,i){if(r===void 0&&(r=!1),e==null)return this.keypointsFilter.reset(),null;var a=i!=null?function(c,d){return(c.width*d.width+c.height*d.height)/2}(i,s):1,o=r?_D(e,s):e,l=this.keypointsFilter.apply(o,t,a);return r?nJ(l,s):l},n}(),HI=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(o){return new Fo(t.alpha)}));for(var s=[],r=0;r<e.length;++r){var i=e[r],a=sn({},i);a.score=this.visibilityFilters[r].apply(i.score),s.push(a)}return s},n}(),rJ={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Oc={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},iJ={maxPoses:1,flipHorizontal:!1},aJ={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},oJ=.3,jI={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},lJ={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},uJ={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},cJ={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},hJ={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},dJ={kernelSize:7,minConfidenceToRefine:.5},qI={alpha:.1},fJ={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},pJ={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},mJ={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},gJ={activation:"none"},yJ={combineWithPreviousRatio:.7},xJ=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return Rt(this,void 0,void 0,function(){return At(this,function(e){return[2,kD(this.mask)]})})},n.prototype.toImageData=function(){return Rt(this,void 0,void 0,function(){return At(this,function(e){return[2,ND(this.mask)]})})},n.prototype.toTensor=function(){return Rt(this,void 0,void 0,function(){return At(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function bJ(n){return ID(n),"person"}var vJ=function(){function n(e,t,s,r,i,a){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=s,this.enableSegmentation=r,this.smoothSegmentation=i,this.modelType=a,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(f){f.reduceBoxesInLowestLayer==null&&(f.reduceBoxesInLowestLayer=!1),f.interpolatedScaleAspectRatio==null&&(f.interpolatedScaleAspectRatio=1),f.fixedAnchorSize==null&&(f.fixedAnchorSize=!1);for(var p=[],g=0;g<f.numLayers;){for(var x=[],b=[],v=[],w=[],$=g;$<f.strides.length&&f.strides[$]===f.strides[g];){var I=BI(f.minScale,f.maxScale,$,f.strides.length);if($===0&&f.reduceBoxesInLowestLayer)v.push(1),v.push(2),v.push(.5),w.push(.1),w.push(I),w.push(I);else{for(var N=0;N<f.aspectRatios.length;++N)v.push(f.aspectRatios[N]),w.push(I);if(f.interpolatedScaleAspectRatio>0){var E=$===f.strides.length-1?1:BI(f.minScale,f.maxScale,$+1,f.strides.length);w.push(Math.sqrt(I*E)),v.push(f.interpolatedScaleAspectRatio)}}$++}for(var D=0;D<v.length;++D){var O=Math.sqrt(v[D]);x.push(w[D]/O),b.push(w[D]*O)}var L=0,z=0;if(f.featureMapHeight.length>0)L=f.featureMapHeight[g],z=f.featureMapWidth[g];else{var P=f.strides[g];L=Math.ceil(f.inputSizeHeight/P),z=Math.ceil(f.inputSizeWidth/P)}for(var _=0;_<L;++_)for(var H=0;H<z;++H)for(var q=0;q<x.length;++q){var ee={xCenter:(H+f.anchorOffsetX)/z,yCenter:(_+f.anchorOffsetY)/L,width:0,height:0};f.fixedAnchorSize?(ee.width=1,ee.height=1):(ee.width=b[q],ee.height=x[q]),p.push(ee)}g=$}return p}(rJ);var o=Wn(this.anchors.map(function(f){return f.width})),l=Wn(this.anchors.map(function(f){return f.height})),c=Wn(this.anchors.map(function(f){return f.xCenter})),d=Wn(this.anchors.map(function(f){return f.yCenter}));this.anchorTensor={x:c,y:d,w:o,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?gi([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,s){return Rt(this,void 0,void 0,function(){var r,i,a,o,l,c,d,f,p,g,x,b,v,w,$,I,N,E,D,O,L,z,P;return At(this,function(_){switch(_.label){case 0:return r=function(H){var q;if((q=H==null?iJ:sn({},H)).maxPoses==null&&(q.maxPoses=1),q.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(q.maxPoses,". Should be > 0."));if(q.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return q}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=s!=null?1e3*s:DD(e)?1e6*e.currentTime:null,i=th(e),a=ce(function(){return De(FS(e),"float32")}),(o=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(a)]);case 1:if((l=_.sent()).length===0)return this.reset(),a.dispose(),[2,[]];c=l[0],o=this.poseDetectionToRoi(c,i),_.label=2;case 2:return[4,this.poseLandmarksByRoi(o,a)];case 3:return d=_.sent(),a.dispose(),d==null?(this.reset(),[2,[]]):(f=d.landmarks,p=d.auxiliaryLandmarks,g=d.poseScore,x=d.worldLandmarks,b=d.segmentationMask,v=this.poseLandmarkFiltering(f,p,x,i),w=v.actualLandmarksFiltered,$=v.auxiliaryLandmarksFiltered,I=v.actualWorldLandmarksFiltered,N=this.poseLandmarksToRoi($,i),this.regionOfInterest=N,E=this.smoothSegmentation&&b!=null?this.poseSegmentationFiltering(b):b,(D=w!=null?_D(w,i):null)!=null&&D.forEach(function(H,q){H.name=ep[q]}),(O=I)!=null&&O.forEach(function(H,q){H.name=ep[q]}),L={score:g,keypoints:D,keypoints3D:O},E!==null&&(z=ce(function(){var H=Un(E,2),q=zi(H,[[0,0],[0,0],[0,1]]);return q2(q,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||et(E),P={maskValueToLabel:bJ,mask:new xJ(z)},L.segmentation=P),[2,[L]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=QZ(t,e,yJ),et(e)),et(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),et([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(et(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=gi([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return Rt(this,void 0,void 0,function(){var t,s,r,i,a,o,l,c,d,f;return At(this,function(p){switch(p.label){case 0:return t=Xw(e,lJ),s=t.imageTensor,r=t.padding,i=this.detectorModel.predict(s),a=XZ(i),o=a.boxes,[4,ZZ([l=a.logits,o],this.anchorTensor,aJ)];case 1:return(c=p.sent()).length===0?(et([s,i,l,o]),[2,c]):[4,KZ(c,this.maxPoses,oJ)];case 2:return d=p.sent(),f=function(g,x){g===void 0&&(g=[]);for(var b=x.left,v=x.top,w=x.left+x.right,$=x.top+x.bottom,I=0;I<g.length;I++){var N=g[I],E=N.locationData.relativeBoundingBox,D=(E.xMin-b)/(1-w),O=(E.yMin-v)/(1-$),L=E.width/(1-w),z=E.height/(1-$);E.xMin=D,E.yMin=O,E.width=L,E.height=z,E.xMax=D+L,E.yMax=O+z;var P=N.locationData.relativeKeypoints;P&&P.forEach(function(_){var H=(_.x-b)/(1-w),q=(_.y-v)/(1-$);_.x=H,_.y=q})}return g}(d,r),et([s,i,l,o]),[2,f]}})})},n.prototype.poseDetectionToRoi=function(e,t){return GI(Hv(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,jI)},n.prototype.poseLandmarksByRoi=function(e,t){return Rt(this,void 0,void 0,function(){var s,r,i,a,o,l,c,d,f,p,g,x,b,v;return At(this,function(w){switch(w.label){case 0:if(s=th(t),r=Xw(t,uJ,e),i=r.imageTensor,a=r.padding,o=r.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(i,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(d=w.sent())==null?(et(c),et(i),[2,null]):(f=d.landmarks,p=d.auxiliaryLandmarks,g=d.poseScore,x=d.worldLandmarks,b=d.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,e,a,o,f,p,x,b)]);case 2:return v=w.sent(),et(c),et(i),[2,sn({poseScore:g},v)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,s,r,i,a,o,l){return Rt(this,void 0,void 0,function(){var c,d,f,p,g,x;return At(this,function(b){return c=UI(i,s),d=UI(a,s),f=MI(c,t),p=MI(d,t),g=function(v,w){for(var $=[],I=0,N=v;I<N.length;I++){var E=N[I],D=E.x,O=E.y,L=w.rotation,z=Math.cos(L)*D-Math.sin(L)*O,P=Math.sin(L)*D+Math.cos(L)*O,_=sn({},E);_.x=z,_.y=P,$.push(_)}return $}(o,t),x=null,this.enableSegmentation&&(x=ce(function(){var v=l.shape,w=v[0],$=v[1],I=function(D){var O=RD(new Array(16).fill(0));O[0][0]=Bs(D,0,0),O[1][0]=-Bs(D,0,1),O[2][0]=Bs(D,0,2),O[3][0]=-Bs(D,0,3),O[0][2]=Bs(D,2,0),O[1][2]=-Bs(D,2,1),O[2][2]=Bs(D,2,2),O[3][2]=-Bs(D,2,3),O[0][1]=-Bs(D,1,0),O[1][1]=Bs(D,1,1),O[2][1]=-Bs(D,1,2),O[3][1]=Bs(D,1,3),O[0][3]=-Bs(D,3,0),O[1][3]=Bs(D,3,1),O[2][3]=-Bs(D,3,2),O[3][3]=Bs(D,3,3);for(var L=D[0][0]*O[0][0]+D[1][0]*O[0][1]+D[2][0]*O[0][2]+D[3][0]*O[0][3],z=0;z<O.length;z++)for(var P=0;P<O.length;P++)O[z][P]/=L;return O}(r),N=gi(ED(I,{width:$,height:w},e),[1,8]),E=[1,w,$,1];return Mt(Hs.transform(ie(l,E),N,"bilinear","constant",0,[e.height,e.width]),[0,3])}),et(l)),[2,{landmarks:f,auxiliaryLandmarks:p,worldLandmarks:g,segmentationMask:x}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return Rt(this,void 0,void 0,function(){var t,s,r,i,a,o,l,c,d,f,p,g,x;return At(this,function(b){switch(b.label){case 0:return t=e[0],s=e[1],r=e[2],i=e[3],a=this.enableSegmentation?e[4]:null,[4,s.data()];case 1:return(o=b.sent()[0])<.5?[2,null]:[4,WI(t,cJ)];case 2:return[4,YZ(b.sent(),r,dJ)];case 3:return l=b.sent(),c=l.slice(0,33),d=l.slice(33,35),[4,WI(i,hJ)];case 4:return f=b.sent(),p=f.slice(0,33),g=function(v,w,$){for(var I=[],N=0;N<v.length;N++){var E=sn({},w[N]);E.score=v[N].score,I.push(E)}return I}(c,p),x=this.enableSegmentation?function(v,w,$){return ce(function(){var I=Mt(v,[0]),N=I.shape[2];if(N===1){var E=I;switch(w.activation){case"none":break;case"sigmoid":E=Ur(E);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(w.activation,")"))}var D=E;return Mt(D,[2])}throw new Error("Unsupported number of tensor channels ".concat(N))})}(a,gJ):null,[2,{landmarks:c,auxiliaryLandmarks:d,poseScore:o,worldLandmarks:g,segmentationMask:x}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return GI(Hv(VI(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,jI)},n.prototype.poseLandmarkFiltering=function(e,t,s,r){var i,a,o;if(this.timestamp!=null&&this.enableSmoothing){var l=Hv(VI(t),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new HI(qI)),i=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new HI(qI)),a=this.visibilitySmoothingFilterAuxiliary.apply(t),o=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new Kv(fJ)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,r,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new Kv(pJ)),a=this.landmarksSmoothingFilterAuxiliary.apply(a,this.timestamp,r,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new Kv(mJ)),o=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else i=e,a=t,o=s;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:a,actualWorldLandmarksFiltered:o}},n}();function wJ(n){return Rt(this,void 0,void 0,function(){var e,t,s,r,i,a;return At(this,function(o){switch(o.label){case 0:return e=function(l){var c=sn({},l??Oc);if(c.enableSmoothing==null&&(c.enableSmoothing=Oc.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=Oc.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=Oc.smoothSegmentation),c.modelType==null&&(c.modelType=Oc.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=Oc.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Zc(e.detectorModelUrl,{fromTFHub:t}),Zc(e.landmarkModelUrl,{fromTFHub:s})])];case 1:return r=o.sent(),i=r[0],a=r[1],[2,new vJ(i,a,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var tu,ca,OD=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,r=t.keypointTrackerParams.keypointFalloff;s<r.length;s++){var i=r[s];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var s=this.computeSimilarity(e);return this.assignTracks(e,s,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(s){return e-s.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,s){for(var r=Array.from(Array(t[0].length).keys()),i=[],a=0,o=Array.from(Array(e.length).keys());a<o.length;a++){var l=o[a];if(r.length!==0){for(var c=-1,d=-1,f=0,p=r;f<p.length;f++){var g=p[f],x=t[l][g];x>=this.minSimilarity&&x>d&&(c=g,d=x)}if(c>=0){var b=this.tracks[c];b=Object.assign(b,this.createTrack(e[l],s,b.id)),e[l].id=b.id;var v=r.indexOf(c);r.splice(v,1)}else i.push(l)}else i.push(l)}for(var w=0,$=i;w<$.length;w++){l=$[w];var I=this.createTrack(e[l],s);this.tracks.push(I),e[l].id=I.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,s){return s.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,s){var r={id:s||this.nextTrackID(),lastTimestamp:t,keypoints:Zl([],e.keypoints,!0).map(function(i){return sn({},i)})};return e.box!==void 0&&(r.box=sn({},e.box)),r},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(s){return!e.includes(s.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),SJ=function(n){function e(t){return n.call(this,t)||this}return $D(e,n),e.prototype.computeSimilarity=function(t){var s=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(r){return s.tracks.map(function(i){return s.iou(r,i)})})},e.prototype.iou=function(t,s){var r=Math.max(t.box.xMin,s.box.xMin),i=Math.max(t.box.yMin,s.box.yMin),a=Math.min(t.box.xMax,s.box.xMax),o=Math.min(t.box.yMax,s.box.yMax);if(r>=a||i>=o)return 0;var l=(a-r)*(o-i);return l/(t.box.width*t.box.height+s.box.width*s.box.height-l)},e}(OD),CJ=function(n){function e(t){var s=n.call(this,t)||this;return s.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=t.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,s}return $D(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var s=[],r=0,i=t;r<i.length;r++){for(var a=i[r],o=[],l=0,c=this.tracks;l<c.length;l++){var d=c[l];o.push(this.oks(a,d))}s.push(o)}return s},e.prototype.oks=function(t,s){for(var r=this.area(s.keypoints)+1e-6,i=0,a=0,o=0;o<t.keypoints.length;++o){var l=t.keypoints[o],c=s.keypoints[o];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){a+=1;var d=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),f=2*this.keypointFalloff[o];i+=Math.exp(-1*d/(2*r*Math.pow(f,2)))}}return a<this.minNumKeyoints?0:i/a},e.prototype.area=function(t){var s=this,r=t.filter(function(l){return l.score>s.keypointThreshold}),i=Math.min.apply(Math,Zl([1],r.map(function(l){return l.x}),!1)),a=Math.max.apply(Math,Zl([0],r.map(function(l){return l.x}),!1)),o=Math.min.apply(Math,Zl([1],r.map(function(l){return l.y}),!1));return(a-i)*(Math.max.apply(Math,Zl([0],r.map(function(l){return l.y}),!1))-o)},e}(OD);function $J(n){switch(n){case ca.BlazePose:return ep.reduce(function(e,t,s){return e[t]=s,e},{});case ca.PoseNet:case ca.MoveNet:return ga.reduce(function(e,t,s){return e[t]=s,e},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(tu||(tu={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(ca||(ca={}));var XI=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],FD={modelType:"SinglePose.Lightning",enableSmoothing:!0},KI={},YI={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Yv={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},QI={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function kJ(n,e,t,s){for(var r={},i=0,a=ga;i<a.length;i++){var o=a[i];r[o]=[e[t[o]].y*s.height,e[t[o]].x*s.width]}if(function($,I){return($[I.left_hip].score>.2||$[I.right_hip].score>.2)&&($[I.left_shoulder].score>.2||$[I.right_shoulder].score>.2)}(e,t)){var l=(r.left_hip[0]+r.right_hip[0])/2,c=(r.left_hip[1]+r.right_hip[1])/2,d=function($,I,N,E,D){for(var O=["left_shoulder","right_shoulder","left_hip","right_hip"],L=0,z=0,P=0;P<O.length;P++)(Y=Math.abs(E-N[O[P]][0]))>L&&(L=Y),(G=Math.abs(D-N[O[P]][1]))>z&&(z=G);for(var _=0,H=0,q=0,ee=Object.keys(N);q<ee.length;q++){var Y,G,te=ee[q];$[I[te]].score<.2||((Y=Math.abs(E-N[te][0]))>_&&(_=Y),(G=Math.abs(D-N[te][1]))>H&&(H=G))}return[L,z,_,H]}(e,t,r,l,c),f=d[0],p=d[1],g=d[2],x=d[3],b=Math.max(1.9*p,1.9*f,1.2*g,1.2*x),v=[l-(b=Math.min(b,Math.max(c,s.width-c,l,s.height-l))),c-b];if(b>Math.max(s.width,s.height)/2)return Yw(n==null,s);var w=2*b;return{yMin:v[0]/s.height,xMin:v[1]/s.width,yMax:(v[0]+w)/s.height,xMax:(v[1]+w)/s.width,height:(v[0]+w)/s.height-v[0]/s.height,width:(v[1]+w)/s.width-v[1]/s.width}}return Yw(n==null,s)}function Yw(n,e){var t,s,r,i;return n?e.width>e.height?(t=1,s=e.height/e.width,r=0,i=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,s=1,r=(e.height/2-e.width/2)/e.height,i=0):e.width>e.height?(t=e.width/e.height,s=1,r=(e.height/2-e.width/2)/e.height,i=0):(t=1,s=e.height/e.width,r=0,i=(e.width/2-e.height/2)/e.width),{yMin:r,xMin:i,yMax:r+t,xMax:i+s,height:t,width:s}}function NJ(n){var e,t=n==null?FD:sn({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(XI.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(XI));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=tu.BoundingBox),t.trackerType===tu.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(s){var r=ZI(Yv,s);return r.keypointTrackerParams=sn({},Yv.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(r.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(r.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),r}(t.trackerConfig):t.trackerConfig=Yv;else{if(t.trackerType!==tu.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,ZI(QI,e)):t.trackerConfig=QI}return t}function ZI(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var IJ=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=$J(ca.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new Kw(YI),this.cropRegionFilterYMin=new Fo(.9),this.cropRegionFilterXMin=new Fo(.9),this.cropRegionFilterYMax=new Fo(.9),this.cropRegionFilterXMax=new Fo(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===tu.Keypoint?this.tracker=new CJ(t.trackerConfig):t.trackerType===tu.BoundingBox&&(this.tracker=new SJ(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return Rt(this,void 0,void 0,function(){var t,s,r,i,a;return At(this,function(o){switch(o.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return Gf()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=o.sent(),o.label=3;case 3:for(t.dispose(),r={keypoints:[],score:0},i=0,a=0;a<17;++a)r.keypoints[a]={y:s[3*a],x:s[3*a+1],score:s[3*a+2]},r.keypoints[a].score>.2&&(++i,r.score+=r.keypoints[a].score);return i>0&&(r.score/=i),[2,r]}})})},n.prototype.runMultiPersonPoseModel=function(e){return Rt(this,void 0,void 0,function(){var t,s,r,i,a,o,l,c;return At(this,function(d){switch(d.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return Gf()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=d.sent(),d.label=3;case 3:for(t.dispose(),r=[],i=s.length/56,a=0;a<i;++a)for(r[a]={keypoints:[]},o=56*a+51,r[a].box={yMin:s[o],xMin:s[o+1],yMax:s[o+2],xMax:s[o+3],width:s[o+3]-s[o+1],height:s[o+2]-s[o]},l=56*a+55,r[a].score=s[l],r[a].keypoints=[],c=0;c<17;++c)r[a].keypoints[c]={y:s[56*a+3*c],x:s[56*a+3*c+1],score:s[56*a+3*c+2]};return[2,r]}})})},n.prototype.estimatePoses=function(e,t,s){return t===void 0&&(t=KI),Rt(this,void 0,void 0,function(){var r,i,a,o,l,c;return At(this,function(d){switch(d.label){case 0:return t=function(f){return f==null?KI:sn({},f)}(t),e==null?(this.reset(),[2,[]]):(s==null?DD(e)&&(s=1e6*e.currentTime):s*=1e3,r=FS(e),i=th(r),a=Un(r,0),e instanceof Gt||r.dispose(),o=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(a,i,s)]);case 1:return o=d.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(a,i,s)];case 3:o=d.sent(),d.label=4;case 4:for(l=0;l<o.length;++l)for(c=0;c<o[l].keypoints.length;++c)o[l].keypoints[c].name=ga[c],o[l].keypoints[c].y*=i.height,o[l].keypoints[c].x*=i.width;return[2,o]}})})},n.prototype.estimateSinglePose=function(e,t,s){return Rt(this,void 0,void 0,function(){var r,i,a,o,l=this;return At(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=Yw(this.cropRegion==null,t)),r=ce(function(){var d=gi([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),f=Dn([1],"int32"),p=[l.modelInputResolution.height,l.modelInputResolution.width];return De(Hs.cropAndResize(e,d,f,p,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(i=c.sent(),r.dispose(),i.score<this.minPoseScore)return this.reset(),[2,[]];for(a=0;a<i.keypoints.length;++a)i.keypoints[a].y=this.cropRegion.yMin+i.keypoints[a].y*this.cropRegion.height,i.keypoints[a].x=this.cropRegion.xMin+i.keypoints[a].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(i.keypoints=this.keypointFilter.apply(i.keypoints,s,1)),o=kJ(this.cropRegion,i.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(o),[2,[i]]}})})},n.prototype.estimateMultiplePoses=function(e,t,s){return Rt(this,void 0,void 0,function(){var r,i,a,o,l,c,d,f,p,g,x,b=this;return At(this,function(v){switch(v.label){case 0:return t.width>t.height?(i=this.multiPoseMaxDimension,a=Math.round(this.multiPoseMaxDimension*t.height/t.width),r=Hs.resizeBilinear(e,[a,i]),l=i,c=32*Math.ceil(a/32),o=zi(r,[[0,0],[0,c-a],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*t.width/t.height),a=this.multiPoseMaxDimension,r=Hs.resizeBilinear(e,[a,i]),l=32*Math.ceil(i/32),c=a,o=zi(r,[[0,0],[0,0],[0,l-i],[0,0]])),r.dispose(),e.dispose(),d=De(o,"int32"),o.dispose(),[4,this.runMultiPersonPoseModel(d)];case 1:for(f=v.sent(),d.dispose(),f=f.filter(function(w){return w.score>=b.minPoseScore}),g=0;g<f.length;++g)for(p=0;p<f[g].keypoints.length;++p)f[g].keypoints[p].y*=c/a,f[g].keypoints[p].x*=l/i;if(this.enableTracking&&(this.tracker.apply(f,s),this.enableSmoothing)){for(g=0;g<f.length;++g)this.keypointFilterMap.has(f[g].id)||this.keypointFilterMap.set(f[g].id,new Kw(YI)),f[g].keypoints=this.keypointFilterMap.get(f[g].id).apply(f[g].keypoints,s,1);x=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(w,$){x.has($)||b.keypointFilterMap.delete($)})}return[2,f]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),s=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:s,yMax:r,xMax:i,height:r-t,width:i-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function TJ(n){return n===void 0&&(n=FD),Rt(this,void 0,void 0,function(){var e,t,s,r;return At(this,function(i){switch(i.label){case 0:return e=NJ(n),s=!0,e.modelUrl?(s=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Zc(e.modelUrl,{fromTFHub:s})]):[3,2];case 1:return t=i.sent(),[3,4];case 2:return r=void 0,e.modelType==="SinglePose.Lightning"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Zc(r,{fromTFHub:s})];case 3:t=i.sent(),i.label=4;case 4:return Gf()==="webgl"&&fe().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new IJ(t,e)]}})})}var JI={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},eT=["MobileNetV1","ResNet50"],tT={MobileNetV1:[8,16],ResNet50:[16]},EJ=[8,16,32],nT={MobileNetV1:[.5,.75,1],ResNet50:[1]},sT=[1,2,4],rT={maxPoses:1,flipHorizontal:!1},RJ={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},AJ=[-123.15,-115.9,-103.06];function Qv(n){return Math.floor(n/2)}var DJ=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(Qv(e),e);)this.exchange(e,Qv(e)),e=Qv(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var s=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=s},n}();function _J(n,e,t,s,r,i){for(var a=i.shape,o=a[0],l=a[1],c=!0,d=Math.max(t-r,0),f=Math.min(t+r+1,o),p=d;p<f;++p){for(var g=Math.max(s-r,0),x=Math.min(s+r+1,l),b=g;b<x;++b)if(i.get(p,b,n)>e){c=!1;break}if(!c)break}return c}function OJ(n){return Rt(this,void 0,void 0,function(){return At(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function zD(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+17)}}function LD(n,e,t){var s=zD(n.heatmapY,n.heatmapX,n.id,t),r=s.y,i=s.x;return{x:n.heatmapX*e+i,y:n.heatmapY*e+r}}function PD(n,e,t,s){var r=t.x,i=t.y;return n.some(function(a){var o,l,c,d,f,p,g=a.keypoints;return o=i,l=r,c=g[s].y,d=g[s].x,(f=c-o)*f+(p=d-l)*p<=e})}var iT=ga.reduce(function(n,e,t){return n[e]=t,n},{}),MD=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[iT[e],iT[t]]}),Zv=MD.map(function(n){return n[1]}),aT=MD.map(function(n){return n[0]});function oT(n,e,t){return n<e?e:n>t?t:n}function Jv(n,e,t,s){return{y:oT(Math.round(n.y/e),0,t-1),x:oT(Math.round(n.x/e),0,s-1)}}function lT(n,e){return{x:n.x+e.x,y:n.y+e.y}}function uT(n,e,t,s,r,i,a,o){o===void 0&&(o=2);for(var l=s.shape,c=l[0],d=l[1],f={y:e.y,x:e.x},p=lT(f,function($,I,N){var E=N.shape[2]/2;return{y:N.get(I.y,I.x,$),x:N.get(I.y,I.x,E+$)}}(n,Jv(f,i,c,d),a)),g=0;g<o;g++){var x=Jv(p,i,c,d),b=zD(x.y,x.x,t,r);p=lT({x:x.x*i,y:x.y*i},{x:b.x,y:b.y})}var v=Jv(p,i,c,d),w=s.get(v.y,v.x,t);return{y:p.y,x:p.x,name:ga[t],score:w}}function FJ(n,e,t,s,r,i){var a=e.shape[2],o=Zv.length,l=new Array(a),c=n.part,d=n.score,f=LD(c,s,t);l[c.id]={score:d,name:ga[c.id],y:f.y,x:f.x};for(var p=o-1;p>=0;--p){var g=Zv[p],x=aT[p];l[g]&&!l[x]&&(l[x]=uT(p,l[g],x,e,t,s,i))}for(p=0;p<o;++p)g=aT[p],x=Zv[p],l[g]&&!l[x]&&(l[x]=uT(p,l[g],x,e,t,s,r));return l}function zJ(n,e,t){return t.reduce(function(s,r,i){var a=r.y,o=r.x,l=r.score;return PD(n,e,{y:a,x:o},i)||(s+=l),s},0)/t.length}function LJ(n,e,t,s,r,i,a,o){return a===void 0&&(a=.5),o===void 0&&(o=20),Rt(this,void 0,void 0,function(){var l,c,d,f,p,g,x,b,v,w,$,I;return At(this,function(N){switch(N.label){case 0:return[4,OJ([n,e,t,s])];case 1:for(l=N.sent(),c=l[0],d=l[1],f=l[2],p=l[3],g=[],x=function(E,D,O){for(var L=O.shape,z=L[0],P=L[1],_=L[2],H=new DJ(z*P*_,function(te){return te.score}),q=0;q<z;++q)for(var ee=0;ee<P;++ee)for(var Y=0;Y<_;++Y){var G=O.get(q,ee,Y);G<E||_J(Y,G,q,ee,D,O)&&H.enqueue({score:G,part:{heatmapY:q,heatmapX:ee,id:Y}})}return H}(a,1,c),b=o*o;g.length<i&&!x.empty();)v=x.dequeue(),w=LD(v.part,r,d),PD(g,b,w,v.part.id)||($=FJ(v,c,d,r,f,p),I=zJ(g,b,$),g.push({keypoints:$,score:I}));return[2,g]}})})}function BD(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var PJ=function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Be(this.outputShape),this.dispatch=Oe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(BD("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function MJ(n,e){if(ou()instanceof cd)return function(t,s){var r=ou(),i=new PJ(s.shape),a=r.runWebGPUProgram(i,[t,s],"float32");return Vs().makeTensorFromTensorInfo(a)}(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var BJ=function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=Be(t),this.dispatch=Oe(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(BD("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function VJ(n,e){if(ou()instanceof cd)return function(t,s){var r=ou(),i=new BJ(t.shape),a=r.runWebGPUProgram(i,[t,s],"float32");return Vs().makeTensorFromTensorInfo(a)}(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function VD(n){var e=n.shape,t=e[0],s=e[1],r=e[2];return ce(function(){var i,a,o=ie(n,[t*s,r]),l=cu(o,0),c=Un(Pe(l,Qe(s,"int32")),1),d=Un((i=l,a=s,ce(function(){var f=Pe(i,Qe(a,"int32"));return Me(i,Q(f,Qe(a,"int32")))})),1);return vn([c,d],1)})}function UJ(n,e,t){return ce(function(){var s=function(r,i){for(var a=[],o=0;o<ga.length;o++){var l=r.get(o,0).valueOf(),c=r.get(o,1).valueOf(),d=WJ(l,c,o,i),f=d.x,p=d.y;a.push(p),a.push(f)}return gi(a,[ga.length,2])}(n,t);return Ce(De(Q(n.toTensor(),Qe(e,"int32")),"float32"),s)})}function WJ(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+ga.length)}}function GJ(n,e,t){return Rt(this,void 0,void 0,function(){var s,r,i,a,o,l,c,d,f,p;return At(this,function(g){switch(g.label){case 0:return s=0,r=VD(n),[4,Promise.all([n.buffer(),e.buffer(),r.buffer()])];case 1:return i=g.sent(),a=i[0],o=i[1],l=i[2],[4,(c=UJ(l,t,o)).buffer()];case 2:return d=g.sent(),f=Array.from(function(x,b){for(var v=b.shape[0],w=new Float32Array(v),$=0;$<v;$++){var I=b.get($,0),N=b.get($,1);w[$]=x.get(I,N,$)}return w}(a,l)),p=f.map(function(x,b){return s+=x,{y:d.get(b,0),x:d.get(b,1),score:x,name:ga[b]}}),r.dispose(),c.dispose(),[2,{keypoints:p,score:s/p.length}]}})})}function HJ(n,e,t){return Rt(this,void 0,void 0,function(){var s,r,i;return At(this,function(a){return s=VD(n),r=function(o,l,c){return ce(function(){var d=VJ(o,c);return Ce(De(Q(o,Qe(l,"int32")),"float32"),d)})}(s,t,e),i=MJ(n,s),[2,[r,i]]})})}function cT(n,e){return(n-1)%e==0}var hT="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",dT="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function fT(n,e){return function(t,s){return(t-1)%s==0}(n,e)?n:Math.floor(n/e)*e+1}var pT=function(){function n(e,t){this.posenetModel=e;var s=this.posenetModel.inputs[0].shape;B(s[1]===-1&&s[2]===-1,function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"});var r,i,a=(r=t.inputResolution,i=t.outputStride,{height:fT(r.height,i),width:fT(r.width,i)});(function(o){B(EJ.indexOf(o)>=0,function(){return"outputStride of ".concat(o," is invalid. ")+"It must be either 8 or 16."})})(t.outputStride),function(o,l){B(cT(o.height,l),function(){return"height of ".concat(o.height," is invalid for output stride ")+"".concat(l,".")}),B(cT(o.width,l),function(){return"width of ".concat(o.width," is invalid for output stride ")+"".concat(l,".")})}(a,t.outputStride),this.inputResolution=a,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=rT),Rt(this,void 0,void 0,function(){return At(this,function(s){return[2,this.estimatePosesGPU(e,t,!1)]})})},n.prototype.estimatePosesGPU=function(e,t,s){return t===void 0&&(t=rT),s===void 0&&(s=!1),Rt(this,void 0,void 0,function(){var r,i,a,o,l,c,d,f,p,g,x,b,v,w,$,I,N,E;return At(this,function(D){switch(D.label){case 0:return r=function(O){var L=O;if(L.maxPoses==null&&(L.maxPoses=1),L.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(L.maxPoses,". Should be > 0."));if(L.maxPoses>1){if((L=sn(sn({},RJ),L)).scoreThreshold<0||L.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(L.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(L.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(L.nmsRadius,"."))}return L}(t),e==null?[2,s?[[],[]]:[]]:(this.maxPoses=r.maxPoses,i=Xw(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),a=i.imageTensor,o=i.padding,l=this.architecture==="ResNet50"?Ce(a,AJ):AD(a,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(d=Mt(c[2],[0]),f=Mt(c[3],[0]),p=Mt(c[0],[0]),g=Mt(c[1],[0])):(d=Mt(c[0],[0]),f=Mt(c[1],[0]),p=Mt(c[2],[0]),g=Mt(c[3],[0])),x=Ur(f),this.maxPoses!==1?[3,5]:s?[4,HJ(x,d,this.outputStride)]:[3,2]);case 1:return v=D.sent(),$=v[0],w=v[1],b=[$,w],[3,4];case 2:return[4,GJ(x,d,this.outputStride)];case 3:$=D.sent(),b=[$],D.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,LJ(x,d,p,g,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:b=D.sent(),D.label=7;case 7:if(s){if(r.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");I=this.getCanvasInfo(th(e),this.inputResolution,o)}else E=th(e),N=function(O,L,z,P){var _=L.height,H=L.width,q=_/(z.height*(1-P.top-P.bottom)),ee=H/(z.width*(1-P.left-P.right)),Y=-P.top*z.height,G=-P.left*z.width;if(ee===1&&q===1&&Y===0&&G===0)return O;for(var te=0,re=O;te<re.length;te++)for(var he=0,W=re[te].keypoints;he<W.length;he++){var ne=W[he];ne.x=(ne.x+G)*ee,ne.y=(ne.y+Y)*q}return O}(b,E,this.inputResolution,o),r.flipHorizontal&&(N=function(O,L){for(var z=0,P=O;z<P.length;z++)for(var _=0,H=P[z].keypoints;_<H.length;_++){var q=H[_];q.x=L.width-1-q.x}return O}(N,E));return a.dispose(),l.dispose(),et(c),d.dispose(),f.dispose(),p.dispose(),g.dispose(),x.dispose(),[2,s?[b,I]:N]}})})},n.prototype.getCanvasInfo=function(e,t,s){var r=e.height,i=e.width,a=r/(t.height*(1-s.top-s.bottom)),o=i/(t.width*(1-s.left-s.right)),l=-s.top*t.height;return[-s.left*t.width,l,o,a,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function jJ(n){return n===void 0&&(n=JI),Rt(this,void 0,void 0,function(){var e,t,s,r,i;return At(this,function(a){switch(a.label){case 0:return(e=function(d){var f=d||JI;if(f.architecture==null&&(f.architecture="MobileNetV1"),eT.indexOf(f.architecture)<0)throw new Error("Invalid architecture ".concat(f.architecture,". ")+"Should be one of ".concat(eT));if(f.inputResolution==null&&(f.inputResolution={height:257,width:257}),f.outputStride==null&&(f.outputStride=16),tT[f.architecture].indexOf(f.outputStride)<0)throw new Error("Invalid outputStride ".concat(f.outputStride,". ")+"Should be one of ".concat(tT[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.multiplier==null&&(f.multiplier=1),nT[f.architecture].indexOf(f.multiplier)<0)throw new Error("Invalid multiplier ".concat(f.multiplier,". ")+"Should be one of ".concat(nT[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.quantBytes==null&&(f.quantBytes=4),sT.indexOf(f.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(f.quantBytes,". ")+"Should be one of ".concat(sT," ")+"for architecture ".concat(f.architecture,"."));if(f.architecture==="MobileNetV1"&&f.outputStride===32&&f.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return f}(n)).architecture!=="ResNet50"?[3,2]:(o=e.outputStride,l=e.quantBytes,c="model-stride".concat(o,".json"),t=l===4?dT+"float/"+c:dT+"quant".concat(l,"/")+c,[4,Zc(e.modelUrl||t)]);case 1:return s=a.sent(),[2,new pT(s,e)];case 2:return r=function(d,f,p){var g={1:"100",.75:"075",.5:"050"},x="model-stride".concat(d,".json");return p===4?hT+"float/".concat(g[f],"/")+x:hT+"quant".concat(p,"/").concat(g[f],"/")+x}(e.outputStride,e.multiplier,e.quantBytes),[4,Zc(e.modelUrl||r)];case 3:return i=a.sent(),[2,new pT(i,e)]}var o,l,c})})}function qJ(n,e){return Rt(this,void 0,void 0,function(){var t,s;return At(this,function(r){switch(n){case ca.PoseNet:return[2,jJ(e)];case ca.BlazePose:if(s=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,wJ(e)];if(t.runtime==="mediapipe")return[2,qZ(e)];s=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case ca.MoveNet:return[2,TJ(e)];default:throw new Error("".concat(n," is not a supported model name."))}})})}var XJ={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UD={kernelName:up,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,od(De(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KJ={kernelName:ch,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Yt(De(t,"float32")),r=Ss(Me(Qe(1),s));return fn(Pe(n,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YJ={kernelName:hh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Ss(Me(Yt(De(t,"float32")),1));return Pe(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QJ={kernelName:vu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=tt(t.shape,s.shape);return{a:()=>{let o=n;const l=ts(t.shape,r);return l.length>0&&(o=je(o,l)),ie(o,t.shape)},b:()=>{let o=n;const l=ts(s.shape,r);return l.length>0&&(o=je(o,l)),ie(o,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZJ={kernelName:cp,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JJ={kernelName:hp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_t(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eee={kernelName:dp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_t(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tee={kernelName:dh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(n,Ss(Me(Qe(1),Yt(De(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nee={kernelName:fh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Ss(Ce(Qe(1),Yt(De(t,"float32"))));return Pe(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const see={kernelName:gh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=tt(t.shape,s.shape);return{a:()=>{const o=Ce(Yt(t),Yt(s));let l=Q(n,Pe(s,o));const c=ts(t.shape,r);return c.length>0&&(l=je(l,c)),ie(l,t.shape)},b:()=>{const o=Ce(Yt(t),Yt(s));let l=fn(Q(n,Pe(t,o)));const c=ts(s.shape,r);return c.length>0&&(l=je(l,c)),ie(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ree={kernelName:ph,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(n,Ce(Yt(De(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iee={kernelName:mh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(n,Me(Qe(1),Yt(De(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aee(n,e,t,s,r,i){const a=U(n,"dy","avgPool3dGrad"),o=U(e,"input","avgPool3dGrad");let l=a,c=o,d=!1;o.rank===4&&(d=!0,l=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),B(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),B(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Xs("avgPool3dGrad",r,i);const f={dy:l,input:c},p={filterSize:t,strides:s,pad:r,dimRoundingMode:i},g=se.runKernel(dx,f,p);return d?ie(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const oee=J({avgPool3dGrad_:aee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lee={kernelName:pp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a,dimRoundingMode:o}=t;return{x:()=>oee(n,s,r,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uee(n,e,t,s,r){const i=U(n,"dy","avgPoolGrad"),a=U(e,"input","avgPoolGrad");B(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let o=a,l=i,c=!1;a.rank===3&&(c=!0,o=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),B(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),B(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const d={dy:l,input:o},f={filterSize:t,strides:s,pad:r},p=se.runKernel(hx,d,f);return c?ie(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const cee=J({avgPoolGrad_:uee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hee={kernelName:fp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a}=t;return{x:()=>cee(n,s,r,i,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dee={kernelName:mp,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:a}=t;return!i&&!a?{a:()=>Ct(n,r,!1,!0),b:()=>Ct(s,n,!0,!1)}:!i&&a?{a:()=>Ct(n,r,!1,!1),b:()=>Ct(n,s,!0,!1)}:i&&!a?{a:()=>Ct(r,n,!1,!0),b:()=>Ct(s,n,!1,!1)}:{a:()=>Ct(r,n,!0,!0),b:()=>Ct(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fee={kernelName:gp,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>xb(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pee={kernelName:hP,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,a=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])a[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const o=[];for(let l=0;l<a.length;l++)a[l]>1&&o.push(l);return{x:()=>je(n,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mee={kernelName:yh,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gee={kernelName:xh,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yee={kernelName:bh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>Rs(fa(sl(s,r),Su(s,i)),n,_t(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xee={kernelName:yp,inputsToSave:["x"],gradFunc:UD.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bee={kernelName:xp,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:r}=t,i=pt(r,e[0].shape)[0],a=s.map(l=>l[i]);return Cr(n,a,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vee={kernelName:bp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:a,pad:o,dataFormat:l}=t;return B(Wo(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>L2(s.shape,n,r,a,o,l),filter:()=>dS(s,n,r.shape,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wee={kernelName:vp,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:a,dataFormat:o,dimRoundingMode:l}=t;return{dy:()=>Go(n,r,i,a,o,1,l),filter:()=>dS(n,s,r.shape,i,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function See(n,e,t,s,r){let i=n;n.rank===4&&(i=ie(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=e;a.rank===4&&(a=ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),B(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),B(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),B(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),B(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),B(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:i,dy:a},l={strides:s,pad:r,filterShape:t};return se.runKernel(xx,o,l)}const Cee=J({conv3DBackpropFilter_:See});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ee={kernelName:wp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;B(Wo(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=e;return{x:()=>wR(a.shape,n,o,r,i),filter:()=>Cee(a,n,o.shape,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kee={kernelName:vh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(fn(nS(De(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nee={kernelName:wh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(sS(De(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iee={kernelName:Sp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:a}=t;return{x:()=>{const o=Zt([r],s.rank);let l=B2(n,r,i,!a);return o!=null&&(l=Dt(l,o)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tee={kernelName:Cp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=t,o=s??[1,1];B(Wo(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,c]=e;return B(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),B(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),B(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),B(ns(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Xs("depthwiseConv2d",i,a),{x:()=>tA(l.shape,n,c,r,i,o,a),filter:()=>eA(l,n,c.shape,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eee={kernelName:$p,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},a={x:s,filter:r,dy:n};return{x:()=>se.runKernel(Ty,i,t),filter:()=>se.runKernel(Ey,a,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ree={kernelName:Ch,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>se.runKernel(Tx,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aee={kernelName:$h,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=Q(js(fn(Yt(t))),2/Math.sqrt(Math.PI));return{x:()=>Q(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dee={kernelName:kh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ee={kernelName:Np,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ie(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oee={kernelName:Nh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,js(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fee={kernelName:Ih,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zee={kernelName:Th,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=tt(t.shape,s.shape);return{a:()=>{const o=Pe(n,De(s,"float32")),l=ts(t.shape,r);return l.length>0?ie(je(o,l),t.shape):o},b:()=>{let o=Q(n,De(t,"float32"));const l=ts(s.shape,r);l.length>0&&(o=ie(je(o,l),s.shape));const c=Yt(s);return fn(Pe(o,De(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lee={kernelName:Ip,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,a,o]=e,l=o??Qe(1),c=ts(i.shape,r.shape),d=[];if(i.rank===1){for(let N=0;N<r.shape.length-1;++N)d.push(r.shape[N]);d.push(1)}const f=Me(r,i),p=Q(n,l),g=J2(Ce(a,Qe(s))),x=Q(Q(Q(g,g),g),Qe(-.5));return{x:()=>i.rank===1?ie(Q(Q(n,hi(ie(g,[1,1,1,i.shape[0]]),d)),l),r.shape):ie(Q(Q(n,g),l),r.shape),mean:()=>{let N=Q(Q(g,Qe(-1)),p);return i.rank===1&&(N=je(N,c)),ie(N,i.shape)},variance:()=>{let N=Q(Q(x,f),p);return i.rank===1&&(N=je(N,c)),ie(N,i.shape)},scale:()=>{const N=Q(f,g);let E=Q(n,N);return i.rank===1&&(E=je(E,c)),ie(E,i.shape)},offset:()=>{let N=n;return i.rank===1&&(N=je(N,c)),ie(N,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pee={kernelName:Tp,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:a}=t,o=pt(i,s.shape)[0],l=(c,d,f)=>()=>{const p=c.shape,g=d.size,x=p.slice(0,o),b=x.length,v=p.slice(i,p.length).slice(1),w=v.length,$=mT(0,b),I=mT(b+1,b+1+w),N=gT([x,[g],v]),E=ie(f,N),D=ie(d,[g]),O=gT([[b],$,I]),L=Dt(E,O);let z=uS(L,D,c.shape[o]);const P=xa(O);return z=Dt(z,P),z};if(a===1){const c=s.shape[0],d=s.split(c,0);return{x:()=>$r(d.map((g,x)=>l(g,r.slice(x,1),n.slice(x,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function mT(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function gT(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mee={kernelName:Eh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>_t(t),b:()=>_t(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bee={kernelName:Rh,gradFunc:n=>({x:()=>De(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vee={kernelName:Ah,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uee={kernelName:Dh,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wee={kernelName:_h,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gee={kernelName:Rp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=Er(s,0);return{x:()=>Rs(i,n,Q(n,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hee={kernelName:Fh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(n,Ce(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jee={kernelName:Oh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(n,De(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qee={kernelName:dP,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const a=js(s);return Me(n,Q(je(n,r,!0),a))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xee(n,e,t,s=5,r=1,i=1,a=.5){const o={x:n,y:e,dy:t},l={depthRadius:s,bias:r,alpha:i,beta:a};return se.runKernel(zx,o,l)}const Kee=J({localResponseNormalizationBackprop_:Xee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yee={kernelName:zp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:a,alpha:o,beta:l}=t;return{x:()=>Kee(s,r,n,i,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WD(n,e,t,s){return e.rank<t.rank&&(e=ie(e,In(e.shape,s))),n.rank<t.rank&&(n=ie(n,In(n.shape,s))),{x:()=>Q(n,De(Fi(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yT={kernelName:Lp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],a=e[1],o=pt(r,i.shape),l=WD(n,a,i,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qee={kernelName:zh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Q(n,De(sl(t,s),"float32")),b:()=>Q(n,De(Xf(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zee(n,e,t,s,r,i,a){const o=U(n,"dy","maxPool3dGrad"),l=U(e,"input","maxPool3dGrad"),c=U(t,"output","maxPool3dGrad");let d=o,f=l,p=c,g=!1;l.rank===4&&(g=!0,d=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),f=ie(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=ie(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),B(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),B(f.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${f.rank}.`),B(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),Xs("maxPool3dGrad",i,a);const x={dy:d,input:f,output:p},b={filterSize:s,strides:r,pad:i,dimRoundingMode:a},v=se.runKernel(Px,x,b);return g?ie(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}const Jee=J({maxPool3dGrad_:Zee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ete={kernelName:Mp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=t;return{x:()=>Jee(n,s,r,i,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tte(n,e,t,s,r,i,a){const o=U(n,"dy","maxPoolGrad"),l=U(e,"input","maxPoolGrad"),c=U(t,"output","maxPoolGrad");B(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),B(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),B(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Xs("maxPoolGrad",i,a);const d={dy:o,input:l,output:c},f={filterSize:s,strides:r,pad:i,dimRoundingMode:a};return se.runKernel(Lx,d,f)}const nte=J({maxPoolGrad_:tte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ste={kernelName:Pp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o}=t;return{x:()=>nte(n,s,r,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rte={kernelName:Bp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=pt(r,s.shape),o=On(s.shape,i)[1],l=ue(o);return{x:()=>{const d=s.shape.slice();i.forEach(g=>{d[g]=1});const f=ie(n,d);return Pe(Q(f,Sr(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ite={kernelName:Vp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,a]=e,o=pt(r,i.shape),l=WD(n,a,i,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ate={kernelName:Lh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Q(n,De(Su(t,s),"float32")),b:()=>Q(n,De(Er(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ote={kernelName:Up,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>ct(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lte={kernelName:Ph,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=tt(t.shape,s.shape);return{a:()=>{const o=ts(t.shape,r);return o.length>0?ie(je(n,o),t.shape):n},b:()=>{const o=Q(n,fn(mm(Pe(t,s)))),l=ts(s.shape,r);return l.length>0?ie(je(o,l),s.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ute={kernelName:Mh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=tt(t.shape,s.shape);return{a:()=>{const o=Q(n,De(s,"float32")),l=ts(t.shape,r);return l.length>0?ie(je(o,l),t.shape):o},b:()=>{const o=Q(n,De(t,"float32")),l=ts(s.shape,r);return l.length>0?ie(je(o,l),s.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cte={kernelName:Wp,gradFunc:n=>({x:()=>fn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hte={kernelName:jp,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>Dn(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dte={kernelName:Hp,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fte={kernelName:qp,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return bi(n,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xT={kernelName:Xp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>ct(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pte={kernelName:Bh,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,a=s,o=tt(i.shape,a.shape);return{a:()=>{const d=De(a,"float32");let f=Q(n,Q(d,Ya(i,Me(d,Qe(1)))));const p=ts(i.shape,o);return p.length>0&&(f=je(f,p)),ie(f,i.shape)},b:()=>{const d=Er(i,0),f=Rs(d,Wr(i),_t(i));let p=Q(n,Q(r,f));const g=ts(a.shape,o);return g.length>0&&(p=je(p,g)),ie(p,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mte={kernelName:Kp,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=Er(t,0);return{x:()=>Rs(r,n,Q(n,s)),alpha:()=>{let i=Rs(r,_t(n),Q(n,t));const a=ts(s.shape,n.shape);return a.length>0&&(i=je(i,a)),ie(i,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gte(n,e,t){const s=n.shape.slice();s[t]=1;const r=ie(e,s),i=zy(n,t,!0,!1),a=zy(n,t,!0,!0),o=Q(i,a);return Q(r,o)}function yte(n,e,t){const s=n.shape.length,r=s-t.length,i=Zt(t,s);let a=n;i!=null&&(a=Dt(n,i));const o=a.shape.slice(),c=o.splice(s-t.length,t.length).reduce((p,g)=>p*g,1);o.push(c);const d=a.reshape(o);let f=gte(d,e,r);if(f=f.reshape(a.shape),i!=null){const p=xa(i);f=Dt(f,p)}return f}const xte={kernelName:Yp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((a,o)=>o):typeof r=="number"?i=[r]:i=r,{x:()=>yte(s,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bte={kernelName:Sh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=tt(t.shape,s.shape);return{a:()=>{const o=Pe(n,De(s,"float32")),l=ts(t.shape,r);return l.length>0?ie(je(o,l),t.shape):o},b:()=>{let o=Q(n,De(t,"float32"));const l=ts(s.shape,r);l.length>0&&(o=ie(je(o,l),s.shape));const c=Yt(s);return fn(Pe(o,De(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vte={kernelName:Vh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(n,fn(Yt(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wte={kernelName:Wh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=Q(Su(t,6),od(t));return{x:()=>Q(n,De(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ste={kernelName:Uh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,De(od(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cte={kernelName:Qp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ie(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $te={kernelName:Jp,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>se.runKernel(jx,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kte={kernelName:Zp,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>se.runKernel(Hx,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nte={kernelName:em,gradFunc:(n,e,t)=>{const{dims:s}=t,r=pt(s,n.shape);return{x:()=>xi(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ite={kernelName:Gh,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tte={kernelName:Hh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fn(Pe(n,Q(Ya(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ete={kernelName:tm,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>De(_t(t),"float32"),t:()=>Q(n,De(t,n.dtype)),e:()=>Q(n,De(mb(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rte={kernelName:jh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Er(t,Qe(0)),r=Qe(xm),i=Qe(bm),a=Q(n,i),o=Q(Q(n,r),js(De(t,"float32")));return Rs(s,a,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ate={kernelName:Yh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,Q(t,Me(Qe(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dte={kernelName:Kh,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _te={kernelName:qh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(cb(De(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ote={kernelName:Xh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(M2(De(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fte={kernelName:nm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,a=s.shape,[o,l]=ym(s,r,i),c=[];for(let d=0;d<n.rank;d++)c.push([o[d],a[d]-o[d]-l[d]]);return{x:()=>zi(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zte={kernelName:am,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,a=Q(n,s);return{logits:()=>Me(a,Q(je(a,[r],i),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lte={kernelName:Qh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,Ur(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bT={kernelName:rm,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>ub(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vT={kernelName:im,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>vn(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pte={kernelName:Zh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(n,Q(Ss(De(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mte={kernelName:Jx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,Q(De(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bte={kernelName:Jh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Qe(2);return{a:()=>Q(n,Q(r,Me(t,s))),b:()=>Q(n,Q(r,Me(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vte={kernelName:rd,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ute={kernelName:ed,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=tt(t.shape,s.shape);return{a:()=>{let o=n;const l=ts(t.shape,r);return l.length>0&&(o=je(o,l)),ie(o,t.shape)},b:()=>{let o=n;const l=ts(s.shape,r);return l.length>0&&(o=je(o,l)),ie(fn(o),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wte={kernelName:sm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;pt(i,s.shape).forEach(c=>{r[c]=1});const o=ie(n,r),l=Q(o,Sr(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gte={kernelName:td,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pe(n,Yt(cb(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hte={kernelName:nd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(Me(Qe(1),Yt(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jte={kernelName:sd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let a=_t(s);if(s.rank===1)for(let o=0;o<r[0];++o)a=Ce(a,ct(n,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)a=Ce(a,ct(n,[o*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)a=Ce(a,ct(n,[o*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let d=0;d<r[3];++d)a=Ce(a,ct(n,[o*s.shape[0],l*s.shape[1],c*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qte={kernelName:Jl,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=xa(r);return{x:()=>Dt(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xte={kernelName:om,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>$r(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kte={kernelName:lm,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Yte(n,t)}}};function Yte(n,e){const t=Za(e,_t(e)),s=gm(n,t);let r=sl(e,Qe(0,"int32"));const i=s.rank-r.rank;for(let o=0;o<i;++o)r=Un(r,o+1);r=fa(r,Sr(s.shape,"bool"));const a=_t(s);return Rs(r,s,a)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qte={kernelName:um,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zte=[UD,KJ,YJ,QJ,ZJ,JJ,eee,tee,nee,see,ree,iee,lee,hee,dee,fee,pee,mee,gee,yee,xee,bee,wee,vee,$ee,kee,Nee,Iee,Tee,Eee,bte,Ree,Aee,Dee,_ee,Oee,zee,Fee,Lee,Pee,Mee,Bee,Vee,Uee,Wee,Gee,Hee,jee,qee,Yee,yT,yT,Qee,ete,ste,rte,ite,ate,ote,lte,ute,cte,hte,dte,fte,xT,xT,pte,mte,xte,vte,wte,Ste,Cte,$te,kte,Nte,Ite,Tte,Ete,Rte,Ate,Dte,_te,Ote,Fte,zte,Lte,bT,bT,vT,vT,Pte,Bte,Mte,Vte,Ute,Wte,Gte,Hte,jte,qte,Xte,Kte,Qte];for(const n of Zte)pP(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.abs=function(){return this.throwIfDisposed(),Xn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.acos=function(){return this.throwIfDisposed(),nR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.acosh=function(){return this.throwIfDisposed(),sR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.add=function(n){return this.throwIfDisposed(),Ce(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.all=function(n,e){return this.throwIfDisposed(),O2(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.any=function(n,e){return this.throwIfDisposed(),Fy(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.argMax=function(n){return this.throwIfDisposed(),cu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.argMin=function(n){return this.throwIfDisposed(),rR(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.asScalar=function(){return this.throwIfDisposed(),B(this.size===1,()=>"The array must have only 1 element."),ie(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.asType=function(n){return this.throwIfDisposed(),De(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as1D=function(){return this.throwIfDisposed(),ie(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as2D=function(n,e){return this.throwIfDisposed(),ie(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),ie(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),ie(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),ie(this,[n,e,t,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.asin=function(){return this.throwIfDisposed(),iR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.asinh=function(){return this.throwIfDisposed(),aR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.atan=function(){return this.throwIfDisposed(),oR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.atan2=function(n){return this.throwIfDisposed(),lR(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.atanh=function(){return this.throwIfDisposed(),uR(this)};Se().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),lb(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),ub(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),hm(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Hc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cast=function(n){return this.throwIfDisposed(),De(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.ceil=function(){return this.throwIfDisposed(),mR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),lr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof Gt&&(n=[n]),vn([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),z2(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),P2(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Go(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cos=function(){return this.throwIfDisposed(),cb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cosh=function(){return this.throwIfDisposed(),M2(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),zy(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),B2(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),CR(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),dm(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),$R(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.divNoNan=function(n){return this.throwIfDisposed(),kR(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.div=function(n){return this.throwIfDisposed(),Pe(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.dot=function(n){return this.throwIfDisposed(),NR(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.elu=function(){return this.throwIfDisposed(),fm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.equal=function(n){return this.throwIfDisposed(),Fi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.erf=function(){return this.throwIfDisposed(),V2(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),ER(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.exp=function(){return this.throwIfDisposed(),js(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.expandDims=function(n){return this.throwIfDisposed(),Un(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.expm1=function(){return this.throwIfDisposed(),RR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.fft=function(){return this.throwIfDisposed(),$b(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.flatten=function(){return this.throwIfDisposed(),ie(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.floor=function(){return this.throwIfDisposed(),mm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.floorDiv=function(n){return this.throwIfDisposed(),_2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.gather=function(n,e,t){return this.throwIfDisposed(),gm(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.greaterEqual=function(n){return this.throwIfDisposed(),sl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.greater=function(n){return this.throwIfDisposed(),Er(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.ifft=function(){return this.throwIfDisposed(),Qf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.irfft=function(){return this.throwIfDisposed(),iS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.isFinite=function(){return this.throwIfDisposed(),AR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.isInf=function(){return this.throwIfDisposed(),DR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.isNaN=function(){return this.throwIfDisposed(),_R(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.leakyRelu=function(n){return this.throwIfDisposed(),db(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.lessEqual=function(n){return this.throwIfDisposed(),Su(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.less=function(n){return this.throwIfDisposed(),Xf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),OR(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logSigmoid=function(){return this.throwIfDisposed(),FR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logSoftmax=function(n){return this.throwIfDisposed(),G2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),pb(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.log=function(){return this.throwIfDisposed(),Wr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.log1p=function(){return this.throwIfDisposed(),fb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logicalAnd=function(n){return this.throwIfDisposed(),fa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logicalNot=function(){return this.throwIfDisposed(),mb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logicalOr=function(n){return this.throwIfDisposed(),H2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.logicalXor=function(n){return this.throwIfDisposed(),zR(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),Ct(this,n,e,t)};Se().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),gb(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.max=function(n,e){return this.throwIfDisposed(),mi(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.maximum=function(n){return this.throwIfDisposed(),Za(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.mean=function(n,e){return this.throwIfDisposed(),$n(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.min=function(n,e){return this.throwIfDisposed(),qf(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.minimum=function(n){return this.throwIfDisposed(),jo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),q2(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.mod=function(n){return this.throwIfDisposed(),PR(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.mul=function(n){return this.throwIfDisposed(),Q(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.neg=function(){return this.throwIfDisposed(),fn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.norm=function(n,e,t){return this.throwIfDisposed(),pm(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.notEqual=function(n){return this.throwIfDisposed(),Yc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),X2(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.onesLike=function(){return this.throwIfDisposed(),Gr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.pad=function(n,e){return this.throwIfDisposed(),zi(this,n,e)};Se().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),MR(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.pow=function(n){return this.throwIfDisposed(),Ya(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.prelu=function(n){return this.throwIfDisposed(),bb(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.prod=function(n,e){return this.throwIfDisposed(),BR(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.reciprocal=function(){return this.throwIfDisposed(),VR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.relu=function(){return this.throwIfDisposed(),ba(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.relu6=function(){return this.throwIfDisposed(),Q2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.reshapeAs=function(n){return this.throwIfDisposed(),ie(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.reshape=function(n){return this.throwIfDisposed(),ie(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),rA(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),iA(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.reverse=function(n){return this.throwIfDisposed(),xi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.rfft=function(){return this.throwIfDisposed(),kb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.round=function(){return this.throwIfDisposed(),Z2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.rsqrt=function(){return this.throwIfDisposed(),J2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.selu=function(){return this.throwIfDisposed(),eS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),tS(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sigmoid=function(){return this.throwIfDisposed(),Ur(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sign=function(){return this.throwIfDisposed(),UR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sin=function(){return this.throwIfDisposed(),nS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sinh=function(){return this.throwIfDisposed(),sS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.slice=function(n,e){return this.throwIfDisposed(),ct(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.softmax=function(n){return this.throwIfDisposed(),Cb(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.softplus=function(){return this.throwIfDisposed(),ad(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),xb(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.split=function(n,e){return this.throwIfDisposed(),Cr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sqrt=function(){return this.throwIfDisposed(),Ss(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.square=function(){return this.throwIfDisposed(),Yt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.squaredDifference=function(n){return this.throwIfDisposed(),aS(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.squeeze=function(n){return this.throwIfDisposed(),Mt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof Gt?[this,n]:[this,...n];return $r(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.step=function(n){return this.throwIfDisposed(),od(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.stridedSlice=function(n,e,t,s,r,i,a,o){return this.throwIfDisposed(),WR(this,n,e,t,s,r,i,a,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sub=function(n){return this.throwIfDisposed(),Me(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.sum=function(n,e){return this.throwIfDisposed(),je(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.tan=function(){return this.throwIfDisposed(),GR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.tanh=function(){return this.throwIfDisposed(),du(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.tile=function(n){return this.throwIfDisposed(),hi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.toBool=function(){return this.throwIfDisposed(),De(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.toFloat=function(){return this.throwIfDisposed(),De(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.toInt=function(){return this.throwIfDisposed(),De(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.topk=function(n,e){return this.throwIfDisposed(),qR(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.transpose=function(n){return this.throwIfDisposed(),Dt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.unique=function(n){return this.throwIfDisposed(),XR(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),uS(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.unstack=function(n){return this.throwIfDisposed(),bi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.where=function(n,e){return this.throwIfDisposed(),Rs(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Se().prototype.zerosLike=function(){return this.throwIfDisposed(),_t(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ia extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ia.prototype)}}class di extends Error{constructor(e){super(e),Object.setPrototypeOf(this,di.prototype)}}class ae extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ae.prototype)}}class bt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bt.prototype)}}class zS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,zS.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class GD{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yu(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function aa(n,e){if(!n)throw new zS(e)}function wT(n,e){let t=0;for(const s of n)s===e&&t++;return t}function sr(n){return n.length===1?n[0]:n}function jt(n){return Array.isArray(n)?n:[n]}function Ua(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Xl(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let oi={};function LS(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function Qw(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>Qw(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:Qw(s))}}}function wm(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let a;if(i in t)a=t[i];else if(i in oi)a=oi[i];else if(a=e[i],a==null)throw new ae(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const i=n;if(i.className==null||i.config==null)throw new ae(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const a=i.className;let o,l;if(a in t?[o,l]=t[a]:a in oi?[o,l]=oi.className:a in e&&([o,l]=e[a]),o==null)throw new ae(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const g of Object.keys(oi))c[g]=oi[g];for(const g of Object.keys(t))c[g]=t[g];const d=i.config;d.customObjects=c;const f=Object.assign({},oi);for(const g of Object.keys(t))oi[g]=t[g];Qw(i.config);const p=l(o,i.config,t,r);return oi=Object.assign({},f),p}else{const c=Object.assign({},oi);for(const f of Object.keys(t))oi[f]=t[f];const d=new o(i.config);return oi=Object.assign({},c),d}}}function Jte(n,e){return n<e?-1:n>e?1:0}function ty(n,e){return-1*Jte(n,e)}function Mo(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function ene(n){if(n==null)throw new ae(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Ru(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new ae(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function PS(n,e,t=0,s=1/0){return aa(t>=0),aa(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function hs(n,e){Array.isArray(n)?(B(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>hs(t,`element ${s+1} of ${e}`))):B(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${HD(n)}.`)}function HD(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>HD(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function tne(n,e,t){let s=t!=null?t():nr(),r;return(...a)=>{const o=t!=null?t():nr();return o-s<e||(s=o,r=n(...a)),r}}function jD(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let nne=0;function qD(){return nne++}const ny={};function i0(n=""){return n in ny||(ny[n]=0),ny[n]+=1,n+ny[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const sne=["channelsFirst","channelsLast"],rne=["nearest","bilinear"],ine=["valid","same","causal"],ane=["max","avg"],one=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Fc=new Map;function zn(n){Ru(sne,"DataFormat",n)}function lne(n){Ru(rne,"InterpolationFormat",n)}function Xr(n){Ru(ine,"PaddingMode",n)}function XD(n){Ru(ane,"PoolMode",n)}const Bf=[],ST="/";function nu(n,e){Bf.push(n);try{const t=e();return Bf.pop(),t}catch(t){throw Bf.pop(),t}}function une(){return Bf.length===0?"":Bf.join(ST)+ST}function KD(n){if(!QD(n))throw new Error("Not a valid tensor name: '"+n+"'");return une()+n}function YD(n){if(!QD(n))throw new Error("Not a valid tensor name: '"+n+"'");Fc.has(n)||Fc.set(n,0);const e=Fc.get(n);if(Fc.set(n,Fc.get(n)+1),e>0){const t=`${n}_${e}`;return Fc.set(t,1),t}else return n}const cne=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function QD(n){return!!n.match(cne)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hne(n){return n===parseInt(n.toString(),10)}function Bo(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function nh(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Xo(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function Mi(n,e){if(e<n)throw new ae(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ew;function Kn(){return ew==null&&(ew=ou().epsilon()),ew}function Bi(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ha(n,e){return De(n,e)}function Sm(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ie(n,t)}function dne(n,e){return ce(()=>{if(n.shape.length!==2)throw new ae(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Sm(n,1);return Zw(t,[1,e,1])})}function fne(n){const e=[Bo(n.shape)];return ie(n,e)}function pne(n){if(n.rank<=1)throw new ae(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Bo(n.shape,1)];return ie(n,e)}function su(n,e,t){return ce(()=>{switch(n.rank){case 1:return wb(n,e,t);case 2:return rS(n,[e,0],[t,n.shape[1]]);case 3:return Sb(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Yf(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return ct(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return ct(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new ae(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function tw(n,e,t){return ce(()=>{switch(n.rank){case 1:return wb(n,e,t);case 2:return rS(n,[0,e],[n.shape[0],t]);case 3:return Sb(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Yf(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new ae(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function sy(n,e,t,s){return ce(()=>{switch(n.rank){case 1:return wb(n,e,t);case 2:switch(s){case 1:return su(n,e,t);case 2:return tw(n,e,t);default:throw new ae(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return su(n,e,t);case 2:return Sb(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return tw(n,e,t);default:throw new ae(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return su(n,e,t);case 2:return Yf(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Yf(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return tw(n,e,t);default:throw new ae(`The axis is not within the rank of the tensor ${s}`)}default:throw new ae(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function MS(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),vn(n,e)}function CT(n,e){switch(n.rank){case 1:return gR([n,e]);case 2:return yR([n,e],0);case 3:return xR([n,e],0);case 4:return bR([n,e],0);default:throw new ae(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Zw(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new ae(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return hi(n,e)}function a0(n,e=0,t=1,s,r){return Y2(n,e,t,s,r)}function da(n,e,t,s){if(n.rank<2||e.rank<2)throw new bt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new bt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return Ew({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?Jw(n.rank,s,Bi()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=ie(n,[-1,i]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),c=[...a,o],d=Array.from({length:e.rank},(x,b)=>b===0?e.rank-2:b<=e.rank-2?b-1:b);e=ie(Dt(e,d),[l,-1]);const f=[...r,...c];return ie(Ew({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?Jw(n.rank,s,Bi()):null,activation:t}),f)}}function ZD(n,e,t){return ce(()=>(Array.isArray(e)?e=Wn(e,"int32"):e=De(e,"int32"),gm(n,e,t)))}function Cm(n){return Q(n,n)}function Jw(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new ae(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?ie(e,[1,s[0],1,1,1]):ie(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?ie(e,[1,1,1,1,s[0]]):ie(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?ie(e,[1,s[0],1,1]):ie(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?ie(e,[1,1,1,s[0]]):ie(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?ie(e,[1,s[0],1]):ie(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?ie(e,[1,1,s[0]]):ie(e,[1].concat(s))}else if(n<3)return e;throw new ae(`Unsupported input rank by biasAdd: ${e.rank}`)}function Gi(n,e,t){return ce(()=>(t==null&&(t=Bi()),zn(t),Ce(n,Jw(n.rank,e,t))))}function mne(n,e=1){if(e!==1)throw new bt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return fm(n)}function gne(n){return ce(()=>Pe(n,Ce(Xn(n),1)))}function JD(n,e,t,s){return ce(()=>QR(n,e,t,s))}function yne(n){return ce(()=>{const e=Ce(.5,Q(.2,n));return lr(e,0,1)})}function $m(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const xne=["fanIn","fanOut","fanAvg"],bne=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vne(n){Ru(xne,"FanMode",n)}function wne(n){Ru(bne,"Distribution",n)}class vi extends ud{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class e_ extends vi{apply(e,t){return Dn(e,t)}}e_.className="Zeros";Ee(e_);class BS extends vi{apply(e,t){return Sr(e,t)}}BS.className="Ones";Ee(BS);class t_ extends vi{constructor(e){if(super(),typeof e!="object")throw new ae(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ae(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ce(()=>Q(Qe(this.value),Sr(e,t)))}getConfig(){return{value:this.value}}}t_.className="Constant";Ee(t_);class n_ extends vi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Cu(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}n_.className="RandomUniform";Ee(n_);class s_ extends vi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new bt(`randomNormal does not support dType ${t}.`);return a0(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}s_.className="RandomNormal";Ee(s_);class r_ extends vi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new bt(`truncatedNormal does not support dType ${t}.`);return lS(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}r_.className="TruncatedNormal";Ee(r_);class i_ extends vi{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ce(()=>{if(e.length!==2||e[0]!==e[1])throw new ae("Identity matrix initializer can only be used for 2D square matrices.");return Q(this.gain,W2(e[0]))})}getConfig(){return{gain:this.gain}}}i_.className="Identity";Ee(i_);function Sne(n,e="channelsLast"){let t,s;if(zn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=Bo(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=Bo(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Bo(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class Nr extends vi{constructor(e){if(super(),e.scale<0)throw new ae(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,vne(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,wne(this.distribution),this.seed=e.seed}apply(e,t){const s=Sne(e),r=s[0],i=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),this.distribution==="normal"){const o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new bt(`${this.getClassName()} does not support dType ${t}.`);return lS(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*a);return Cu(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Nr.className="VarianceScaling";Ee(Nr);class VS extends Nr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}VS.className="GlorotUniform";Ee(VS);class US extends Nr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}US.className="GlorotNormal";Ee(US);class WS extends Nr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}WS.className="HeNormal";Ee(WS);class GS extends Nr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}GS.className="HeUniform";Ee(GS);class HS extends Nr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}HS.className="LeCunNormal";Ee(HS);class jS extends Nr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}jS.className="LeCunUniform";Ee(jS);class a_ extends vi{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ce(()=>{if(e.length<2)throw new bt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=ue(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const a=[Math.max(r,s),Math.min(r,s)],o=a0(a,0,1,t,this.seed),l=aA.qr(o,!1);let c=l[0];const f=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return c=Q(c,f.sign()),s<r&&(c=c.transpose()),Q(Qe(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}a_.className="Orthogonal";Ee(a_);const $T={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function kT(n,e={}){return wm(n,ci.getMap().classNameMap,e,"initializer")}function bn(n){return LS(n)}function pn(n){if(typeof n=="string"){const e=n in $T?$T[n]:n;if(e==="GlorotNormal")return new US;if(e==="GlorotUniform")return new VS;if(e==="HeNormal")return new WS;if(e==="HeUniform")return new GS;if(e==="LeCunNormal")return new HS;if(e==="LeCunUniform")return new jS;{const t={};return t.className=e,t.config={},kT(t)}}else return n instanceof vi?n:kT(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function e2(n){return Array.isArray(n)&&Array.isArray(n[0])}function Hy(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function ht(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new ae(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function Lt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new ae(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jy(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const NT="Variable";class Cne{constructor(e,t="float32",s=NT,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=qD(),s=s??NT,this.originalName=KD(s),this.name=YD(this.originalName),this.trainable_=r,this.constraint=i,this.val=KR(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),$ne(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function $ne(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function t2(n){return n.map(e=>e.read())}function qS(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Yn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class ya{constructor(e,t,s,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=qD(),a!=null&&(this.originalName=KD(a),this.name=YD(this.originalName)),this.rank=t.length}}let kne=0;class o0{constructor(e,t){this.callArgs=t,this.id=kne++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Nne=0;class wt extends ud{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Nne++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=Ua(s)+"_"+i0(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new di(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ae(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return sr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return sr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ia(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ia(`Layer ${this.name} is not connected, no input to return.`);return sr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ia(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ia(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return sr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=jt(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=jt(this.inputSpec);if(t.length!==s.length)throw new ae(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],a=s[r];if(a==null)continue;const o=i.rank;if(a.ndim!=null&&o!==a.ndim)throw new ae(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${o}`);if(a.maxNDim!=null&&o>a.maxNDim)throw new ae(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${o}`);if(a.minNDim!=null&&o<a.minNDim)throw new ae(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${o}.`);if(a.dtype!=null&&i.dtype!==a.dtype)throw new ae(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${i.dtype}.`);if(a.axes){const l=i.shape;for(const c in a.axes){const d=Number(c),f=a.axes[c],p=d>=0?l[d]:l[l.length+d];if(f!=null&&[f,null].indexOf(p)===-1)throw new ae(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${f} but got shape ${l}.`)}}if(a.shape!=null)for(let l=0;l<a.shape.length;++l){const c=a.shape[l],d=i.shape[l];if(c!=null&&d!=null&&c!==d)throw new ae(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=jt(e),r=Ene(e),i=Rne(e);if(r===i)throw new ae("Arguments to apply() must be all SymbolicTensors or all Tensors");return nu(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const o of jt(e))a.push(o.shape);this.build(sr(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const o=jt(a),l=[];for(let c of o)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(a=sr(l),this.activityRegularizer!=null)throw new bt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=Ine(e),o=this.computeOutputShape(a);let l;const c=Tne(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((d,f)=>new ya(c,d,this,jt(e),t,this.name,f)):l=new ya(c,o,this,jt(e),t,this.name),this.addInboundNode(e,l,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new bt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ia(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new ia(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new di(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return jy(this.weights)}build(e){this.built=!0}getWeights(e=!1){return t2(e?this.trainableWeights:this.weights)}setWeights(e){ce(()=>{const t=this.weights;if(t.length!==e.length)throw new ae(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=t2(t);for(let i=0;i<r.length;++i){const a=r[i],o=t[i],l=e[i];if(!yt(a.shape,l.shape))throw new ae(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);s.push([o,l])}qS(s)})}addWeight(e,t,s,r,i,a,o,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new ae(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():pn("zeros"));const c=r.apply(t,s),d=new Cne(c,s,e,a,o);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(d.read())),a==null&&(a=!0),a?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=jt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=jt(t),a=jt(r);if(i.length!==a.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let o=0;o<i.length;o++)i[o].kerasMask=a[o]}addInboundNode(e,t,s,r,i,a,o=null){const l=jt(e);t=jt(t),s=jt(s),r=jt(r),i=Hy(i),a=Hy(a);const c=[],d=[],f=[];for(const p of l)c.push(p.sourceLayer),d.push(p.nodeIndex),f.push(p.tensorIndex);new o0({outboundLayer:this,inboundLayers:c,nodeIndices:d,tensorIndices:f,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:a},o);for(let p=0;p<t.length;p++)t[p].sourceLayer=this,t[p].nodeIndex=this.inboundNodes.length-1,t[p].tensorIndex=p}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Ine(n){n=jt(n);const e=[];for(const t of n)e.push(t.shape);return sr(e)}function Tne(n){return"float32"}function o_(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const a=s.inputTensors[i],o=s.inboundLayers[i],l=s.nodeIndices[i],c=o_(a,o,l);for(const d of c)r.indexOf(d)===-1&&r.push(d)}return r}}}function Ene(n){let e=!0;for(const t of jt(n))if(!(t instanceof ya)){e=!1;break}return e}function Rne(n){let e=!0;for(const t of jt(n))if(t instanceof ya){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class km extends wt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:i0("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ae("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new ae("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ae("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new ya(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new o0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ae(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}km.className="InputLayer";Ee(km);function Ane(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new ae("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new km({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Dne(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return De(e,n.dtype)}catch{throw new ae(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class zo{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof zo)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Dne(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new ae(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ya){if(this.id2Value[e.id]==null)throw new ae(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ae(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ya){if(this.id2Value[e.id]==null)throw new ae(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ae(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&et(this.id2Mask)}}const qy=new GD,Xy=new GD;function _ne(n){qy?.setMaxEntries(n),Xy?.setMaxEntries(n)}function zf(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),a=i?n:[n],o=a.map(x=>x.name),l=[],c=e.names();for(const x of o)c.indexOf(x)!==-1?l.push(e.getValue(x)):l.push(null);const d=o.join(",")+"|"+e.names().sort().join(",");let f=qy.get(d),p;if(f==null){const x=One(a,e);f=x.sorted,p=x.recipientCounts,qy.put(d,f),Xy.put(d,p)}p={},r||Object.assign(p,Xy.get(d));const g=new zo(e);for(let x=0;x<f.length;++x){const b=f[x],v=b.sourceLayer;if(v instanceof km)continue;const w=[],$=[],I=[];let N=!1;for(const z of b.inputs){const P=g.getValue(z),_=g.getMask(z);w.push(P),$.push(_),_!=null&&(N=!0),r||(p[z.name]--,p[z.name]===0&&!e.hasKey(z)&&o.indexOf(z.name)===-1&&!P.isDisposed&&z.sourceLayer.stateful!==!0&&I.push(P))}N&&(t=t||{},t.mask=$[0]);const E=jt(v.apply(w,t));let D=null;v.supportsMasking&&(D=v.computeMask(w,$));const O=zne(b),L=Array.isArray(O)?O:[O];for(let z=0;z<L.length;++z){g.hasKey(L[z])||g.add(L[z],E[z],Array.isArray(D)?D[0]:D);const P=o.indexOf(L[z].name);P!==-1&&(l[P]=E[z])}r||et(I)}return g.disposeMasks(),i?l:l[0]}function One(n,e){B(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=IT(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:a,recipientMap:o}=IT(i,e);for(const l of a)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in o)s[l]==null&&(s[l]=new Set),o[l].forEach(c=>s[l].add(c))}}return{sorted:t,recipientCounts:Fne(s)}}function Fne(n){const e={};for(const t in n)e[t]=n[t].size;return e}function IT(n,e){const t=new Set,s=[],r={};for(const o of e.names())t.add(o);const i=[],a=[];for(i.push(n);i.length>0;){const o=i[i.length-1];if(t.has(o.name)){i.pop();continue}const l=a[a.length-1]===i.length-1;if(o.inputs.length===0||l)i.pop(),s.push(o),t.add(o.name),l&&a.pop();else{a.push(i.length-1);for(const c of o.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(o.name),!t.has(c.name)&&i.push(c)}}return{sorted:s,recipientMap:r}}function zne(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lne=fe();Lne.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,_ne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function XS(n,e){return ce(()=>Ss(je(Q(n,n),e,!0)))}class Nm extends ud{getConfig(){return{}}}class l_ extends Nm{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>{const t=XS(e,this.axis),s=lr(t,0,this.maxValue);return Q(e,Pe(s,Ce(Kn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}l_.className="MaxNorm";Ee(l_);class u_ extends Nm{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>Pe(e,Ce(Kn(),XS(e,this.axis))))}getConfig(){return{axis:this.axis}}}u_.className="UnitNorm";Ee(u_);class c_ extends Nm{apply(e){return ba(e)}}c_.className="NonNeg";Ee(c_);class h_ extends Nm{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>{const t=XS(e,this.axis),s=Ce(Q(this.rate,lr(t,this.minValue,this.maxValue)),Q(1-this.rate,t));return Q(e,Pe(s,Ce(Kn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}h_.className="MinMaxNorm";Ee(h_);const TT={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Zn(n){return LS(n)}function ET(n,e={}){return wm(n,ci.getMap().classNameMap,e,"constraint")}function Jn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in TT?TT[n]:n,config:{}};return ET(t)}else return n instanceof Nm?n:ET(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Bl(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const a=i;e.push(a.data()),t.push(r),s.push(a)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];et(s)}}function d_(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var RT;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(RT||(RT={}));const Pne=125;class tp{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Mne{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Bne extends tp{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;const o=ce(()=>Ce(this.totals[r],Q(i,s)));this.totals[r]=o,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:ce(()=>{const r=Q(Pe(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),cs(t[s])}))}}class Vne extends tp{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const a=this.history[i];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){const l=a[o];e.push(l.data()),t.push(i),s.push(o)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class Une extends tp{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||TA,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Pne),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");fw(this.yieldEvery)&&(this.maybeWait=tne(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await Bl(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Bl(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await Bl(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Bl(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await Bl(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):fw(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Bl(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Bl(e),await this.trainEnd(e))}}function f_(n,e){return n==null&&(n={}),n instanceof tp?[n]:Array.isArray(n)&&n[0]instanceof tp?n:jt(n).map(s=>new Une(s,e))}class li{constructor(){}static registerCallbackConstructor(e,t){B(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),li.checkForDuplicate(t),li.constructors[e]==null&&(li.constructors[e]=[]),li.constructors[e].push(t)}static checkForDuplicate(e){for(const t in li.constructors)li.constructors[+t].forEach(r=>{if(r===e)throw new ae("Duplicate callback constructor.")})}static clear(){li.constructors={}}static createCallbacks(e){const t=[];for(const s in li.constructors){const r=+s;e>=r&&t.push(...li.constructors[r])}return t.map(s=>new s)}}li.constructors={};function p_(n,e,t,s,r,i,a,o,l){const c=new Vne,d=[new Bne,...li.createCallbacks(e)];n!=null&&d.push(...n),d.push(c);const f=new Mne(d);return f.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:f,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Xa(n,e={},t=!1){return wm(n,ci.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ky(n,e){return ce(()=>{n.dtype!=="float32"&&(n=De(n,"float32"));const t=je(Cm(n),e,!0),s=id(t.shape,Kn()),r=Ss(Za(t,s));return Pe(n,r)})}function l0(n,e){return ce(()=>$n(Cm(Me(e,n)),-1))}function KS(n,e){return ce(()=>$n(Xn(Me(e,n)),-1))}function YS(n,e){return ce(()=>{const t=Me(n,e),s=lr(Xn(n),Kn(),Number.MAX_VALUE),r=Xn(Pe(t,s));return Q(100,$n(r,-1))})}function Wne(n,e){return ce(()=>{const t=lr(e,Kn(),Number.MAX_VALUE),s=Wr(Ce(1,t)),r=lr(n,Kn(),Number.MAX_VALUE),i=Wr(Ce(1,r));return $n(Cm(Me(s,i)),-1)})}function Gne(n,e){return ce(()=>{const t=Za(0,Me(1,Q(n,e)));return $n(Cm(t),-1)})}function Hne(n,e){return ce(()=>{const t=Za(0,Me(1,Q(n,e)));return $n(t,-1)})}function jne(n,e){return ce(()=>{const t=je(Q(n,e),-1),s=mi(Q(Me(1,n),e),-1);return Za(0,Ce(1,Me(s,t)))})}function qne(n,e){return ce(()=>{const t=Math.log(2),s=Me(e,n),r=Me(Ce(s,ad(Q(-2,s))),t);return $n(r,-1)})}function np(n,e,t=!1){return ce(()=>{if(t)e=Cb(e);else{const s=je(e,e.shape.length-1,!0);e=Pe(e,s)}return e=lr(e,Kn(),1-Kn()),fn(je(Q(De(n,"float32"),Wr(e)),e.shape.length-1))})}function Yy(n,e,t=!1){return ce(()=>{const s=De(mm(fne(n)),"int32");e=lr(e,Kn(),1-Kn());const r=e.shape,i=ie(X2(s,r[r.length-1]),r);return np(i,e,t)})}function Xne(n,e){if(!yt(n.shape,e.shape))throw new ae(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return ce(()=>{const t=ba(e),s=fn(Xn(e));return Ce(Me(t,Q(e,n)),fb(js(s)))})}function u0(n,e){return ce(()=>{let t;return t=lr(e,Kn(),1-Kn()),t=Wr(Pe(t,Me(1,t))),$n(Xne(n,t),-1)})}function Kne(n,e){return ce(()=>{const t=lr(n,Kn(),1),s=lr(e,Kn(),1);return je(Q(n,Wr(Pe(t,s))),-1)})}function Yne(n,e){return ce(()=>{const t=Wr(Ce(Kn(),e));return $n(Me(e,Q(n,t)),-1)})}function m_(n,e){return ce(()=>{const t=Ky(n,-1),s=Ky(e,-1),r=Q(t,s);return fn(je(r,-1))})}const Qy={meanSquaredError:l0,meanAbsoluteError:KS,meanAbsolutePercentageError:YS,meanSquaredLogarithmicError:Wne,squaredHinge:Gne,hinge:Hne,categoricalHinge:jne,logcosh:qne,categoricalCrossentropy:np,sparseCategoricalCrossentropy:Yy,binaryCrossentropy:u0,kullbackLeiblerDivergence:Kne,poisson:Yne,cosineProximity:m_};function nw(n){if(typeof n=="string"){if(n in Qy)return Qy[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ae(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function g_(n,e){return ce(()=>{const t=Q(.5,Gr(e)),s=ha(Er(e,t),n.dtype);return $n(Fi(n,s),-1)})}function y_(n,e){return ce(()=>ha(Fi(cu(n,-1),cu(e,-1)),"float32"))}function Qne(n,e){return ce(()=>De(je(fa(Fi(n,1),Fi(e,1))),"float32"))}function Zne(n,e){return ce(()=>De(je(fa(Fi(n,0),Fi(e,1))),"float32"))}function Jne(n,e){return ce(()=>{const t=Qne(n,e),s=Zne(n,e),r=Ce(t,s);return De(Rs(Er(r,0),Pe(t,r),0),"float32")})}function ese(n,e){return u0(n,e)}function tse(n,e){return n.rank===e.rank&&(n=Mt(n,[n.rank-1])),e=cu(e,-1),e.dtype!==n.dtype&&(e=De(e,n.dtype)),De(Fi(n,e),"float32")}const nse=l0,sse=l0,rse=KS,ise=KS,ase=YS,ose=YS,x_=np,lse=m_,b_=Yy,Zy={binaryAccuracy:g_,categoricalAccuracy:y_,precision:Jne,categoricalCrossentropy:x_,sparseCategoricalCrossentropy:b_,mse:nse,MSE:sse,mae:rse,MAE:ise,mape:ase,MAPE:ose,cosine:lse};function use(n){if(typeof n=="string"&&n in Zy)return Zy[n];if(typeof n!="string"&&n!=null)return n;throw new ae(`Unknown metric ${n}`)}function ry(n){if(aa(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(Qy))if(Qy[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Zy))if(Zy[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cse(n){const e={Adagrad:()=>Ac.adagrad(.01),Adadelta:()=>Ac.adadelta(1,.95,Kn()),Adam:()=>Ac.adam(.001,.9,.999,Kn()),Adamax:()=>Ac.adamax(.002,.9,.999,Kn(),0),RMSProp:()=>Ac.rmsprop(.001,.9,0,Kn()),SGD:()=>Ac.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new ae(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const AT=1*1024*1024;function DT(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!n2(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>AT&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${AT}.`)}}function n2(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!n2(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!n2(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hse(n,e,t,s=console.log){const r=fse(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(d=>Math.floor(e*d)));let a;if(!r){i.push("Receives inputs"),a=[];for(const d in n.nodesByDepth)a.push(...n.nodesByDepth[d])}s("_".repeat(e)),Jy(i,t,s),s("=".repeat(e));const o=n.layers;for(let d=0;d<o.length;++d)r?pse(o[d],t,s):mse(o[d],t,a,s),s((d===o.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=dse(n),c=jy(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function dse(n){let e;return n.collectedTrainableWeights!=null?e=jy(n.collectedTrainableWeights):e=jy(n.trainableWeights),e}function fse(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const a of r.inboundNodes)if(s.indexOf(a)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function Jy(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function pse(n,e,t){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,a=n.getClassName(),o=[`${i} (${a})`,r,s,n.countParams().toString()];Jy(o,e,t)}function mse(n,e,t,s){let r,i;try{i=n.inboundNodes.map(f=>JSON.stringify(f.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const a=[];for(const f of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(f)===-1))for(let p=0;p<f.inboundLayers.length;++p){const g=f.inboundLayers[p].name,x=f.nodeIndices[p],b=f.tensorIndices[p];a.push(`${g}[${x}][${b}]`)}const o=n.name,l=n.getClassName(),c=a.length===0?"":a[0],d=[`${o} (${l})`,i,r,n.countParams().toString(),c];Jy(d,e,s);for(let f=1;f<a.length;++f)Jy(["","","","",a[f]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function v_(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function s2(n,e){if(n===null)return null;if(typeof n=="string")return Xl(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];v_(e,r,i)?t.push(i):t.push(s2(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=Xl(s);t[i]=s2(r,i)}}return t}}function r2(n,e){if(n==null)return null;if(typeof n=="string")return Ua(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];v_(e,r,i)?t.push(i):t.push(r2(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=Ua(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=r2(r,s)}return t}}/** @license See the LICENSE file. */const w_="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const gse=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class Ei extends wt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const $=this.getClassName().toLowerCase();this.name=i0($)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Mo(this.inputs).length!==this.inputs.length)throw new ae(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map($=>$.name)}`);Mo(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map($=>$.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const $ of this.outputs){const I=$.sourceLayer,N=$.nodeIndex,E=$.tensorIndex;this.outputLayers.push(I),this.outputLayersNodeIndices.push(N),this.outputLayersTensorIndices.push(E)}for(const $ of this.inputs){const I=$.sourceLayer,N=$.nodeIndex,E=$.tensorIndex;aa(N===0,"input layer has >1 nodes"),aa(E===0,"input layer has >1 tensors"),this.inputLayers.push(I),this.inputLayersNodeIndices.push(N),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let $=0;$<this.inputLayers.length;$++){const I=this.inputLayers[$];if(!(I instanceof km))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${$} (0-based) originates from layer type ${I.getClassName()}.`);this.inputNames.push(I.name),this.feedInputShapes.push(I.batchInputShape),this.feedInputNames.push(I.name)}for(const $ of this.outputLayers)this.outputNames.push($.name);this.internalInputShapes=this.inputs.map($=>$.shape),this.internalOutputShapes=this.outputs.map($=>$.shape);const t={},s={},r={},i={},a={},o=[],l=($,I,N,E,D,O)=>{(E==null||D==null||O==null)&&(E=$.sourceLayer,D=$.nodeIndex,O=$.tensorIndex);const L=E.inboundNodes[D];if(N.indexOf(L)!==-1)throw new di(`The tensor ${$.name} at layer "${E.name}" is part of a cycle.`);if(I.indexOf(L)!==-1)return;this.containerNodes.add(Ei.nodeKey(E,D)),E.id in a||(a[E.id]=Object.keys(a).length),N.indexOf(L)===-1&&N.push(L);const z=L.inboundLayers.length;for(let P=0;P<z;P++){const _=L.inputTensors[P],H=L.inboundLayers[P],q=L.nodeIndices[P],ee=L.tensorIndices[P];l(_,I,N,H,q,ee)}for(I.push(L);N.indexOf(L)>=0;)N.splice(N.indexOf(L),1);o.push(L)},c=[],d=[];for(const $ of this.outputs)l($,c,d);const f=o.slice().reverse();for(const $ of f){s[$.id]=$,$.id in t||(t[$.id]=0);let I=t[$.id];const N=r[$.outboundLayer.id]==null?0:r[$.outboundLayer.id];I=Math.max(I,N),r[$.outboundLayer.id]=I,i[$.outboundLayer.id]=$.outboundLayer,t[$.id]=I;for(let E=0;E<$.inboundLayers.length;E++){const D=$.inboundLayers[E],O=$.nodeIndices[E],L=D.inboundNodes[O],z=t[L.id]==null?0:t[L.id];t[L.id]=Math.max(I+1,z),s[L.id]=L}}const p={};for(const $ in t){const I=t[$];I in p||(p[I]=[]),p[I].push(s[$])}const g={};for(const $ in r){const I=r[$];I in g||(g[I]=[]),g[I].push(i[$])}let x=Object.keys(g).map($=>parseInt($,10)).sort(ty);this.layers=[];for(const $ of x){const I=g[$];I.sort((N,E)=>{const D=a[N.id],O=a[E.id];return D<O?-1:D>O?1:0});for(const N of I)N instanceof Ei&&this.internalContainerRefs.push(N),this.layers.push(N)}this.layersByDepth=g,x=Object.keys(p).map($=>parseInt($,10)).sort(ty);const b=this.inputs.slice(),v=[];for(const $ of x)for(const I of p[$]){const N=I.outboundLayer;if(N!=null){for(const E of I.inputTensors)if(b.indexOf(E)===-1)throw new di(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${N.name}". The following previous layers were accessed without issue: ${v}`);for(const E of I.outputTensors)b.push(E);v.push(N.name)}}this.nodesByDepth=p;const w=this.layers.map($=>$.name);for(const $ of w){const I=w.filter(N=>N===$).length;if(I!==1)throw new di(`The name "${$}" is used ${I} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(w))}this.outboundNodes=[],this.inboundNodes=[],new o0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map($=>null),outputMasks:this.outputs.map($=>null),inputShapes:this.inputs.map($=>$.shape),outputShapes:this.outputs.map($=>$.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ae("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=gse(e);i&&this.parseWeights(e);for(const o of this.layers)for(const[l,c]of o.weights.entries()){const d=i?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(s[d]!=null)throw new ae(`Duplicate weight name: ${d}`);s[d]=c,r++}const a=[];for(const o in e){let l=o;if(s[o]==null){const c=o.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[l]!=null)a.push([s[l],e[o]]);else if(t)throw new ae(`Provided weight data has no target variable: ${o}`);delete s[l]}if(t){const o=[];for(const l in s)o.push(l);if(o.length>0)throw new ae(`${o.length} of ${r} weights are not set: ${o}`)}qS(a)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!r.includes(a)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${w_}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=r2(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return ce(()=>{e=jt(e);const s=new zo;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return zf(this.outputs,s,t)})}computeMask(e,t){return ce(()=>{e=jt(e);let s;return t==null?s=yu(null,e.length):s=jt(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=Hy(e);if(t.length!==this.inputLayers.length)throw new ae(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<t.length;o++){const l=this.inputLayers[o],c=t[o],d=l.name+"_0_0";s[d]=c}const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(ty);if(r.length>1)for(const o of r){const l=this.nodesByDepth[o];for(const c of l){const d=c.outboundLayer;if(this.inputLayers.map(b=>b.id).indexOf(d.id)!==-1)continue;const f=[];for(let b=0;b<c.inboundLayers.length;b++){const v=c.inboundLayers[b],w=c.nodeIndices[b],$=c.tensorIndices[b],I=`${v.name}_${w}_${$}`,N=s[I];f.push(N)}const p=d.computeOutputShape(sr(f)),g=Hy(p),x=d.inboundNodes.indexOf(c);for(let b=0;b<g.length;b++){const v=`${d.name}_${x}_${b}`;s[v]=g[b]}}}const i=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],d=this.outputLayersTensorIndices[o],f=`${l.name}_${c}_${d}`;a.push(f)}for(let o=0;o<a.length;o++){const l=a[o];aa(l in s),i.push(s[l])}return sr(i)}runInternalGraph(e,t){t==null&&(t=yu(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],d=e[l],f=t[l];s[c.id]=[d,f]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(ty);for(const l of r){const c=this.nodesByDepth[l];for(const d of c){const f=d.outboundLayer,p=d.inputTensors,g=d.outputTensors,x=new Array;for(const b of p)b.id in s&&x.push(s[b.id]);if(x.length===p.length){let b={},v,w,$,I;if(d.callArgs!=null&&(b=d.callArgs),x.length===1){const[N,E]=x[0];b.mask==null&&(b.mask=E),$=jt(f.call(N,b)),I=jt(f.computeMask(N,E)),v=[N],w=[E]}else v=x.map(N=>N[0]),w=x.map(N=>N[1]),b.mask==null&&(b.mask=w),$=jt(f.call(v,b)),I=jt(f.computeMask(v,w));if(f.activityRegularizer)throw new bt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let N=0;N<g.length;++N){const E=g[N],D=$[N],O=I[N];s[E.id]=[D,O]}}}}const i=[],a=[],o=[];for(const l of this.outputs){aa(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,d]=s[l.id];o.push(c.shape),i.push(c),a.push(d)}return[i,a,o]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof Ei?1:0;for(let i=0;i<r.inboundNodes.length;i++){const a=Ei.nodeKey(r,i);this.containerNodes.has(a)&&(t[a]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new ae("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new ae(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new ae(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return ce(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=Ei.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const o=a.getClassName(),l=a.getConfig(),c=[];for(let f=0;f<a.inboundNodes.length;f++){const p=a.inboundNodes[f],g=Ei.nodeKey(a,f);let x={};if(this.containerNodes.has(g)){if(p.callArgs)try{JSON.stringify(p.callArgs),x=p.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),x={}}if(p.inboundLayers.length>0){const b=[];for(let v=0;v<p.inboundLayers.length;v++){const w=p.inboundLayers[v],$=p.nodeIndices[v],I=p.tensorIndices[v],N=Ei.nodeKey(w,$);let E=t[N];E==null&&(E=0),b.push([w.name,E,I,x])}c.push(b)}}}const d={};d.name=a.name,d.className=o,d.config=l,d.inboundNodes=c,s.push(d)}e.layers=s;const r=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],l=this.inputLayersNodeIndices[a],c=Ei.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let d=t[c];d==null&&(d=0);const f=this.inputLayersTensorIndices[a];r.push([o.name,d,f])}e.inputLayers=r;const i=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=Ei.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let d=t[c];d==null&&(d=0);const f=this.outputLayersTensorIndices[a];i.push([o.name,d,f])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},a={};function o(v,w){v.name in a?a[v.name].push(w):a[v.name]=[w]}function l(v,w){const $=[];let I;for(const N of w){const E=N[0],D=N[1],O=N[2];if(I=N[3]==null?{}:N[3],!(E in i)){o(v,w);return}const L=i[E];if(L.inboundNodes.length<=D){o(v,w);return}const z=L.inboundNodes[D];$.push(z.outputTensors[O])}$.length>0&&v.apply(sr($),I)}function c(v){const w=v.name,$=Xa(v,t.customObjects!=null?t.customObjects:{});$.setFastWeightInitDuringBuild(r),i[w]=$,v.inboundNodes.forEach(N=>{if(!(N instanceof Array))throw new ae(`Corrupted configuration, expected array for nodeData: ${N}`);o($,N)})}const d=t.name,f=t.layers;for(const v of f)c(v);for(;!ene(a);)for(const v of f){const w=i[v.name];if(w.name in a){const $=a[w.name];delete a[w.name];for(const I of $)l(w,I)}}const p=[],g=[],x=t.inputLayers;for(const v of x){const w=v[0],$=v[1],I=v[2];aa(w in i);const E=i[w].inboundNodes[$].outputTensors;p.push(E[I])}const b=t.outputLayers;for(const v of b){const w=v[0],$=v[1],I=v[2];aa(w in i);const E=i[w].inboundNodes[$].outputTensors;g.push(E[I])}return new e({inputs:p,outputs:g,name:d})}get stateful(){if(this._stateful)throw new ae("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ce(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yse(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function S_(n,e){return yse(n,e,"classWeight")}async function C_(n,e,t,s){if(t!=null){const r=ce(()=>{if(n.shape.length===1)return ja(n);if(n.shape.length===2){if(n.shape[1]>1)return cu(n,1);if(n.shape[1]===1)return ie(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());et(r);const a=[];return i.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(t[o])}),Wn(a,"float32")}else return null}function xse(n,e){return Q(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const bse=32;function $_(n,e){let t,s;const r=e;t=r.xs,s=r.ys,B(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=_T("input",n.inputNames,t),a=_T("output",n.outputNames,s),o=i[0].shape[0];B(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),B(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)B(i[l].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let l=0;l<a.length;l++)B(a[l].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:i,ys:a}}function _T(n,e,t){if(t instanceof Gt)return[t];if(Array.isArray(t))return B(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new ae(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function vse(n){if(n.length===3)throw new bt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function wse(n,e,t){const s=t.batchesPerEpoch!=null;if(B(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),B(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),B(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),B(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),B(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,a;if(r)if(OT(t.validationData))B(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const v=vse(t.validationData);i=v.xs,a=v.ys}const o=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;r?c=l.slice().concat(l.map(v=>"val_"+v)):c=l.slice();const d=f_(t.callbacks,t.yieldEvery),f=t.verbose==null?1:t.verbose,{callbackList:p,history:g}=p_(d,f,t.epochs,null,null,Sse(e,t),null,r,c);p.setModel(n),n.history=g,await p.onTrainBegin(),n.stopTraining_=!1;let x=t.initialEpoch==null?0:t.initialEpoch,b=await e.iterator();for(;x<t.epochs;){const v={};await p.onEpochBegin(x);let w=0,$=0;for(s||(b=await e.iterator());!s||w<t.batchesPerEpoch;){const I=await b.next();if(s&&I.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${w} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(I.value!=null){const{xs:N,ys:E}=$_(n,I.value),D={};D.batch=$,D.size=N[0].shape[0],await p.onBatchBegin($,D);const O=[];if(t.classWeight!=null){const P=S_(t.classWeight,n.outputNames);for(let _=0;_<P.length;++_)O.push(await C_(E[_],null,P[_]))}const L=N.concat(E).concat(O),z=o(L);et(L);for(let P=0;P<l.length;++P){const _=l[P],H=z[P];D[_]=H,cs(H)}await p.onBatchEnd($,D),d_(D),$++,w++}if(s?w>=t.batchesPerEpoch:I.done){if(r){let N;OT(t.validationData)?N=jt(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):N=jt(n.evaluate(i,a,{batchSize:t.validationBatchSize==null?bse:t.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)v[`val_${n.metricsNames[E]}`]=N[E]}break}if(n.stopTraining_)break}if(await p.onEpochEnd(x,v),x++,n.stopTraining_)break}return await p.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Sse(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function OT(n){return typeof n.iterator=="function"}function Cse(n){return typeof n.next=="function"}async function $se(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new bt("Verbose mode is not implemented yet.");B(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=Cse(e)?e:await e.iterator();let o=0,l=0;for(;!s||l<t.batches;){const c=await a.next();if(i=ce(()=>{if(c.value){const{xs:d,ys:f}=$_(n,c.value),p=d.concat(f),g=ce(()=>r(p));if(et(p),l===0)for(let b=0;b<g.length;++b)i.push(Qe(0));const x=p[0].shape[0];for(let b=0;b<g.length;++b){const v=g[b],w=i[b];i[b]=ce(()=>Ce(i[b],Q(x,v))),l>0&&et(w)}et(g),o+=x,++l}return i}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const d=i[c];i[c]=Pe(i[c],o),et(d)}return sr(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sw(n){B(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Rf(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>su(s,e,t-e)):su(n,e,t-e)}function i2(n,e){return ce(()=>n==null?null:Array.isArray(n)?n.map(t=>i2(t,e)):ZD(n,e.dtype==="int32"?e:De(e,"int32")))}function rw(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function k_(n){const e=[];n instanceof Gt&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(Sm(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Ti(n,e){if(n==null)return;const t=[];if(e instanceof Gt)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof Gt)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kse(n){return n instanceof Gt}function a2(n){return Array.isArray(n)}function FT(n){return!kse(n)&&!a2(n)}function zT(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let a=!1;if(a2(n)&&n.length>0)a=!0;else if(FT(n)){for(const o in n)if(n.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new ae(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(a=>null);let i;if(FT(n)){n=n,i=[];for(const a of e){if(n[a]==null)throw new ae(`No data provided for "${a}". Need data for each key in: ${e}`);i.push(n[a])}}else if(a2(n)){if(n=n,n.length!==e.length)throw new ae(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new ae(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=k_(i),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=i[a];if(o.shape.length!==t[a].length)throw new ae(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<t[a].length;++l){if(l===0&&!s)continue;const c=o.shape[l],d=t[a][l];if(d!=null&&d>=0&&c!==d)throw new ae(`${r} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return i}function Nse(n,e,t){const s=Mo(n.map(i=>i.shape[0]));s.sort();const r=Mo(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new ae(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new ae(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!yt(s,r))throw new ae(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function Ise(n,e,t){const s=[l0,u0,np];for(let r=0;r<n.length;++r){const i=n[r],a=e[r],o=t[r];if(a!=null){if(a===np&&i.shape[i.shape.length-1]===1)throw new ae(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const l=i.shape.slice(1),c=o.slice(1);for(let d=0;d<l.length;++d){const f=l[d],p=c[d];if(p!=null&&f!==p)throw new ae(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function LT(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new ae(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new ae(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=i[a];if(o.shape.length!==t[a].length)throw new ae(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<t[a].length;++l){if(l===0&&!s)continue;const c=o.shape[l],d=t[a][l];if(d!=null&&d!==c)throw new ae(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function Tse(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const Ese="layers-model";class jc extends Ei{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new ae("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");hse(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=cse(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof rl))throw new ae("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new ae(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(nw(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ae(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>nw(o))}else{const a=nw(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const o=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nu("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const r=Tse(e.metrics,this.outputNames),i=(a,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,a])};nu("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=r[a];(c=>{const d="";let f,p,g;for(const x of c){if(typeof x=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(x)!==-1){const v=this.internalOutputShapes[a];v[v.length-1]===1||this.lossFunctions[a]===u0?["accuracy","acc"].indexOf(x)!==-1?p=g_:["crossentropy","ce"].indexOf(x)!==-1&&(p=ese):this.lossFunctions[a]===Yy?["accuracy","acc"].indexOf(x)!==-1?p=tse:["crossentropy","ce"].indexOf(x)!==-1&&(p=b_):["accuracy","acc"].indexOf(x)!==-1?p=y_:["crossentropy","ce"].indexOf(x)!==-1&&(p=x_);let w;["accuracy","acc"].indexOf(x)!==-1?w="acc":["crossentropy","ce"].indexOf(x)!==-1&&(w="ce"),g=p,f=d+w}else g=use(x),f=d+ry(x);let b;nu(f,()=>{b=g}),i(a,f,b)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;sw(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const o=a[0].concat(a[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,o,r,s.verbose,s.steps);return sr(c)}finally{Ti(a[0],e),Ti(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),$se(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new ae(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new ae(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new ae("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),a=new zo;if(e instanceof Gt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ae(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new ae(`No value is provided for the model's input ${l.name}`);a.add(l,c)}const o=zf(i,a);return s?o:o[0]}retrieveSymbolicTensors(e){const t=yu(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],a=i.map(o=>o.name);for(let o=0;o<e.length;++o){const l=a.indexOf(e[o]);if(l!==-1&&(t[o]=i[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,a)=>{i==null&&r.push(e[a])}),new ae(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return ce(()=>{const r=this.checkNumSamples(e);if(s)throw new bt("Verbose predictLoop() is not implemented yet.");const i=rw(r,t),a=this.outputs.map(o=>[]);for(let o=0;o<i.length;++o)ce(()=>{const c=i[o][0],d=i[o][1],f=Rf(e,c,d),p=[];if(Array.isArray(f))for(let x=0;x<f.length;++x)p.push({key:this.inputs[x],value:f[x]});else p.push({key:this.inputs[0],value:f});const g=new zo(p);return zf(this.outputs,g)}).forEach((c,d)=>a[d].push(c));return sr(a.map(o=>vn(o,0)))})}predict(e,t={}){const s=k_(e);LT(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return sw(r),this.predictLoop(s,r)}finally{Ti(s,e)}}predictOnBatch(e){LT(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new di("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const o=this.feedOutputShapes[a];this.feedLossFns[a]===Yy?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(e=zT(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=zT(t,this.feedOutputNames,i,!1,"target"),Nse(e,t),Ise(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new ae(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,a){const[o,l]=this.standardizeUserDataXY(e,t,i,a);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const d=S_(r,this.outputNames);c=[];for(let f=0;f<d.length;++f)c.push(await C_(l[f],null,d[f]))}return[o,l,c]}testLoop(e,t,s,r=0,i){return ce(()=>{const a=this.checkNumSamples(t,s,i,"steps"),o=[];if(r>0)throw new bt("Verbose mode is not implemented yet.");if(i!=null)throw new bt("steps mode in testLoop() is not implemented yet");{const l=rw(a,s),c=Wn(Mi(0,a));for(let d=0;d<l.length;++d){const f=l[d][0],p=l[d][1],g=su(c,f,p-f),x=i2(t,g),b=e(x);if(d===0)for(let v=0;v<b.length;++v)o.push(Qe(0));for(let v=0;v<b.length;++v){const w=b[v];o[v]=Ce(o[v],Q(p-f,w))}}for(let d=0;d<o.length;++d)o[d]=Pe(o[d],a)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(wT(e,r)>1){const a=wT(e.slice(0,s),r);i+=`_${a}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{const f=[];for(let b=0;b<this.inputs.length;++b)f.push({key:this.inputs[b],value:s[b]});const p=new zo(f),g=zf(this.outputs,p,{training:!0});let x;for(let b=0;b<this.lossFunctions.length;++b){const v=this.lossFunctions[b];let w=v(r[b],g[b]);i[b]!=null&&(w=xse(w,i[b]));const $=$n(w);t.push($),b===0?x=w:x=Ce(x,w)}for(let b=0;b<this.metricsTensors.length;++b){let v;if(this.outputs.length>1&&b<this.outputs.length)v=t[b];else{const w=this.metricsTensors[b][0],$=this.metricsTensors[b][1];v=$n(w(r[$],g[$]))}cs(v),a.push(v)}return x=$n(x),this.calculateLosses().forEach(b=>{x=Ce(x,b)}),x},l=this.collectedTrainableWeights.map(f=>f.read());return[this.optimizer_.minimize(o,!0,l)].concat(a)}}makeTestFunction(){this.testFunction=e=>ce(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:r[c]});const o=new zo(a),l=zf(this.outputs,o);for(let c=0;c<this.lossFunctions.length;++c){const d=this.lossFunctions[c],f=$n(d(i[c],l[c]));c===0?s=f:s=Ce(s,f),t.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const d=this.metricsTensors[c][0],f=this.metricsTensors[c][1],p=$n(d(i[f],l[f]));t.push(p)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,a,o,l,c,d,f,p;try{const g=s.batchSize==null?32:s.batchSize;sw(g);const b=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,g);r=b[0],i=b[1],p=b[2];let v=!1,w;if(s.validationData!=null&&s.validationData.length>0){if(v=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new bt("validationData including sample weights is not supported yet."):new ae(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const P=await this.standardizeUserData(l,c,null,null,!0,g);d=P[0],f=P[1],w=d.concat(f)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){v=!0;const z=Math.floor(r[0].shape[0]*(1-s.validationSplit)),P=r[0].shape[0];d=Rf(r,z,P),a=r,r=Rf(r,0,z),f=Rf(i,z,P),o=i,i=Rf(i,0,z),w=d.concat(f)}else s.validationSteps!=null&&(v=!0);const $=r.concat(i).concat(p);this.checkTrainableWeightsConsistency();const I=this.makeTrainFunction(),N=this.getDedupedMetricsNames();let E,D;v?(this.makeTestFunction(),E=this.testFunction,D=N.slice().concat(N.map(z=>"val_"+z))):(E=null,w=[],D=N.slice());const O=f_(s.callbacks,s.yieldEvery);return await this.fitLoop(I,$,N,g,s.epochs,s.verbose,O,E,w,s.shuffle,D,s.initialEpoch,null,null)}finally{this.isTraining=!1,Ti(r,e),Ti(i,t),Ti(a,e),Ti(o,t),Ti(d,l),Ti(f,c),p!=null&&et(p)}}async fitLoop(e,t,s,r,i,a,o,l,c,d,f,p,g,x){r==null&&(r=32),i==null&&(i=1),d==null&&(d=!0),p==null&&(p=0);let b=!1;if(l!=null&&c!=null&&(b=!0),x!=null&&(b=!0,g==null))throw new ae("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const v=this.checkNumSamples(t,r,g,"steps_per_epoch");let w;v!=null&&(w=Mi(0,v)),a==null&&(a=1);const{callbackList:$,history:I}=p_(o,a,i,p,v,g,r,b,f);$.setModel(this),this.history=I,await $.onTrainBegin(),this.stopTraining_=!1;for(let N=p;N<i;++N){await $.onEpochBegin(N);const E={};if(g!=null)throw new bt("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new bt("batch shuffling is not implemneted yet");d&&JL(w);const D=Wn(w),O=rw(v,r);for(let L=0;L<O.length;++L){const z={};if(await $.onBatchBegin(L,z),ce(()=>{const P=O[L][0],_=O[L][1],H=su(D,P,_-P);z.batch=L,z.size=_-P;const q=i2(t,H),ee=e(q);for(let Y=0;Y<s.length;++Y){const G=s[Y],te=ee[Y];z[G]=te,cs(te)}if(L===O.length-1&&b){const Y=this.testLoop(l,c,r);for(let G=0;G<s.length;++G){const te=s[G],re=Y[G];cs(re),E["val_"+te]=re}}}),await $.onBatchEnd(L,z),d_(z),this.stopTraining_)break}D.dispose()}if(await $.onEpochEnd(N,E),this.stopTraining_)break}return await $.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return wse(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],o=this.makeTrainFunction()(r.concat(i)),l=[];for(const c of o){const d=await c.data();l.push(d[0])}return et(o),Ti(s[0],e),Ti(s[1],t),sr(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<r.length;++a)s&&!r[a].trainable||t.push({name:r[a].originalName,tensor:i[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=HN().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-HN().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Ua(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Ua(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=Ua(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Ua(ry(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ua(ry(e)));{const e={};for(const t in this.metrics)e[t]=Ua(ry(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=s2(e.optimizer_config),s=Xa(t);let r;if(typeof e.loss=="string")r=Xl(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>Xl(a));else if(e.loss!=null){r={};for(const a in e.loss)r[a]=Xl(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>Xl(a));else if(e.metrics!=null){i={};for(const a in e.metrics)i[a]=Xl(e.metrics[a])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const c=qE(e);if(c.length===0)throw new ae(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new ae(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new ae("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await Sw(this.getNamedWeights(t)),o={modelTopology:this.toJSON(null,!1),format:Ese,generatedBy:`TensorFlow.js tfjs-layers v${w_}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:d,specs:f}=await Sw(await this.optimizer.getWeights(),c);s.specs.push(...f),s.data=GE([s.data,d])}return this.userDefinedMetadata!=null&&(DT(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,e.save(o)}setUserDefinedMetadata(e){DT(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}jc.className="Model";Ee(jc);class N_ extends jc{}N_.className="Functional";Ee(N_);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sp extends jc{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:i0("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ae(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof sp||e instanceof jc;let s;if(t){if(s=e,s.outputs.length!==1)throw new ae("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ae("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ae("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=Ane({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new ae(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ae("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=o_(this.outputs[0])}this.inboundNodes=[],new o0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:yu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Lt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new jc({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new di("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new di("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new di("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new di("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new ae("Legacy serialization format not supported yet.");i=t}else B(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof sp))throw new bt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of i){const d=Xa(l,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(e){if(this.model==null)throw new ae("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ae("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}sp.className="Sequential";Ee(sp);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Ds=class extends ud{getConfig(){return{}}};class I_ extends Ds{apply(e,t=1){return mne(e,t)}}I_.className="elu";Ee(I_);class T_ extends Ds{apply(e){return eS(e)}}T_.className="selu";Ee(T_);class E_ extends Ds{apply(e){return ba(e)}}E_.className="relu";Ee(E_);class R_ extends Ds{apply(e){return ce(()=>jo(6,ba(e)))}}R_.className="relu6";Ee(R_);class A_ extends Ds{apply(e){return e}}A_.className="linear";Ee(A_);class D_ extends Ds{apply(e){return Ur(e)}}D_.className="sigmoid";Ee(D_);class __ extends Ds{apply(e){return yne(e)}}__.className="hardSigmoid";Ee(__);class O_ extends Ds{apply(e){return ad(e)}}O_.className="softplus";Ee(O_);class F_ extends Ds{apply(e){return gne(e)}}F_.className="softsign";Ee(F_);class z_ extends Ds{apply(e){return du(e)}}z_.className="tanh";Ee(z_);let QS=class extends Ds{apply(e,t=-1){return Cb(e,t)}};QS.className="softmax";Ee(QS);class L_ extends Ds{apply(e,t=-1){return G2(e,t)}}L_.className="logSoftmax";Ee(L_);class P_ extends Ds{apply(e){return ce(()=>ce(()=>{const t=Math.sqrt(2),s=Q(.5,Ce(1,V2(Pe(e,t))));return Q(e,s)}))}}P_.className="gelu";Ee(P_);class M_ extends Ds{apply(e){return ce(()=>Q(.5,Q(e,Ce(1,du(Q(Ss(Pe(2,Math.PI)),Ce(e,Q(.044715,Ya(e,3)))))))))}}M_.className="gelu_new";Ee(M_);class B_ extends Ds{apply(e){return ce(()=>Q(e,du(ad(e))))}}B_.className="mish";Ee(B_);class V_ extends Ds{apply(e,t=1){return ce(()=>Q(Ur(Q(e,t)),e))}}V_.className="swish";Ee(V_);function Ko(n){return n.getClassName()}function iw(n,e={}){return wm(n,ci.getMap().classNameMap,e,"activation")}function Yo(n){if(n==null){const e={};return e.className="linear",e.config={},iw(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},iw(e)}else return n instanceof Ds?n:iw(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Rse(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class U_ extends ud{}class W_ extends U_{constructor(e){super(),Rse(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ce(()=>{let t=Dn([1]);return this.hasL1&&(t=Ce(t,je(Q(this.l1,Xn(e))))),this.hasL2&&(t=Ce(t,je(Q(this.l2,Cm(e))))),ie(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}W_.className="L1L2";Ee(W_);const PT={l1l2:"L1L2"};function rn(n){return LS(n)}function MT(n,e={}){return wm(n,ci.getMap().classNameMap,e,"regularizer")}function mn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in PT?PT[n]:n,config:{}};return MT(t)}else return n instanceof U_?n:MT(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class G_ extends wt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=ht(e);let s=ba(e);return this.maxValue!=null&&(s=lr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}G_.className="ReLU";Ee(G_);class H_ extends wt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=ht(e);return db(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}H_.className="LeakyReLU";Ee(H_);class j_ extends wt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=pn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=mn(e.alphaRegularizer),this.alphaConstraint=Jn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ae(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Lt(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new Yn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=ht(e),bb(e,this.alpha.read())}getConfig(){const e={alphaInitializer:bn(this.alphaInitializer),alphaRegularizer:rn(this.alphaRegularizer),alphaConstraint:Zn(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}j_.className="PReLU";Ee(j_);let q_=class extends wt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new bt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=ht(e);return fm(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};q_.className="ELU";Ee(q_);class X_ extends wt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=ht(e);return Q(s,De(Er(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}X_.className="ThresholdedReLU";Ee(X_);class K_ extends wt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new QS().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return ce(()=>{let s=ht(e);const r=t.mask;if(r!=null){const i=Q(Me(Sr(s.shape),De(r,s.dtype)),Qe(-1e9));s=Ce(s,i)}return this.axis instanceof Array?this.axis.length>1?js(Me(s,pb(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}K_.className="Softmax";Ee(K_);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qc(n,e,t){if(typeof n=="number")return yu(n,e);if(n.length!==e)throw new ae(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!hne(r))throw new ae(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function _i(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let a;return t==="same"?a=n:a=n-i+1,Math.floor((a+s-1)/s)}function oa(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Xo([t-e,0]);else if(s==="same")n=n*e;else throw new ae(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ZS(n,e){return ce(()=>(zn(e),e==="channelsFirst"?Dt(n,[0,2,3,1]):n))}function Y_(n,e){return ce(()=>(zn(e),e==="channelsFirst"?Dt(n,[0,2,3,4,1]):n))}function Ase(n,e,t,s=1,r="valid",i,a=1){return ce(()=>{if(i==null&&(i=Bi()),zn(i),n.shape.length!==3)throw new ae(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new ae(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new ae(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=Dt(n,[0,2,1])),r==="causal")throw new bt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=z2(n,e,s,r==="same"?"same":"valid","NWC",a);return t!=null&&(o=Gi(o,t)),o})}function BT(n,e,t,s=[1,1],r="valid",i,a,o=null){return ce(()=>{if(i==null&&(i=Bi()),zn(i),n.rank!==3&&n.rank!==4)throw new ae(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ae(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=ZS(n,i);if(r==="causal")throw new bt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=JR({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:o}),i==="channelsFirst"&&(l=Dt(l,[0,3,1,2])),l})}function Dse(n,e,t,s=[1,1,1],r="valid",i,a){return ce(()=>{if(i==null&&(i=Bi()),zn(i),n.rank!==4&&n.rank!==5)throw new ae(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ae(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=Y_(n,i);if(r==="causal")throw new bt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=vR(o,e,s,r==="same"?"same":"valid","NDHWC",a),t!=null&&(o=Gi(o,t)),i==="channelsFirst"&&(o=Dt(o,[0,4,1,2,3])),o})}class c0 extends wt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",c0.verifyArgs(t),this.rank=e,hs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new bt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=qc(t.kernelSize,e,"kernelSize"),this.strides=qc(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Xr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,zn(this.dataFormat),this.activation=Yo(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=pn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Jn(t.biasConstraint),this.biasRegularizer=mn(t.biasRegularizer),this.activityRegularizer=mn(t.activityRegularizer),this.dilationRate=qc(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ae(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ae(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ae(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(aa("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!PS(e.kernelSize,"number",1,3))throw new ae(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ko(this.activation),useBias:this.useBias,biasInitializer:bn(this.biasInitializer),biasRegularizer:rn(this.biasRegularizer),activityRegularizer:rn(this.activityRegularizer),biasConstraint:Zn(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class fd extends c0{constructor(e,t){super(e,t),this.kernel=null,fd.verifyArgs(t),this.filters=t.filters,hs(this.filters,"filters"),this.kernelInitializer=pn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Jn(t.kernelConstraint),this.kernelRegularizer=mn(t.kernelRegularizer)}build(e){e=Lt(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ae(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return ce(()=>{e=ht(e);let s;const r=this.bias==null?null:this.bias.read(),i=jD(this.activation.getClassName());if(i!=null&&this.rank===2)s=BT(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=Ase(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=BT(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=Dse(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new bt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Lt(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const a=_i(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:bn(this.kernelInitializer),kernelRegularizer:rn(this.kernelRegularizer),kernelConstraint:Zn(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ae(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Im extends fd{constructor(e){super(2,e),Im.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!PS(e.kernelSize,"number",1,2))throw new ae(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Im.className="Conv2D";Ee(Im);class Tm extends fd{constructor(e){super(3,e),Tm.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ae(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Tm.className="Conv3D";Ee(Tm);class Q_ extends Im{constructor(e){if(super(e),this.inputSpec=[new Yn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ae(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Lt(e),e.length!==4)throw new ae("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ae("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Yn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return ce(()=>{let s=ht(e);if(s.shape.length!==4)throw new ae(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);const l=r[a],c=r[o],d=this.kernelSize[0],f=this.kernelSize[1],p=this.strides[0],g=this.strides[1],x=oa(l,p,d,this.padding),b=oa(c,g,f,this.padding),v=[i,x,b,this.filters];this.dataFormat!=="channelsLast"&&(s=Dt(s,[0,2,3,1]));let w=P2(s,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=Dt(w,[0,3,1,2])),this.bias!=null&&(w=Gi(w,this.bias.read(),this.dataFormat)),this.activation!=null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=Lt(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[s]=this.filters,t[r]=oa(t[r],l,a,this.padding),t[i]=oa(t[i],c,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Q_.className="Conv2DTranspose";Ee(Q_);class Z_ extends Tm{constructor(e){if(super(e),this.inputSpec=[new Yn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ae(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Lt(e),e.length!==5)throw new ae("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ae("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Yn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return ce(()=>{let s=ht(e);if(s.shape.length!==5)throw new ae(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,o,l;this.dataFormat==="channelsFirst"?(l=2,a=3,o=4):(l=1,a=2,o=3);const c=r[l],d=r[a],f=r[o],p=this.kernelSize[0],g=this.kernelSize[1],x=this.kernelSize[2],b=this.strides[0],v=this.strides[1],w=this.strides[2],$=oa(c,b,p,this.padding),I=oa(d,v,g,this.padding),N=oa(f,w,x,this.padding),E=[i,$,I,N,this.filters];this.dataFormat!=="channelsLast"&&(s=Dt(s,[0,2,3,4,1]));let D=SR(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(D=Dt(D,[0,4,1,2,3])),this.bias!==null&&(D=Gi(D,this.bias.read(),this.dataFormat)),this.activation!==null&&(D=this.activation.apply(D)),D})}computeOutputShape(e){e=Lt(e);const t=e.slice();let s,r,i,a;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,a=4):(s=4,r=1,i=2,a=3);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],f=this.strides[1],p=this.strides[2];return t[s]=this.filters,t[r]=oa(t[r],d,o,this.padding),t[i]=oa(t[i],f,l,this.padding),t[a]=oa(t[a],p,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Z_.className="Conv3DTranspose";Ee(Z_);class J_ extends fd{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ae("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ae("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ae(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=pn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=mn(t.depthwiseRegularizer),this.depthwiseConstraint=Jn(t.depthwiseConstraint),this.pointwiseInitializer=pn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=mn(t.pointwiseRegularizer),this.pointwiseConstraint=Jn(t.pointwiseConstraint)}build(e){if(e=Lt(e),e.length<this.rank+2)throw new ae(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new ae(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let o=0;o<this.rank;++o)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Yn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return ce(()=>{e=ht(e);let s;if(this.rank===1)throw new bt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Dt(e,[0,2,3,1])),s=tS(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Gi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Dt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=bn(this.depthwiseInitializer),e.pointwiseInitializer=bn(this.pointwiseInitializer),e.depthwiseRegularizer=rn(this.depthwiseRegularizer),e.pointwiseRegularizer=rn(this.pointwiseRegularizer),e.depthwiseConstraint=Zn(this.depthwiseConstraint),e.pointwiseConstraint=Zn(this.pointwiseConstraint),e}}J_.className="SeparableConv";class eO extends J_{constructor(e){super(2,e)}}eO.className="SeparableConv2D";Ee(eO);class h0 extends fd{constructor(e){super(1,e),h0.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!PS(e.kernelSize,"number",1,1))throw new ae(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}h0.className="Conv1D";Ee(h0);class tO extends wt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ce(()=>{if(e=ht(e),this.dataFormat==="channelsLast"){const s=sy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return sy(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=sy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return sy(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}tO.className="Cropping2D";Ee(tO);class nO extends wt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,zn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,lne(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return ce(()=>{let s=ht(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=Dt(s,[0,2,3,1]);const i=this.size[0]*r[2],a=this.size[1]*r[3],o=this.interpolation==="nearest"?Hs.resizeNearestNeighbor(s,[i,a]):Hs.resizeBilinear(s,[i,a]);return Dt(o,[0,3,1,2])}else{const i=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?Hs.resizeNearestNeighbor(s,[i,a]):Hs.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}nO.className="UpSampling2D";Ee(nO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _se(n,e,t=[1,1],s="valid",r,i){return ce(()=>{r==null&&(r=Bi()),zn(r);let a=ZS(n,r);if(n.rank!==4)throw new ae(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new ae(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=dm(a,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(a=Dt(a,[0,3,1,2])),a})}class sO extends c0{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=pn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Jn(e.depthwiseConstraint),this.depthwiseRegularizer=mn(e.depthwiseRegularizer)}build(e){if(e=Lt(e),e.length<4)throw new ae(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new ae(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{e=ht(e);let s=_se(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Gi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Lt(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=_i(t,this.kernelSize[0],this.padding,this.strides[0]),a=_i(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,a]:[e[0],i,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=bn(this.depthwiseInitializer),e.depthwiseRegularizer=rn(this.depthwiseRegularizer),e.depthwiseConstraint=Zn(this.depthwiseRegularizer),e}}sO.className="DepthwiseConv2D";Ee(sO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rO(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new ae("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function iO(n,e,t,s=!1,r,i,a=!1,o=!1){return ce(()=>{const l=e.shape.length;if(l<3)throw new ae(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Mi(2,l));e=Dt(e,c),a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=De(De(r,"bool"),"float32"),r.rank===l-1&&(r=Un(r,-1)),r=Dt(r,c)),s&&(e=xi(e,0),r!=null&&(r=xi(r,0)));const d=[];let f,p=t;const g=e.shape[0],x=bi(e);let b;r!=null&&(b=bi(r));for(let w=0;w<g;++w){const $=x[w],I=ce(()=>n($,p));if(r==null)f=I[0],p=I[1];else{const N=ce(()=>{const E=b[w],D=Me(Gr(E),E),O=Ce(Q(I[0],E),Q(p[0],D)),L=p.map((z,P)=>Ce(Q(I[1][P],E),Q(z,D)));return{output:O,newStates:L}});f=N.output,p=N.newStates}o&&d.push(f)}let v;return o&&(v=$r(d,1)),[f,v,p]})}class ol extends wt{constructor(e){super(e);let t;if(e.cell==null)throw new ae("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new tC({cells:e.cell}):t=e.cell,t.stateSize==null)throw new ae("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Yn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Mi(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){e2(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const a of t)i.push([e[0],a]);return[r].concat(i)}else return r}computeMask(e,t){return ce(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new bt("Constants support is not implemented in RNN yet.");e2(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Yn({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!yt(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new ae(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new Yn({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){ce(()=>{if(!this.stateful)throw new ia("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ae("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Dn([s,r])):this.states_=[Dn([s,this.cell.stateSize])];else if(e==null)et(this.states_),this.keptStates!=null&&(et(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Dn([s,r])):this.states_[0]=Dn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ae(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):et(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[s,a];if(!yt(i.shape,o))throw new ae(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>cs(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=rO(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let a=[],o=[];if(s!=null){t.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new Yn({shape:c.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof ya){const c=[e].concat(a),d=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=d;const p=super.apply(c,t);return this.inputSpec=f,p}else return super.apply(e,t)}call(e,t){return ce(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=ht(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new ae(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},c=iO((x,b)=>{const v=this.cell.call([x].concat(b),o);return[v[0],v.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],f=c[1],p=c[2];this.stateful&&this.resetStates(p,r);const g=this.returnSequences?f:d;return this.returnState?[g].concat(p):g})}getInitialState(e){return ce(()=>{let t=Dn(e.shape);return t=je(t,[1,2]),t=Sm(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Zw(t,[1,s]):t):this.cell.stateSize>1?[Zw(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===ol.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=Xa(r,s);return new e(Object.assign(t,{cell:i}))}}ol.className="RNN";Ee(ol);class d0 extends wt{}class JS extends d0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,hs(this.units,"units"),this.activation=Yo(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mn(e.kernelRegularizer),this.recurrentRegularizer=mn(e.recurrentRegularizer),this.biasRegularizer=mn(e.biasRegularizer),this.kernelConstraint=Jn(e.kernelConstraint),this.recurrentConstraint=Jn(e.recurrentConstraint),this.biasConstraint=Jn(e.biasConstraint),this.dropout=nh([1,Xo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=nh([1,Xo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Lt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{if(e=e,e.length!==2)throw new ae(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Qo({ones:()=>Gr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Qo({ones:()=>Gr(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?i=da(Q(e,a),this.kernel.read()):i=da(e,this.kernel.read()),this.bias!=null&&(i=Gi(i,this.bias.read())),o!=null&&(s=Q(s,o));let l=Ce(i,da(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ko(this.activation),useBias:this.useBias,kernelInitializer:bn(this.kernelInitializer),recurrentInitializer:bn(this.recurrentInitializer),biasInitializer:bn(this.biasInitializer),kernelRegularizer:rn(this.kernelRegularizer),recurrentRegularizer:rn(this.recurrentRegularizer),biasRegularizer:rn(this.biasRegularizer),activityRegularizer:rn(this.activityRegularizer),kernelConstraint:Zn(this.kernelConstraint),recurrentConstraint:Zn(this.recurrentConstraint),biasConstraint:Zn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}JS.className="SimpleRNNCell";Ee(JS);class aO extends ol{constructor(e){e.cell=new JS(e),super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}aO.className="SimpleRNN";Ee(aO);class eC extends d0{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ae("GRUCell does not support reset_after parameter set to true.");this.units=e.units,hs(this.units,"units"),this.activation=Yo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Yo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mn(e.kernelRegularizer),this.recurrentRegularizer=mn(e.recurrentRegularizer),this.biasRegularizer=mn(e.biasRegularizer),this.kernelConstraint=Jn(e.kernelConstraint),this.recurrentConstraint=Jn(e.recurrentConstraint),this.biasConstraint=Jn(e.biasConstraint),this.dropout=nh([1,Xo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=nh([1,Xo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Lt(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{if(e=e,e.length!==2)throw new ae(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Qo({ones:()=>Gr(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Qo({ones:()=>Gr(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,c;0<this.dropout&&this.dropout<1&&(e=Q(e,i[0]));let d=da(e,this.kernel.read());this.useBias&&(d=Gi(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Q(r,a[0]));const f=this.recurrentKernel.read(),[p,g]=Cr(f,[2*this.units,this.units],f.rank-1),x=da(r,p),[b,v,w]=Cr(d,3,d.rank-1),[$,I]=Cr(x,2,x.rank-1);o=this.recurrentActivation.apply(Ce(b,$)),l=this.recurrentActivation.apply(Ce(v,I));const N=da(Q(l,r),g);c=this.activation.apply(Ce(w,N));const E=Ce(Q(o,r),Q(Ce(1,fn(o)),c));return[E,E]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ko(this.activation),recurrentActivation:Ko(this.recurrentActivation),useBias:this.useBias,kernelInitializer:bn(this.kernelInitializer),recurrentInitializer:bn(this.recurrentInitializer),biasInitializer:bn(this.biasInitializer),kernelRegularizer:rn(this.kernelRegularizer),recurrentRegularizer:rn(this.recurrentRegularizer),biasRegularizer:rn(this.biasRegularizer),activityRegularizer:rn(this.activityRegularizer),kernelConstraint:Zn(this.kernelConstraint),recurrentConstraint:Zn(this.recurrentConstraint),biasConstraint:Zn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}eC.className="GRUCell";Ee(eC);class oO extends ol{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new eC(e),super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}oO.className="GRU";Ee(oO);class f0 extends d0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,hs(this.units,"units"),this.activation=Yo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Yo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=mn(e.kernelRegularizer),this.recurrentRegularizer=mn(e.recurrentRegularizer),this.biasRegularizer=mn(e.biasRegularizer),this.kernelConstraint=Jn(e.kernelConstraint),this.recurrentConstraint=Jn(e.recurrentConstraint),this.biasConstraint=Jn(e.biasConstraint),this.dropout=nh([1,Xo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=nh([1,Xo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Lt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;r=new(t=class extends vi{apply(l,c){const d=i.apply([a]),f=new BS().apply([a]),p=i.apply([a*2]);return CT(CT(d,f),p)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ce(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new ae(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Qo({ones:()=>Gr(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Qo({ones:()=>Gr(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,d,f;0<this.dropout&&this.dropout<1&&(e=Q(e,a[0]));let p=da(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Q(r,o[0])),p=Ce(p,da(r,this.recurrentKernel.read())),this.useBias&&(p=Gi(p,this.bias.read()));const[g,x,b,v]=Cr(p,4,p.rank-1);l=this.recurrentActivation.apply(g),c=this.recurrentActivation.apply(x),d=Ce(Q(c,i),Q(l,this.activation.apply(b))),f=this.recurrentActivation.apply(v);const w=Q(f,this.activation.apply(d));return[w,w,d]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ko(this.activation),recurrentActivation:Ko(this.recurrentActivation),useBias:this.useBias,kernelInitializer:bn(this.kernelInitializer),recurrentInitializer:bn(this.recurrentInitializer),biasInitializer:bn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:rn(this.kernelRegularizer),recurrentRegularizer:rn(this.recurrentRegularizer),biasRegularizer:rn(this.biasRegularizer),activityRegularizer:rn(this.activityRegularizer),kernelConstraint:Zn(this.kernelConstraint),recurrentConstraint:Zn(this.recurrentConstraint),biasConstraint:Zn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}f0.className="LSTMCell";Ee(f0);class lO extends ol{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new f0(e),super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}lO.className="LSTM";Ee(lO);class tC extends d0{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ce(()=>{e=e;let s=e.slice(1);const r=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(s.splice(0,o.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let a;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];s=r[o],o===0?a=[e[0]].concat(s):a=[a[0]].concat(s),a=l.call(a,t),i.push(a.slice(1))}s=[];for(const o of i.slice().reverse())s.push(...o);return[a[0]].concat(s)})}build(e){e2(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{nu(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(Xa(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return t2(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let a=0;a<s.weights.length;++a)t.push([s.weights[a],i[a]])}qS(t)}}tC.className="StackedRNNCells";Ee(tC);function Qo(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,a=()=>i!=null?i(e(),t):JD(e(),t),o=()=>$m(a,e,s);return!r||r<=1?cs(o().clone()):Array(r).fill(void 0).map(o).map(c=>cs(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Ose=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class uO extends ol{constructor(e){if(e.unroll)throw new bt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new bt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Yn({ndim:5})]}call(e,t){return ce(()=>{if(this.cell.dropoutMask!=null&&(et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ae("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ce(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],a=Dn(i);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){ce(()=>{if(!this.stateful)throw new ia("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new ae("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Dn(i)):this.states_=[Dn(i)];else if(e==null)et(this.states_),this.keptStates!=null&&(et(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Dn(i)):this.states_[0]=Dn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ae(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):et(this.states_);for(let o=0;o<this.states_.length;++o){const l=e[o],c=i;if(!yt(l.shape,c))throw new ae(`State ${o} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>cs(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:a,dilationRate:o}=this.cell,l=t==="channelsFirst",c=e[l?3:2],d=e[l?4:3],f=_i(c,r[0],i,a[0],o[0]),p=_i(d,r[1],i,a[1],o[1]);return[...e.slice(0,2),...l?[s,f,p]:[f,p,s]]}}uO.className="ConvRNN2D";class nC extends f0{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,hs(this.filters,"filters"),this.kernelSize=qc(s,2,"kernelSize"),this.kernelSize.forEach(l=>hs(l,"kernelSize")),this.strides=qc(r||1,2,"strides"),this.strides.forEach(l=>hs(l,"strides")),this.padding=i||"valid",Xr(this.padding),this.dataFormat=a||"channelsLast",zn(this.dataFormat),this.dilationRate=qc(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>hs(l,"dilationRate"))}build(e){var t;e=Lt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new ae(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,a=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;l=new(t=class extends vi{apply(p,g){const x=c.apply([d]),b=Sr([d]),v=c.apply([d*2]);return MS([x,b,v])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ce(()=>{if(e.length!==3)throw new ae(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Qo({ones:()=>Gr(r),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(W,ne,pe)=>!ne||!ne[pe]?W:Q(ne[pe],W);let d=c(r,l,0),f=c(r,l,1),p=c(r,l,2),g=c(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Qo({ones:()=>Gr(i),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const x=this.recurrentDropoutMask;let b=c(i,x,0),v=c(i,x,1),w=c(i,x,2),$=c(i,x,3);const I=3,[N,E,D,O]=Cr(this.kernel.read(),o,I),[L,z,P,_]=this.useBias?Cr(this.bias.read(),o):[null,null,null,null];d=this.inputConv(d,N,L,this.padding),f=this.inputConv(f,E,z,this.padding),p=this.inputConv(p,D,P,this.padding),g=this.inputConv(g,O,_,this.padding);const[H,q,ee,Y]=Cr(this.recurrentKernel.read(),o,I);b=this.recurrentConv(b,H),v=this.recurrentConv(v,q),w=this.recurrentConv(w,ee),$=this.recurrentConv($,Y);const G=this.recurrentActivation.apply(Ce(d,b)),te=this.recurrentActivation.apply(Ce(f,v)),re=Ce(Q(te,a),Q(G,this.activation.apply(Ce(p,w)))),he=Q(this.recurrentActivation.apply(Ce(g,$)),this.activation.apply(re));return[he,he,re]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=Ose(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=Go(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Gi(i,s,this.dataFormat):i}recurrentConv(e,t){return Go(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}nC.className="ConvLSTM2DCell";Ee(nC);class cO extends uO{constructor(e){const t=new nC(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}cO.className="ConvLSTM2D";Ee(cO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sC extends wt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return ce(()=>{this.invokeCallHook(e,t);const s=ht(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return $m(()=>JD(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}sC.className="Dropout";Ee(sC);class hO extends sC{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}hO.className="SpatialDropout1D";Ee(hO);class dO extends wt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,hs(this.units,"units"),this.activation=Yo(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=pn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=pn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Jn(e.kernelConstraint),this.biasConstraint=Jn(e.biasConstraint),this.kernelRegularizer=mn(e.kernelRegularizer),this.biasRegularizer=mn(e.biasRegularizer),this.activityRegularizer=mn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Lt(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Lt(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);const s=ht(e),r=jD(this.activation.getClassName());let i;return r!=null?i=da(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=da(s,this.kernel.read()),this.bias!=null&&(i=Gi(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Ko(this.activation),useBias:this.useBias,kernelInitializer:bn(this.kernelInitializer),biasInitializer:bn(this.biasInitializer),kernelRegularizer:rn(this.kernelRegularizer),biasRegularizer:rn(this.biasRegularizer),activityRegularizer:rn(this.activityRegularizer),kernelConstraint:Zn(this.kernelConstraint),biasConstraint:Zn(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}dO.className="Dense";Ee(dO);class fO extends wt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Lt(e);for(const t of e.slice(1))if(t==null)throw new ae(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Bo(e,1)]}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let s=ht(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=Dt(s,r)}return pne(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}fO.className="Flatten";Ee(fO);class pO extends wt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Yo(e.activation)}call(e,t){return ce(()=>{this.invokeCallHook(e,t);const s=ht(e);return this.activation.apply(s)})}getConfig(){const e={activation:Ko(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}pO.className="Activation";Ee(pO);class mO extends wt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ce(()=>(e=ht(e),dne(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}mO.className="RepeatVector";Ee(mO);class gO extends wt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,a=null;for(let l=0;l<r.length;++l){const c=r[l];if(this.isUnknown(c))if(a===null)a=l;else throw new ae("Can only specifiy one unknown dimension.");else i*=c}const o=Bo(e);if(a!==null){if(i===0||o%i!==0)throw new ae(s);r[a]=o/i}else if(o!==i)throw new ae(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ce(()=>{this.invokeCallHook(e,t);const s=ht(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ie(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}gO.className="Reshape";Ee(gO);class yO extends wt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Mi(1,e.dims.length+1);if(!yt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Yn({ndim:this.dims.length+1})]}computeOutputShape(e){e=Lt(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return Dt(ht(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}yO.className="Permute";Ee(yO);class xO extends wt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=ht(e);return Fy(Yc(s,this.maskValue),-1)}call(e,t){return ce(()=>{this.invokeCallHook(e,t);const s=ht(e),a=Fy(Yc(s,this.maskValue),-1,!0);return Q(s,De(a,s.dtype))})}}xO.className="Masking";Ee(xO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class bO extends wt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(jt(e.inputLength))}this.inputDim=e.inputDim,hs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,hs(this.outputDim,"outputDim"),this.embeddingsInitializer=pn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=mn(e.embeddingsRegularizer),this.activityRegularizer=mn(e.activityRegularizer),this.embeddingsConstraint=Jn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ce(()=>this.maskZero?(e=ht(e),Yc(e,_t(e))):null)}computeOutputShape(e){if(e=Lt(e),this.inputLength==null)return[...e,this.outputDim];const t=jt(this.inputLength);if(t.length!==e.length-1)throw new ae(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],a=e[r+1];if(i!=null&&a!=null&&i!==a)throw new ae(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=a),s++}}return[e[0],...t,this.outputDim]}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let s=ht(e);s.dtype!=="int32"&&(s=ha(s,"int32"));const r=ZD(this.embeddings.read(),ie(s,[s.size]));return ie(r,Lt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:bn(this.embeddingsInitializer),embeddingsRegularizer:rn(this.embeddingsRegularizer),activityRegularizer:rn(this.activityRegularizer),embeddingsConstraint:Zn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}bO.className="Embedding";Ee(bO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Au extends wt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new bt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],a=t[r];if(i==null||a==null||i<0||a<0)s.push(null);else if(i===1)s.push(a);else if(a===1)s.push(i);else{if(i!==a)throw new ae("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Lt(e)]),e=e,e.length<2)throw new ae(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Mo(t),t.length>1)throw new ae(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const a=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&Mo(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ce(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Xo(r);for(let a of e){const o=a.rank;for(let l=0;l<i-o;++l)a=Sm(a,1);s.push(a)}return this.mergeFunction(s)}else{let i=!1;for(const l of e){const c=l.rank;if(c==null){const d=l.shape,f=d[0],p=d.slice(1).concat([f]);let g=ie(l,[f].concat(Bo(d.slice(1))));g=Dt(g,[1,0]),g=ie(g,p),s.push(g),i=!0}else if(c>1){const d=Mi(1,c).concat([0]);s.push(Dt(l,d)),i=!0}else s.push(l)}let a=this.mergeFunction(s);const o=a.rank;if(i){if(o==null){const l=a.shape,c=l.length,d=l[c-1],f=[d].concat(l.slice(0,l.length-1));a=ie(Dt(ie(a,[-1,d]),[1,0]),f)}else if(o>1){const l=[o-1].concat(Mi(0,o-1));a=Dt(a,l)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Mo(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return ce(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ae("`mask` should be an Array");if(!Array.isArray(e))throw new ae("`inputs` should be an Array");if(t.length!==e.length)throw new ae(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Un(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=fa(s,t[r]);return s})}}class vO extends Au{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Ce(t,e[s]);return t})}}vO.className="Add";Ee(vO);class wO extends Au{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Q(t,e[s]);return t})}}wO.className="Multiply";Ee(wO);class SO extends Au{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Ce(t,e[s]);return Q(1/e.length,t)})}}SO.className="Average";Ee(SO);class CO extends Au{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Za(t,e[s]);return t})}}CO.className="Maximum";Ee(CO);class $O extends Au{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=jo(t,e[s]);return t})}}$O.className="Minimum";Ee($O);class kO extends Au{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ae("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let a=!1;for(const o of s)if(yt(o,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new ae("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ce(()=>MS(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ae("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new ae("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ae("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ae(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ce(()=>{let s=!0;if(t.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(De(Gr(e[a]),"bool")):t[a].rank<e[a].rank?r.push(Un(t[a],-1)):r.push(t[a]);const i=vn(r,this.axis);return O2(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}kO.className="Concatenate";Ee(kO);function Af(n,e){for(;n<0;)n+=e;return n}function Fse(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new bt("batchDot is not implemented for tensors of 4D or higher rank yet");if(B(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),B(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new bt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return ce(()=>{let a;if(s>r){a=s-r;const l=[];for(let c=0;c<a;++c)l.push(1);e=ie(e,e.shape.concat(l))}else if(r>s){a=r-s;const l=[];for(let c=0;c<a;++c)l.push(1);n=ie(n,n.shape.concat(l))}else a=0;let o;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?o=je(Q(n,e),i[0]):o=je(Q(Dt(n,[1,0]),e),i[1]);else{const l=i[0]!==n.shape.length-1,c=i[1]===e.shape.length-1;o=Ct(n,e,l,c)}if(a>0){let l;s>r?l=s+r-3:l=s-1;const c=[];for(let d=l;d<l+a;++d)c.push(d);o=Mt(o,c)}return o.shape.length===1&&(o=Un(o,1)),o})}class NO extends Au{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){B(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new bt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new ae(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ae(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,a)=>Af(i,e[a].shape.length)):r=[Af(this.axes,t.shape.length),Af(this.axes,s.shape.length)],this.normalize&&(t=Ky(t,r[0]),s=Ky(s,r[1])),Fse(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Af(this.axes,e.length),Af(this.axes,t.length)],s}computeOutputShape(e){B(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new bt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}NO.className="Dot";Ee(NO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class IO extends wt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);const s=ht(e);return $m(()=>Ce(a0(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}IO.className="GaussianNoise";Ee(IO);class TO extends wt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);const s=ht(e);return this.rate>0&&this.rate<1?$m(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return Q(s,a0(s.shape,1,i))},()=>s,t.training||!1):s})}}TO.className="GaussianDropout";Ee(TO);class EO extends wt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ht(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ce(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return $m(()=>{const i=ht(e),o=-1.6732632423543772*1.0507009873554805;let l=sl(Cu(s),this.rate);l=ha(l,"float32");const c=((1-this.rate)*(1+this.rate*o**2))**-.5,d=-c*o*this.rate,f=Ce(Q(i,l),Q(Ce(l,-1),o));return Ce(Q(f,c),d)},()=>ht(e),t.training||!1)}return e})}}EO.className="AlphaDropout";Ee(EO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rp(n,e,t,s,r,i=.001){let a;if(n.rank===2)a=hR(n,e,t,s,r,i);else if(n.rank===3)a=dR(n,e,t,s,r,i);else if(n.rank===4)a=fR(n,e,t,s,r,i);else throw new bt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function zse(n,e,t,s,r=.001){return ce(()=>{const i=yb(n,s),a=i.mean,o=i.variance;return[rp(n,a,o,t,e,r),a,o]})}function Lse(n,e,t,s,r=.001){return ce(()=>{const i=yb(n,s),a=i.mean,o=i.variance,l=[];for(const x of Mi(0,n.rank))s.indexOf(x)!==-1?l.push(1):l.push(n.shape[x]);const c=ie(a,l),d=ie(o,l),f=e==null?null:ie(e,l),p=t==null?null:ie(t,l);return[rp(n,c,d,p,f,r),a,o]})}function Pse(n,e,t,s,r=.001){return yt(s.slice().sort(),Mi(0,n.rank-1))?zse(n,e,t,s,r):Lse(n,e,t,s,r)}class RO extends wt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pn(e.betaInitializer||"zeros"),this.gammaInitializer=pn(e.gammaInitializer||"ones"),this.movingMeanInitializer=pn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=pn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Jn(e.betaConstraint),this.gammaConstraint=Jn(e.gammaConstraint),this.betaRegularizer=mn(e.betaRegularizer),this.gammaRegularizer=mn(e.gammaRegularizer)}build(e){e=Lt(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new ae(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Yn({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ce(()=>{const s=t.training==null?!1:t.training,r=ht(e),i=r.shape,a=i.length,o=Mi(0,a),l=this.axis>=0?this.axis:this.axis+a;o.splice(l,1);const c=yu(1,a);c[l]=i[l];const d=o.slice();d.sort();const f=!yt(d,Mi(0,a).slice(0,a-1)),p=()=>{if(f){const $=ie(this.movingMean.read(),c),I=ie(this.movingVariance.read(),c),N=this.center?ie(this.beta.read(),c):null,E=this.scale?ie(this.gamma.read(),c):null;return rp(r,$,I,N,E,this.epsilon)}else return rp(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return p();const[g,x,b]=Pse(r,this.gamma.read(),this.beta.read(),o,this.epsilon),v=($,I,N)=>{ce(()=>{const E=1-N,D=$.read(),O=Q(Me(D,I),E);$.write(Me(D,O))})};return(()=>{v(this.movingMean,x,this.momentum),v(this.movingVariance,b,this.momentum)})(),g})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:bn(this.betaInitializer),gammaInitializer:bn(this.gammaInitializer),movingMeanInitializer:bn(this.movingMeanInitializer),movingVarianceInitializer:bn(this.movingVarianceInitializer),betaRegularizer:rn(this.betaRegularizer),gammaRegularizer:rn(this.gammaRegularizer),betaConstraint:Zn(this.betaConstraint),gammaConstraint:Zn(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}RO.className="BatchNormalization";Ee(RO);class AO extends wt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pn(e.betaInitializer||"zeros"),this.gammaInitializer=pn(e.gammaInitializer||"ones"),this.betaRegularizer=mn(e.betaRegularizer),this.gammaRegularizer=mn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Lt(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Mo(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=ht(e),r=s.shape,i=r.length;return ce(()=>{let{mean:o,variance:l}=yb(s,this.axis,!0);const c=yu(1,i);for(const b of this.axis)c[b]=r[b];const d=b=>b!=null&&b.shape.length!==i?ie(b,c):b;let f=this.scale?d(this.gamma.read()):null,p=this.center?d(this.beta.read()):null;const g=[],x=[];for(let b=0;b<i;++b)this.axis.indexOf(b)!==-1?(g.push(r[b]),x.push(1)):(g.push(1),x.push(r[b]));return o=hi(o,g),l=hi(l,g),f!=null&&(f=hi(f,x)),p!=null&&(p=hi(p,x)),rp(s,o,l,p,f,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:bn(this.betaInitializer),gammaInitializer:bn(this.gammaInitializer),betaRegularizer:rn(this.betaRegularizer),gammaRegularizer:rn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}AO.className="LayerNormalization";Ee(AO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Mse(n,e,t){return ce(()=>{if(n.rank!==4)throw new ae(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ae("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Bi()),t!=="channelsLast"&&t!=="channelsFirst")throw new ae(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],zi(n,s)})}class DO extends wt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Bi():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ae(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ae(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new ae(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new Yn({ndim:4})]}computeOutputShape(e){e=Lt(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return ce(()=>Mse(ht(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}DO.className="ZeroPadding2D";Ee(DO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function p0(n,e,t,s,r,i){return ce(()=>{zn(r),XD(i),Xr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=Bi()),i==null&&(i="max"),n=ZS(n,r);let a;const o=s==="same"?"same":"valid";return i==="max"?a=gb(n,e,t,o):a=lb(n,e,t,o),r==="channelsFirst"&&(a=Dt(a,[0,3,1,2])),a})}function _O(n,e,t,s,r,i){return ce(()=>{zn(r),XD(i),Xr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Bi()),i==null&&(i="max"),n=Y_(n,r);let a;const o=s==="same"?"same":"valid";return i==="max"?a=LR(n,e,t,o):a=cR(n,e,t,o),r==="channelsFirst"&&(a=Dt(a,[0,4,1,2,3])),a})}class OO extends wt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ae(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(hs(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ae(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);hs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Xr(this.padding),this.inputSpec=[new Yn({ndim:3})]}computeOutputShape(e){e=Lt(e);const t=_i(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ce(()=>{this.invokeCallHook(e,t),e=Sm(ht(e),2);const s=this.poolingFunction(ht(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Mt(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class FO extends OO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return zn(i),Xr(r),p0(e,t,s,r,i,"max")}}FO.className="MaxPooling1D";Ee(FO);class zO extends OO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return zn(i),Xr(r),p0(e,t,s,r,i,"avg")}}zO.className="AveragePooling1D";Ee(zO);class LO extends wt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ae(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];hs(this.poolSize,"poolSize"),hs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,zn(this.dataFormat),Xr(this.padding),this.inputSpec=[new Yn({ndim:4})]}computeOutputShape(e){e=Lt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=_i(t,this.poolSize[0],this.padding,this.strides[0]),s=_i(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return ce(()=>(this.invokeCallHook(e,t),this.poolingFunction(ht(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class PO extends LO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return zn(i),Xr(r),p0(e,t,s,r,i,"max")}}PO.className="MaxPooling2D";Ee(PO);class MO extends LO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return zn(i),Xr(r),p0(e,t,s,r,i,"avg")}}MO.className="AveragePooling2D";Ee(MO);class BO extends wt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ae(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];hs(this.poolSize,"poolSize"),hs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,zn(this.dataFormat),Xr(this.padding),this.inputSpec=[new Yn({ndim:5})]}computeOutputShape(e){e=Lt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=_i(t,this.poolSize[0],this.padding,this.strides[0]),s=_i(s,this.poolSize[1],this.padding,this.strides[1]),r=_i(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return ce(()=>(this.invokeCallHook(e,t),this.poolingFunction(ht(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class VO extends BO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return zn(i),Xr(r),_O(e,t,s,r,i,"max")}}VO.className="MaxPooling3D";Ee(VO);class UO extends BO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return zn(i),Xr(r),_O(e,t,s,r,i,"avg")}}UO.className="AveragePooling3D";Ee(UO);class WO extends wt{constructor(e){super(e),this.inputSpec=[new Yn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new bt}}class GO extends WO{constructor(e){super(e||{})}call(e,t){return ce(()=>{const s=ht(e);return $n(s,1)})}}GO.className="GlobalAveragePooling1D";Ee(GO);class HO extends WO{constructor(e){super(e||{})}call(e,t){return ce(()=>{const s=ht(e);return mi(s,1)})}}HO.className="GlobalMaxPooling1D";Ee(HO);class jO extends wt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,zn(this.dataFormat),this.inputSpec=[new Yn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new bt}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class qO extends jO{call(e,t){return ce(()=>{const s=ht(e);return this.dataFormat==="channelsLast"?$n(s,[1,2]):$n(s,[2,3])})}}qO.className="GlobalAveragePooling2D";Ee(qO);class XO extends jO{call(e,t){return ce(()=>{const s=ht(e);return this.dataFormat==="channelsLast"?mi(s,[1,2]):mi(s,[2,3])})}}XO.className="GlobalMaxPooling2D";Ee(XO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class KO extends wt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=Xa(r,s);delete t.layer;const a={layer:i};return Object.assign(a,t),new e(a)}}class YO extends KO{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Lt(e),e.length<3)throw new ae(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Lt(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return ce(()=>(e=ht(e),iO((a,o)=>[ht(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}YO.className="TimeDistributed";Ee(YO);function Bse(n){Ru(one,"BidirectionalMergeMode",n)}const Vse="concat";class QO extends KO{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=Xa(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Xa(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Vse:e.mergeMode,Bse(this.mergeMode),e.weights)throw new bt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):sr(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=rO(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const a=[],o=[];if(s!=null){const c=s.length;if(c%2>0)throw new ae("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,a.push(...s);const d=s.map(f=>new Yn({shape:f.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),o.push(...d)}if(r!=null)throw new bt("Support for constants in Bidirectional layers is not implemented yet.");const l=a[0]instanceof ya;for(const c of a)if(c instanceof ya!==l)throw new ae("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(a),d=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=d;const p=super.apply(c,t);return this.inputSpec=f,p}else return super.apply(e,t)}call(e,t){return ce(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=xi(i,1));let o;return this.mergeMode==="concat"?o=MS([r,i]):this.mergeMode==="sum"?o=Ce(r,i):this.mergeMode==="ave"?o=Q(.5,Ce(r,i)):this.mergeMode==="mul"?o=Q(r,i):this.mergeMode==null&&(o=[r,i]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){nu(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),nu(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=Xa(t.layer);if(delete t.layer,t.numConstants!=null)throw new bt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}QO.className="Bidirectional";Ee(QO);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ZO extends wt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ce(()=>(e=ht(e),e.dtype!=="float32"&&(e=ha(e,"float32")),Ce(Q(e,this.scale),this.offset)))}}ZO.className="Rescaling";Ee(ZO);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:Use,cropAndResize:Wse}=Hs;class JO extends wt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,a,o,l){return ce(()=>{let c,d=!1;const f=t/a,p=s/o,g=(r+t)/a,x=(i+s)/o,b=[f,p,g,x],v=[];e.rank===3?(d=!0,c=$r([e])):c=e;for(let E=0;E<c.shape[0];E++)v.push(b);const w=Di(v,[v.length,4]),$=Qc(0,v.length,1,"int32"),N=Wse(c,w,$,[r,i],"nearest");return ha(d?ht(bi(N)):N,l)})}upsize(e,t,s,r){return ce(()=>{const i=Use(e,[t,s]);return ha(i,r)})}call(e,t){return ce(()=>{const s=ht(e),r=s.dtype,i=s.shape,a=i[i.length-3],o=i[i.length-2];let l=0;a!==this.height&&(l=Math.floor((a-this.height)/2));let c=0;return o!==this.width&&(c=Math.floor((o-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,a,o,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Lt(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}JO.className="CenterCrop";Ee(JO);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gse(n,e,t,s){let r=ht(n);if(r.dtype!=="int32"&&(r=ha(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=Un(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Un(r,-1)),r.rank>2)throw new ae(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const a=["multiHot","oneHot"].includes(e),o=r;let l;if(typeof s<"u"&&e==="count"?l=Tw(o,s,t,a):l=Tw(o,[],t,a),e!=="tfIdf")return l;if(s)return Q(l,s);throw new ae("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eF extends wt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Lt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ce(()=>{e=ht(e),e.dtype!=="int32"&&(e=ha(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ae(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=ht(t.countWeights)}const r=mi(e),i=qf(e),a=Er(this.numTokens,r).bufferSync().get(0),o=sl(i,0).bufferSync().get(0);if(!(a&&o))throw new ae(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Gse(e,this.outputMode,this.numTokens,s)})}}eF.className="CategoryEncoding";Ee(eF);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Hse=["bilinear","nearest"],VT=new Set(Hse);class tF extends wt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(VT.has(e.interpolation))this.interpolation=e.interpolation;else throw new ae(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Lt(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ce(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Hs.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Hs.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...VT]} are supported`)})}}tF.className="Resizing";Ee(tF);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class nF{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}nF.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sF extends wt{constructor(e){super(e),this.randomGenerator=new nF(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}sF.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const jse=["bilinear","nearest"],UT=new Set(jse);class rF extends sF{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ae(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ae(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ae(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(UT.has(s))this.interpolation=s;else throw new ae(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Lt(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return ce(()=>{const s=ht(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Cu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Hs.resizeBilinear(e,a);case"nearest":return Hs.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...UT]} are supported`)}})}}rF.className="RandomWidth";Ee(rF);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var WT;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(WT||(WT={}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qse=cS;class m0 extends lx{nextDataId(){return m0.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new f2(this,Vs())}write(e,t,s){this.firstUse&&(this.firstUse=!1,fe().get("IS_NODE")&&Br(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&lh(s[0])){const i=s.map(a=>Ha(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return Li(r,i)}return py(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Oi(r));return ft(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ft(e.shape,e.dtype,t)}makeOutput(e,t,s){return Vs().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=nr();return e(),{kernelMs:nr()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){qe([e],"where");const t=this.readSync(e.dataId);return qse(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}m0.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */R2("cpu",()=>new m0,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iF=qt(Ch,n=>n>=0?n:Math.exp(n)-1),Xse={kernelName:Ch,backendName:"cpu",kernelFunc:iF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;qe([r],"leakyRelu");const a=ue(r.shape),o=t.data.get(r.dataId).values,l=es("float32",a);for(let c=0;c<o.length;c++)l[c]=o[c]<0?i*o[c]:o[c];return t.makeTensorInfo(r.shape,"float32",l)}const Kse={kernelName:Rp,backendName:"cpu",kernelFunc:aF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yse=Fn((n,e)=>n<0?e*n:n);function oF(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;qe([s,r],"prelu");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,[o,l]=Yse(s.shape,r.shape,i,a,"float32");return t.makeTensorInfo(l,"float32",o)}const Qse={kernelName:Kp,backendName:"cpu",kernelFunc:oF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lF=qt(Uh,n=>Math.max(0,n)),Zse={kernelName:Uh,backendName:"cpu",kernelFunc:lF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uF=qt(Wh,n=>Math.min(Math.max(0,n),6)),Jse={kernelName:Wh,backendName:"cpu",kernelFunc:uF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ex(n,e,t,s,r){if(t==="linear")return pa({inputs:{x:e},backend:n});if(t==="relu")return lF({inputs:{x:e},backend:n});if(t==="elu")return iF({inputs:{x:e},backend:n});if(t==="relu6")return uF({inputs:{x:e},backend:n});if(t==="prelu")return oF({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return aF({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return B3({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=ue(r.shape),o=m2(i,a),l=ue(o);B(a===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const c=t.data.get(r.dataId);if(c.complexTensorInfos!=null){const d=c.complexTensorInfos.real,f=c.complexTensorInfos.imag;d.shape=o,f.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const ere={kernelName:Qp,backendName:"cpu",kernelFunc:ln};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cF(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;qe([r,i],"matMul");const l=r.shape.length,c=i.shape.length,d=a?r.shape[l-2]:r.shape[l-1],f=o?i.shape[c-1]:i.shape[c-2],p=a?r.shape[l-1]:r.shape[l-2],g=o?i.shape[c-2]:i.shape[c-1],x=r.shape.slice(0,-2),b=i.shape.slice(0,-2),v=ue(x),w=ue(b),I=tt(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([p,g]);B(d===f,()=>`Error in matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`);const N=a?[v,d,p]:[v,p,d],E=o?[w,g,f]:[w,f,g],D=ln({inputs:{x:r},backend:t,attrs:{shape:N}}),O=ln({inputs:{x:i},backend:t,attrs:{shape:E}}),L=a?D.shape[1]:D.shape[2],z=a?D.shape[2]:D.shape[1],P=o?O.shape[1]:O.shape[2],_=Math.max(v,w),H=t.data.get(D.dataId).values,q=t.data.get(O.dataId).values,ee=Ye(D.shape),Y=Ye(O.shape),[G,te,re]=a?[ee[0],1,ee[1]]:[ee[0],ee[1],1],[he,W,ne]=o?[1,Y[1],Y[0]]:[Y[1],1,Y[0]],pe=z*P,de=ft([_,z,P],D.dtype),we=de.values,ke=t.blockSize;for(let Ne=0;Ne<_;Ne++){const Ue=Ne%v,Le=Ne%w;for(let Ge=0;Ge<z;Ge+=ke){const at=Math.min(Ge+ke,z);for(let nt=0;nt<P;nt+=ke){const Tt=Math.min(nt+ke,P);for(let st=0;st<L;st+=ke){const gt=Math.min(st+ke,L);for(let Bt=Ge;Bt<at;Bt++)for(let Pt=nt;Pt<Tt;Pt++){let $t=0;for(let Ht=st;Ht<gt;Ht++){const Ys=H[Ue*G+Bt*te+Ht*re],gn=q[Ht*he+Pt*W+Le*ne];$t+=Ys*gn}we[Ne*pe+(Bt*P+Pt)]+=$t}}}}}return t.disposeIntermediateTensorInfo(D),t.disposeIntermediateTensorInfo(O),t.makeTensorInfo(I,de.dtype,de.values)}const tre={kernelName:mp,backendName:"cpu",kernelFunc:cF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nre(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=s;let p,g,x;const b=[];p=cF({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:c},backend:t}),a&&(g=eh({inputs:{a:p,b:a},backend:t}),b.push(p),p=g),d&&(x=ex(t,p,d,o,f),b.push(p),p=x);for(const w of b)t.disposeIntermediateTensorInfo(w);return p}const sre={kernelName:Vf,backendName:"cpu",kernelFunc:nre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rre=qt(ch,n=>Math.acos(n)),ire={kernelName:ch,backendName:"cpu",kernelFunc:rre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const are=qt(hh,n=>Math.acosh(n)),ore={kernelName:hh,backendName:"cpu",kernelFunc:are};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lre(n){const{inputs:e,backend:t}=n,s=e;qe(e,"addN");const r=s.map(o=>t.data.get(o.dataId).values),i=ft(s[0].shape,s[0].dtype),a=i.values;for(let o=0;o<s.length;o++){const l=r[o];for(let c=0;c<a.length;c++)a[c]+=l[c]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const ure={kernelName:cp,backendName:"cpu",kernelFunc:lre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;qe(r,"all");const o=pt(i,r.shape);let l=o;const c=Zt(l,r.shape.length);let d=r;c!=null&&(d=ur({inputs:{x:r},backend:t,attrs:{perm:c}}),l=cn(l.length,r.shape.length)),Gn("all",l,d.shape.length);const[f,p]=On(d.shape,l),g=ue(p),x=ws(ue(f),d.dtype),b=t.data.get(d.dataId).values;for(let w=0;w<x.length;++w){const $=w*g;let I=b[$];for(let N=0;N<g;++N){const E=b[$+N];I=I&&E}x[w]=I}c!=null&&t.disposeIntermediateTensorInfo(d);const v=t.makeTensorInfo(f,d.dtype,x);if(a){const w=In(f,o),$=ln({inputs:{x:v},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(v),$}return v}const hre={kernelName:ux,backendName:"cpu",kernelFunc:cre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;qe(r,"any");const o=pt(i,r.shape);let l=o;const c=Zt(l,r.shape.length);let d=r;c!=null&&(d=ur({inputs:{x:r},backend:t,attrs:{perm:c}}),l=cn(l.length,r.shape.length)),Gn("any",l,d.shape.length);const[f,p]=On(d.shape,l),g=ue(p),x=ws(ue(f),d.dtype),b=t.data.get(d.dataId).values;for(let w=0;w<x.length;++w){const $=w*g;let I=b[$];for(let N=0;N<g;++N){const E=b[$+N];I=I||E}x[w]=I}c!=null&&t.disposeIntermediateTensorInfo(d);const v=t.makeTensorInfo(f,d.dtype,x);if(a){const w=In(f,o),$=ln({inputs:{x:v},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(v),$}return v}const fre={kernelName:cx,backendName:"cpu",kernelFunc:dre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;qe(r,"argMax");let a=pt(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const c=[];o!=null&&(l=ur({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(l),a=cn(a.length,l.shape.length)),a=[a[0]],Gn("argMax",a,l.shape.length);const[d,f]=On(l.shape,a),p=ue(d),g=ws(p,"int32"),x=ue(f),b=t.data.get(l.dataId).values;for(let v=0;v<g.length;++v){const w=v*x;let $=b[w],I=0;for(let N=0;N<x;++N){const E=b[w+N];E>$&&($=E,I=N)}g[v]=I}return c.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(d,"int32",g)}const mre={kernelName:hp,backendName:"cpu",kernelFunc:pre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;qe(r,"argMin");let a=pt(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const c=[];o!=null&&(l=ur({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(l),a=cn(a.length,l.shape.length)),a=[a[0]],Gn("argMin",a,l.shape.length);const[d,f]=On(l.shape,a),p=ue(d),g=ws(p,"int32"),x=ue(f),b=t.data.get(l.dataId).values;for(let v=0;v<g.length;++v){const w=v*x;let $=b[w],I=0;for(let N=0;N<x;++N){const E=b[w+N];E<$&&($=E,I=N)}g[v]=I}return c.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(d,"int32",g)}const yre={kernelName:dp,backendName:"cpu",kernelFunc:gre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xre=qt(dh,n=>Math.asin(n)),bre={kernelName:dh,backendName:"cpu",kernelFunc:xre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vre=qt(fh,n=>Math.asinh(n)),wre={kernelName:fh,backendName:"cpu",kernelFunc:vre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sre=qt(ph,n=>Math.atan(n)),Cre={kernelName:ph,backendName:"cpu",kernelFunc:Sre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $re=Fn((n,e)=>Math.atan2(n,e)),kre=ss(gh,$re),Nre={kernelName:gh,backendName:"cpu",kernelFunc:kre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ire=qt(mh,n=>Math.atanh(n)),Tre={kernelName:mh,backendName:"cpu",kernelFunc:Ire};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rC(n,e,t,s,r,i){const a=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,f=r.effectiveFilterWidth,p=r.padInfo.top,g=r.padInfo.left,x=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=ft(r.outShape,t),v=b.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3],$=r.outShape[2]*r.outShape[3],I=r.outShape[3];for(let N=0;N<r.batchSize;++N){const E=N*w,D=N*s[0];for(let O=0;O<r.inChannels;++O)for(let L=0;L<r.outHeight;++L){const z=L*a-p,P=Math.max(0,z),_=Math.min(r.inHeight,d+z),H=E+L*$;for(let q=0;q<r.outWidth;++q){const ee=q*o-g,Y=Math.max(0,ee),G=Math.min(r.inWidth,f+ee);let te=x,re=0,he=0;for(let ne=P;ne<_;ne+=l){const pe=D+ne*s[1];for(let de=Y;de<G;de+=c){const we=pe+de*s[2],ke=n[we+O];i==="max"&&ke>te?te=ke:i==="avg"&&(re+=ke,he++)}if(isNaN(te))break}const W=H+q*I+O;v[W]=i==="avg"?re/he:te}}}return b}function hF(n,e,t,s,r=!1,i=!1){const a=ft(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,d=s.dilationWidth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,g=s.padInfo.top,x=s.padInfo.left,b=ft(e,t,n);for(let v=0;v<s.batchSize;++v)for(let w=0;w<s.inChannels;++w)for(let $=0;$<s.outHeight;++$){const I=$*o-g;let N=I;for(;N<0;)N+=c;const E=Math.min(s.inHeight,f+I);for(let D=0;D<s.outWidth;++D){const O=D*l-x;let L=O;for(;L<0;)L+=d;const z=Math.min(s.inWidth,p+O);let P=Number.NEGATIVE_INFINITY,_=-1;for(let H=N;H<E;H+=c){const q=H-I;for(let ee=L;ee<z;ee+=d){const Y=ee-O,G=b.get(v,H,ee,w);G>P&&(P=G,r?_=i?((v*s.inHeight+H)*s.inWidth+ee)*s.inChannels+w:(H*s.inWidth+ee)*s.inChannels+w:_=q*p+Y)}}a.set(_,v,$,D,w)}}return a}function dF(n,e,t,s,r,i){const a=r.strideDepth,o=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,d=r.dilationHeight,f=r.dilationWidth,p=r.effectiveFilterDepth,g=r.effectiveFilterHeight,x=r.effectiveFilterWidth,b=r.padInfo.front,v=r.padInfo.top,w=r.padInfo.left,$=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=ft(r.outShape,t),N=I.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],D=r.outShape[2]*r.outShape[3]*r.outShape[4],O=r.outShape[3]*r.outShape[4],L=r.outShape[4];for(let z=0;z<r.batchSize;++z){const P=z*E,_=z*s[0];for(let H=0;H<r.inChannels;++H)for(let q=0;q<r.outDepth;++q){const ee=q*a-b;let Y=ee;for(;Y<0;)Y+=c;const G=Math.min(r.inDepth,p+ee),te=P+q*D;for(let re=0;re<r.outHeight;++re){const he=re*o-v;let W=he;for(;W<0;)W+=d;const ne=Math.min(r.inHeight,g+he),pe=te+re*O;for(let de=0;de<r.outWidth;++de){const we=de*l-w;let ke=we;for(;ke<0;)ke+=f;const Ne=Math.min(r.inWidth,x+we),Ue=pe+de*L;let Le=$,Ge=0,at=0;for(let Tt=Y;Tt<G;Tt+=c){const st=_+Tt*s[1];for(let gt=W;gt<ne;gt+=d){const Bt=st+gt*s[2];for(let Pt=ke;Pt<Ne;Pt+=f){const $t=Bt+Pt*s[3],Ht=n[$t+H];if(i==="max"&&Ht>Le?Le=Ht:i==="avg"&&(Ge+=Ht,at++),isNaN(Le))break}if(isNaN(Le))break}if(isNaN(Le))break}const nt=Ue+H;N[nt]=i==="avg"?Ge/Math.max(at,1):Le}}}}return I}function Ere(n,e){const t=ft(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,p=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;for(let b=0;b<e.batchSize;++b)for(let v=0;v<e.inChannels;++v)for(let w=0;w<e.outDepth;++w){const $=w*s-p;let I=$;for(;I<0;)I+=a;const N=Math.min(e.inDepth,c+$);for(let E=0;E<e.outHeight;++E){const D=E*r-g;let O=D;for(;O<0;)O+=o;const L=Math.min(e.inHeight,d+D);for(let z=0;z<e.outWidth;++z){const P=z*i-x;let _=P;for(;_<0;)_+=l;const H=Math.min(e.inWidth,f+P);let q=Number.NEGATIVE_INFINITY,ee=-1;for(let Y=I;Y<N;Y+=a){const G=Y-$;for(let te=O;te<L;te+=o){const re=te-D;for(let he=_;he<H;he+=l){const W=he-P,ne=n.get(b,Y,te,he,v);ne>=q&&(q=ne,ee=G*d*f+re*d+W)}}}t.set(ee,b,w,E,z,v)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;qe(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,c=1;B(ns(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=As(r.shape,i,a,c,o,l);let f;if(d.filterWidth===1&&d.filterHeight===1&&yt(d.inShape,d.outShape))f=pa({inputs:{x:r},backend:t});else{const p=t.data.get(r.dataId).values,g=Ye(r.shape),x=rC(p,r.shape,r.dtype,g,d,"avg");f=t.makeTensorInfo(d.outShape,r.dtype,x.values)}return f}const Are={kernelName:fp,backendName:"cpu",kernelFunc:Rre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s;qe(r,"avgPool3d");const d=jr(r.shape,i,a,1,o,l,c),f=t.data.get(r.dataId).values,p=dF(f,r.shape,r.dtype,Ye(r.shape),d,"avg");return t.makeTensorInfo(p.shape,"float32",p.values)}const _re={kernelName:pp,backendName:"cpu",kernelFunc:Dre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ore(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:c}=s;qe([r,i],"avgPool3DGrad");const d=jr(i.shape,a,o,1,l,c),f=d.strideDepth,p=d.strideHeight,g=d.strideWidth,x=d.filterDepth,b=d.filterHeight,v=d.filterWidth,w=d.dilationDepth,$=d.dilationHeight,I=d.dilationWidth,N=d.effectiveFilterDepth,E=d.effectiveFilterHeight,D=d.effectiveFilterWidth,O=N-1-d.padInfo.front,L=D-1-d.padInfo.left,z=E-1-d.padInfo.top,P=ft(i.shape,"float32"),_=1/(x*b*v),H=t.bufferSync(r);for(let q=0;q<d.batchSize;++q)for(let ee=0;ee<d.inChannels;++ee)for(let Y=0;Y<d.inDepth;++Y)for(let G=0;G<d.inHeight;++G)for(let te=0;te<d.inWidth;++te){const re=Y-O,he=G-z,W=te-L;let ne=0;for(let pe=0;pe<N;pe+=w){const de=(re+pe)/f;if(!(de<0||de>=d.outDepth||Math.floor(de)!==de))for(let we=0;we<E;we+=$){const ke=(he+we)/p;if(!(ke<0||ke>=d.outHeight||Math.floor(ke)!==ke))for(let Ne=0;Ne<D;Ne+=I){const Ue=(W+Ne)/g;if(Ue<0||Ue>=d.outWidth||Math.floor(Ue)!==Ue)continue;const Le=H.get(q,de,ke,Ue,ee);ne+=Le}}}P.set(ne*_,q,Y,G,te,ee)}return t.makeTensorInfo(P.shape,P.dtype,P.values)}const Fre={kernelName:dx,backendName:"cpu",kernelFunc:Ore};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zre(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;qe([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,d=As(a.shape,o,l,1,c),f=d.strideHeight,p=d.strideWidth,g=d.filterHeight,x=d.filterWidth,b=d.dilationHeight,v=d.dilationWidth,w=d.effectiveFilterHeight,$=d.effectiveFilterWidth,I=$-1-d.padInfo.left,N=w-1-d.padInfo.top,E=ft(a.shape,"float32"),D=1/(g*x),O=t.data.get(r.dataId).values,L=ft(r.shape,"float32",O);for(let z=0;z<d.batchSize;++z)for(let P=0;P<d.inChannels;++P)for(let _=0;_<d.inHeight;++_)for(let H=0;H<d.inWidth;++H){const q=_-N,ee=H-I;let Y=0;for(let G=0;G<w;G+=b){const te=(q+G)/f;if(!(te<0||te>=d.outHeight||Math.floor(te)!==te))for(let re=0;re<$;re+=v){const he=(ee+re)/p;if(he<0||he>=d.outWidth||Math.floor(he)!==he)continue;const W=L.get(z,te,he,P);Y+=W}}E.set(Y*D,z,_,H,P)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const Lre={kernelName:hx,backendName:"cpu",kernelFunc:zre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:a,mean:o,variance:l}=e;B(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),qe([r,o,l,i,a],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const d=t.data.get(r.dataId).values,f=t.data.get(o.dataId).values,p=t.data.get(l.dataId).values,g=i?t.data.get(i.dataId).values:new Float32Array([1]),x=a?t.data.get(a.dataId).values:new Float32Array([0]),b=new Float32Array(d.length),v=x.length,w=g.length,$=p.length,I=f.length;let N=0,E=0,D=0,O=0;for(let L=0;L<d.length;++L)b[L]=x[N++]+(d[L]-f[E++])*g[D++]/Math.sqrt(p[O++]+c),N>=v&&(N=0),E>=I&&(E=0),D>=w&&(D=0),O>=$&&(O=0);return t.makeTensorInfo(r.shape,r.dtype,b)}const Mre={kernelName:Ip,backendName:"cpu",kernelFunc:Pre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;qe([r],"batchToSpaceND");const o=i.reduce((w,$)=>w*$),l=$u(r.shape,i,o),c=ku(l.length,i.length),d=Nu(r.shape,i,o),f=Mb(a,i.length),p=Bb(d,a,i.length),g=ln({inputs:{x:r},backend:t,attrs:{shape:l}}),x=ur({inputs:{x:g},backend:t,attrs:{perm:c}}),b=ln({inputs:{x},backend:t,attrs:{shape:d}}),v=gu({inputs:{x:b},backend:t,attrs:{begin:f,size:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),v}const Vre={kernelName:gp,backendName:"cpu",kernelFunc:Bre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ure(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,c=TS(o,l,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,c)}const Wre={kernelName:fx,backendName:"cpu",kernelFunc:Ure};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gre(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,o=tt(Array.from(i),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Hre={kernelName:mx,backendName:"cpu",kernelFunc:Gre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jre=qt(bh,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),qre={kernelName:bh,backendName:"cpu",kernelFunc:jre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xre=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(ue(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values;for(let c=0;c<o.length;c++){const d=o[c],f=l[c];s[c]=Math.hypot(d,f)}return t.makeOutput(s,e.shape,"float32")},Kre={kernelName:yp,backendName:"cpu",kernelFunc:Xre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sh(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const Yre={kernelName:Ox,backendName:"cpu",kernelFunc:sh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rh(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=pt(r,e[0].shape)[0],a=e.map(b=>b.shape);zb(a,i);let o=ir(e.map(b=>b.shape),i);if(ue(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(b=>ue(b.shape)>0);if(l.length===1)return pa({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const b=l.map(N=>mu({inputs:{input:N},backend:t})),v=l.map(N=>sh({inputs:{input:N},backend:t})),w=rh({inputs:b,backend:t,attrs:{axis:i}}),$=rh({inputs:v,backend:t,attrs:{axis:i}}),I=wr({inputs:{real:w,imag:$},backend:t});return b.forEach(N=>t.disposeIntermediateTensorInfo(N)),v.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo($),I}const c=l.map(b=>{const w=[-1,ue(b.shape.slice(i))];return ln({inputs:{x:b},backend:t,attrs:{shape:w}})}),d=c.map(b=>({vals:t.data.get(b.dataId).values,shape:b.shape}));o=ir(c.map(b=>b.shape),1);const f=c[0].shape[0]===1,p=f3(d,o,e[0].dtype,f),g=ir(l.map(b=>b.shape),i),x=t.makeTensorInfo(g,e[0].dtype,p);return c.forEach(b=>t.disposeIntermediateTensorInfo(b)),x}const Qre={kernelName:xp,backendName:"cpu",kernelFunc:rh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:d}=s;qe([r,i],"conv2d");const f=Tr(l),p=un(r.shape,i.shape,a,c,o,d,!1,f),g=p.filterHeight,x=p.filterWidth,b=p.dilationHeight,v=p.dilationWidth,w=p.padInfo.left,$=p.padInfo.top,I=p.dataFormat==="channelsLast",N=new Qn(p.outShape,r.dtype),E=Ye(r.shape),D=Ye(i.shape),O=E[0],L=I?E[1]:E[2],z=I?E[2]:1,P=I?1:E[1],_=N.strides[0],H=I?N.strides[1]:N.strides[2],q=I?N.strides[2]:1,ee=I?1:N.strides[1],Y=t.data.get(r.dataId).values,G=t.data.get(i.dataId).values,te=N.values;for(let re=0;re<p.batchSize;++re){const he=re*O,W=re*_;for(let ne=0;ne<p.outHeight;++ne){const pe=W+ne*H,de=ne*p.strideHeight-$;for(let we=0;we<g;++we){const ke=de+we*b;if(ke<0||ke>=p.inHeight)continue;const Ne=we*D[0],Ue=he+ke*L;for(let Le=0;Le<p.outWidth;++Le){const Ge=pe+Le*q,at=Le*p.strideWidth-w;for(let nt=0;nt<x;++nt){const Tt=at+nt*v;if(Tt<0||Tt>=p.inWidth)continue;const st=Ne+nt*D[1],gt=Ue+Tt*z;let Bt=st;for(let Pt=0;Pt<p.inChannels;++Pt){const $t=Y[gt+Pt*P];for(let Ht=0;Ht<p.outChannels;++Ht)te[Ge+Ht*ee]+=$t*G[Bt+Ht];Bt+=p.outChannels}}}}}}return t.makeTensorInfo(N.shape,N.dtype,te)}const Zre={kernelName:bp,backendName:"cpu",kernelFunc:fF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:d}=s;qe([r,i],"conv2dBackpropFilter");const f=Tr(l),p=un(r.shape,d,a,1,o,c,!1,f),{strideHeight:g,strideWidth:x,filterHeight:b,filterWidth:v}=p,w=p.dataFormat==="channelsLast",$=new Qn(p.filterShape,"float32"),I=p.padInfo.left,N=p.padInfo.top,E=t.data.get(r.dataId).values,D=t.data.get(i.dataId).values,O=new Qn(r.shape,r.dtype,E),L=new Qn(i.shape,i.dtype,D);for(let z=0;z<b;++z){const P=Math.max(0,Math.ceil((N-z)/g)),_=Math.min(p.outHeight,(p.inHeight+N-z)/g);for(let H=0;H<v;++H){const q=Math.max(0,Math.ceil((I-H)/x)),ee=Math.min(p.outWidth,(p.inWidth+I-H)/x);for(let Y=0;Y<p.inChannels;++Y)for(let G=0;G<p.outChannels;++G){let te=0;for(let re=0;re<p.batchSize;++re)for(let he=P;he<_;++he){const W=z+he*g-N;for(let ne=q;ne<ee;++ne){const pe=H+ne*x-I;w?te+=O.get(re,W,pe,Y)*L.get(re,he,ne,G):te+=O.get(re,Y,W,pe)*L.get(re,G,he,ne)}}$.set(te,z,H,Y,G)}}}return t.makeTensorInfo($.shape,$.dtype,$.values)}const eie={kernelName:yx,backendName:"cpu",kernelFunc:Jre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tie(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:d}=s;qe([r,i],"conv2dBackpropInput");const f=Ye(i.shape),p=Ye(r.shape);let g=Tr(c);const x=un(a,i.shape,o,1,l,d,!1,g),b=new Qn(x.inShape,"float32"),v=b.values,w=t.data.get(r.dataId).values,$=t.data.get(i.dataId).values,[I,N,E]=f,{batchSize:D,filterHeight:O,filterWidth:L,inChannels:z,inHeight:P,inWidth:_,outChannels:H,outHeight:q,outWidth:ee,strideHeight:Y,strideWidth:G}=x;g=x.dataFormat;const te=O-1-x.padInfo.top,re=L-1-x.padInfo.left,he=g==="channelsLast",W=b.strides[0],ne=he?b.strides[1]:b.strides[2],pe=he?b.strides[2]:1,de=he?1:b.strides[1],we=p[0],ke=he?p[1]:p[2],Ne=he?p[2]:1,Ue=he?1:p[1];for(let Le=0;Le<D;++Le)for(let Ge=0;Ge<z;++Ge)for(let at=0;at<P;++at){const nt=at-te,Tt=Math.max(0,Math.ceil(nt/Y)),st=Math.min(q,(O+nt)/Y);for(let gt=0;gt<_;++gt){const Bt=gt-re,Pt=Math.max(0,Math.ceil(Bt/G)),$t=Math.min(ee,(L+Bt)/G);let Ht=0;for(let gn=Tt;gn<st;++gn){const Os=gn*Y-nt;for(let rs=Pt;rs<$t;++rs){const Rr=rs*G-Bt,Ln=we*Le+ke*gn+Ne*rs,hr=I*(O-1-Os)+N*(L-1-Rr)+E*Ge;for(let is=0;is<H;++is){const hn=w[Ln+Ue*is],as=$[hr+is];Ht+=hn*as}}}const Ys=W*Le+ne*at+pe*gt+de*Ge;v[Ys]=Ht}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const nie={kernelName:vp,backendName:"cpu",kernelFunc:tie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s;qe([r,i],"conv3d");const c=Wi(r.shape,i.shape,a,l,o),{filterDepth:d,filterHeight:f,filterWidth:p,dilationDepth:g,dilationHeight:x,dilationWidth:b,padInfo:v}=c,w=v.front,$=v.left,I=v.top,N=new Qn(c.outShape,r.dtype),E=t.data.get(r.dataId).values,D=t.data.get(i.dataId).values,O=N.values,L=Ye(r.shape),z=Ye(i.shape);for(let P=0;P<c.batchSize;++P){const _=P*L[0],H=P*N.strides[0];for(let q=0;q<c.outDepth;++q){const ee=H+q*N.strides[1],Y=q*c.strideDepth-w;for(let G=0;G<d;++G){const te=Y+G*g;if(te<0||te>=c.inDepth)continue;const re=G*z[0],he=_+te*L[1];for(let W=0;W<c.outHeight;++W){const ne=ee+W*N.strides[2],pe=W*c.strideHeight-I;for(let de=0;de<f;++de){const we=pe+de*x;if(we<0||we>=c.inHeight)continue;const ke=re+de*z[1],Ne=he+we*L[2];for(let Ue=0;Ue<c.outWidth;++Ue){const Le=ne+Ue*c.outChannels,Ge=Ue*c.strideWidth-$;for(let at=0;at<p;++at){const nt=Ge+at*b;if(nt<0||nt>=c.inWidth)continue;const Tt=ke+at*z[2],st=Ne+nt*c.inChannels;let gt=Tt;for(let Bt=0;Bt<c.inChannels;++Bt){const Pt=E[st+Bt];for(let $t=0;$t<c.outChannels;++$t)O[Le+$t]+=Pt*D[gt+$t];gt+=c.outChannels}}}}}}}}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const rie={kernelName:wp,backendName:"cpu",kernelFunc:sie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s;qe([r,i],"conv3dBackpropFilterV2");const c=Ye(r.shape),d=Ye(i.shape),f=Wi(r.shape,l,a,1,o),p=f.strideDepth,g=f.strideHeight,x=f.strideWidth,b=f.filterDepth,v=f.filterHeight,w=f.filterWidth,$=new Qn(f.filterShape,"float32"),I=$.values,[N,E,D,O]=$.strides,L=t.data.get(i.dataId).values,[z,P,_,H]=d,q=t.data.get(r.dataId).values,[ee,Y,G,te]=c,re=f.padInfo.front,he=f.padInfo.left,W=f.padInfo.top;for(let ne=0;ne<b;++ne){const pe=Math.max(0,Math.ceil((re-ne)/p)),de=Math.min(f.outDepth,(f.inDepth+re-ne)/p),we=ne*N;for(let ke=0;ke<v;++ke){const Ne=Math.max(0,Math.ceil((W-ke)/g)),Ue=Math.min(f.outHeight,(f.inHeight+W-ke)/g),Le=ke*E+we;for(let Ge=0;Ge<w;++Ge){const at=Math.max(0,Math.ceil((he-Ge)/x)),nt=Math.min(f.outWidth,(f.inWidth+he-Ge)/x),Tt=Ge*D+Le;for(let st=0;st<f.inChannels;++st){const gt=st*O+Tt;for(let Bt=0;Bt<f.outChannels;++Bt){let Pt=0;for(let $t=0;$t<f.batchSize;++$t){const Ht=$t*ee,Ys=$t*z;for(let gn=pe;gn<de;++gn){const rs=(ne+gn*p-re)*Y+Ht,Rr=gn*P+Ys;for(let Ln=Ne;Ln<Ue;++Ln){const is=(ke+Ln*g-W)*G+rs,hn=Ln*_+Rr;for(let as=at;as<nt;++as){const ul=(Ge+as*x-he)*te+is,no=as*H+hn;Pt+=q[ul+st]*L[no+Bt]}}}}I[gt+Bt]=Pt}}}}}return t.makeTensorInfo($.shape,$.dtype,$.values)}const aie={kernelName:xx,backendName:"cpu",kernelFunc:iie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oie(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:l}=s;qe([r],"conv3dBackpropInputV2");const c=Ye(r.shape),d=Ye(i.shape),f=Wi(l,i.shape,o,1,a),p=new Qn(f.inShape,"float32"),g=p.values,[x,b,v,w]=p.strides,$=t.data.get(r.dataId).values,[I,N,E,D]=c,O=t.data.get(i.dataId).values,[L,z,P,_]=d,{batchSize:H,filterDepth:q,filterHeight:ee,filterWidth:Y,inChannels:G,inDepth:te,inHeight:re,inWidth:he,outChannels:W,outDepth:ne,outHeight:pe,outWidth:de,strideDepth:we,strideHeight:ke,strideWidth:Ne}=f,Ue=q-1-f.padInfo.front,Le=ee-1-f.padInfo.top,Ge=Y-1-f.padInfo.left;for(let at=0;at<H;++at)for(let nt=0;nt<G;++nt)for(let Tt=0;Tt<te;++Tt){const st=Tt-Ue,gt=Math.max(0,Math.ceil(st/we)),Bt=Math.min(ne,(q+st)/we);for(let Pt=0;Pt<re;++Pt){const $t=Pt-Le,Ht=Math.max(0,Math.ceil($t/ke)),Ys=Math.min(pe,(ee+$t)/ke);for(let gn=0;gn<he;++gn){const Os=gn-Ge,rs=Math.max(0,Math.ceil(Os/Ne)),Rr=Math.min(de,(Y+Os)/Ne);let Ln=0;for(let hr=gt;hr<Bt;++hr){const is=hr*we-st;for(let hn=Ht;hn<Ys;++hn){const as=hn*ke-$t;for(let Tn=rs;Tn<Rr;++Tn){const ul=Tn*Ne-Os,no=I*at+N*hr+E*hn+D*Tn,zu=L*(q-1-is)+z*(ee-1-as)+P*(Y-1-ul)+_*nt;for(let Qs=0;Qs<W;++Qs){const Hi=$[no+Qs],Kr=O[zu+Qs];Ln+=Hi*Kr}}}}g[x*at+b*Tt+v*Pt+w*gn+nt]=Ln}}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const lie={kernelName:bx,backendName:"cpu",kernelFunc:oie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uie=qt(vh,n=>Math.cos(n)),cie={kernelName:vh,backendName:"cpu",kernelFunc:uie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hie=qt(wh,n=>Math.cosh(n)),die={kernelName:wh,backendName:"cpu",kernelFunc:hie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fie(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:c}=s,[d,f,p,g]=r.shape,x=i.shape[0],[b,v]=o,w=ft([x,b,v,g],"float32"),$=t.data.get(i.dataId).values,I=t.data.get(a.dataId).values,N=t.data.get(r.dataId).values,E=Ye(r.shape),D=Ye(w.shape);for(let O=0;O<x;O++){const L=O*4,z=$[L],P=$[L+1],_=$[L+2],H=$[L+3],q=I[O];if(q>=d)continue;const ee=b>1?(_-z)*(f-1)/(b-1):0,Y=v>1?(H-P)*(p-1)/(v-1):0;for(let G=0;G<b;G++){const te=b>1?z*(f-1)+G*ee:.5*(z+_)*(f-1);if(te<0||te>f-1){for(let re=0;re<v;re++)for(let he=0;he<g;he++){const W=he+re*D[2]+G*D[1]+O*D[0];w.values[W]=c}continue}if(l==="bilinear"){const re=Math.floor(te),he=Math.ceil(te),W=te-re;for(let ne=0;ne<v;ne++){const pe=v>1?P*(p-1)+ne*Y:.5*(P+H)*(p-1);if(pe<0||pe>p-1){for(let Ne=0;Ne<g;Ne++){const Ue=Ne+ne*D[2]+G*D[1]+O*D[0];w.values[Ue]=c}continue}const de=Math.floor(pe),we=Math.ceil(pe),ke=pe-de;for(let Ne=0;Ne<g;Ne++){let Ue=Ne+de*E[2]+re*E[1]+q*E[0];const Le=N[Ue];Ue=Ne+we*E[2]+re*E[1]+q*E[0];const Ge=N[Ue];Ue=Ne+de*E[2]+he*E[1]+q*E[0];const at=N[Ue];Ue=Ne+we*E[2]+he*E[1]+q*E[0];const nt=N[Ue],Tt=Le+(Ge-Le)*ke,st=at+(nt-at)*ke;Ue=Ne+ne*D[2]+G*D[1]+O*D[0],w.values[Ue]=Tt+(st-Tt)*W}}}else for(let re=0;re<v;++re){const he=v>1?P*(p-1)+re*Y:.5*(P+H)*(p-1);if(he<0||he>p-1){for(let pe=0;pe<g;pe++){const de=pe+re*D[2]+G*D[1]+O*D[0];w.values[de]=c}continue}const W=Math.round(he),ne=Math.round(te);for(let pe=0;pe<g;pe++){const de=pe+W*E[2]+ne*E[1]+q*E[0],we=pe+re*D[2]+G*D[1]+O*D[0];w.values[we]=N[de]}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const pie={kernelName:wx,backendName:"cpu",kernelFunc:fie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;qe(r,"cumprod");const l=Zt([i],r.shape.length);let c=r;l!=null&&(c=ur({inputs:{x:r},backend:t,attrs:{perm:l}}));const d=cn(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const f=ds(c.dtype,"int32"),p=y2(ue(c.shape),f),g=t.data.get(c.dataId).values,x=c.shape[c.shape.length-1],b=o?(w,$)=>w+x-$-1:(w,$)=>w+$;for(let w=0;w<g.length;w+=x)for(let $=0;$<x;$++){const I=b(w,$);if($===0)p[I]=a?1:g[I];else{const N=b(w,$-1);p[I]=a?g[N]*p[N]:g[I]*p[N]}}const v=t.makeTensorInfo(c.shape,f,p);if(l!=null){const w=xa(l),$=ur({inputs:{x:v},backend:t,attrs:{perm:w}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(c),$}return v}const gie={kernelName:vx,backendName:"cpu",kernelFunc:mie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;qe(r,"cumsum");const l=Zt([i],r.shape.length);let c=r;l!=null&&(c=ur({inputs:{x:r},backend:t,attrs:{perm:l}}));const d=cn(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const f=ds(c.dtype,"int32"),p=ws(ue(c.shape),f),g=t.data.get(c.dataId).values,x=c.shape[c.shape.length-1],b=o?(w,$)=>w+x-$-1:(w,$)=>w+$;for(let w=0;w<g.length;w+=x)for(let $=0;$<x;$++){const I=b(w,$);if($===0)p[I]=a?0:g[I];else{const N=b(w,$-1);p[I]=a?g[N]+p[N]:g[I]+p[N]}}const v=t.makeTensorInfo(c.shape,f,p);if(l!=null){const w=xa(l),$=ur({inputs:{x:v},backend:t,attrs:{perm:w}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(c),$}return v}const xie={kernelName:Sp,backendName:"cpu",kernelFunc:yie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,d=TS(l,c,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const l=t.bufferSync(r),c=t.bufferSync(i),d=c3(l,c,a,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const vie={kernelName:Sx,backendName:"cpu",kernelFunc:bie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s;B(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=r.shape[0],l=r.shape[1],c=r.shape[2],d=r.shape[3],f=l*i,p=c*i,g=d/(i*i),x=t.data.get(r.dataId).values,b=new Float32Array(o*f*p*g);let v=0;for(let w=0;w<o;++w)for(let $=0;$<f;++$){const I=Math.floor($/i),N=$%i;for(let E=0;E<p;++E){const D=Math.floor(E/i),O=E%i,L=(N*i+O)*g;for(let z=0;z<g;++z){const _=z+L+d*(D+c*(I+l*w));b[v++]=x[_]}}}return t.makeTensorInfo([o,f,p,g],r.dtype,b)}const Sie={kernelName:Cx,backendName:"cpu",kernelFunc:wie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:c}=s;qe([r,i],"depthwiseConv2DNative");const d=Ye(r.shape),f=Ye(i.shape);let p=l;p==null&&(p=[1,1]),B(ns(a,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);const g=un(r.shape,i.shape,a,p,o,c,!0),{filterHeight:x,filterWidth:b,dilationHeight:v,dilationWidth:w,padInfo:$}=g,I=$.left,N=$.top,E=g.outChannels/g.inChannels,D=new Qn(g.outShape,r.dtype),O=t.data.get(r.dataId).values,L=t.data.get(i.dataId).values,z=D.values;for(let P=0;P<g.batchSize;++P){const _=P*d[0],H=P*D.strides[0];for(let q=0;q<g.outHeight;++q){const ee=H+q*D.strides[1],Y=q*g.strideHeight-N;for(let G=0;G<x;++G){const te=Y+G*v;if(te<0||te>=g.inHeight)continue;const re=G*f[0],he=_+te*d[1];for(let W=0;W<g.outWidth;++W){const ne=ee+W*D.strides[2],pe=W*g.strideWidth-I;for(let de=0;de<b;++de){const we=pe+de*w;if(we<0||we>=g.inWidth)continue;const ke=re+de*f[1],Ne=he+we*g.inChannels;let Ue=ne,Le=ke;for(let Ge=0;Ge<g.inChannels;++Ge){const at=O[Ne+Ge];for(let nt=0;nt<E;++nt)z[Ue+nt]+=at*L[Le+nt];Ue+=E,Le+=E}}}}}}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const Cie={kernelName:Cp,backendName:"cpu",kernelFunc:pF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:d}=s;qe([r,i],"depthwiseConv2dNativeBackpropFilter");const f=un(r.shape,d,a,o,l,c,!0),{strideHeight:p,strideWidth:g,filterHeight:x,filterWidth:b}=f,v=new Qn(f.filterShape,"float32"),w=f.padInfo.left,$=f.padInfo.top,I=f.outChannels/f.inChannels,N=t.data.get(r.dataId).values,E=new Qn(r.shape,r.dtype,N),D=t.data.get(i.dataId).values,O=new Qn(i.shape,i.dtype,D);for(let L=0;L<x;++L){const z=Math.max(0,Math.ceil(($-L)/p)),P=Math.min(f.outHeight,(f.inHeight+$-L)/p);for(let _=0;_<b;++_){const H=Math.max(0,Math.ceil((w-_)/g)),q=Math.min(f.outWidth,(f.inWidth+w-_)/g);for(let ee=0;ee<f.outChannels;++ee){const Y=Math.trunc(ee/I),G=ee%I;let te=0;for(let re=0;re<f.batchSize;++re)for(let he=z;he<P;++he){const W=L+he*p-$;for(let ne=H;ne<q;++ne){const pe=_+ne*g-w;te+=E.get(re,W,pe,Y)*O.get(re,he,ne,ee)}}v.set(te,L,_,Y,G)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const kie={kernelName:$x,backendName:"cpu",kernelFunc:$ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nie(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:d}=s;qe([r,i],"depthwiseConv2DNativeBackpropInput");const f=Ye(r.shape),p=Ye(i.shape),g=un(d,i.shape,a,o,l,c,!0),x=new Qn(g.inShape,"float32"),b=x.values,[v,w,$]=x.strides,I=t.data.get(r.dataId).values,[N,E,D]=f,O=t.data.get(i.dataId).values,[L,z,P]=p,{batchSize:_,filterHeight:H,filterWidth:q,inChannels:ee,inHeight:Y,inWidth:G,outChannels:te,outHeight:re,outWidth:he,strideHeight:W,strideWidth:ne}=g,pe=H-1-g.padInfo.top,de=q-1-g.padInfo.left,we=te/ee;for(let ke=0;ke<_;++ke)for(let Ne=0;Ne<ee;++Ne)for(let Ue=0;Ue<Y;++Ue){const Le=Ue-pe,Ge=Math.max(0,Math.ceil(Le/W)),at=Math.min(re,(H+Le)/W);for(let nt=0;nt<G;++nt){const Tt=nt-de,st=Math.max(0,Math.ceil(Tt/ne)),gt=Math.min(he,(q+Tt)/ne);let Bt=0;for(let Pt=Ge;Pt<at;++Pt){const $t=Pt*W-Le;for(let Ht=st;Ht<gt;++Ht){const Ys=Ht*ne-Tt,gn=N*ke+E*Pt+D*Ht,Os=L*(H-1-$t)+z*(q-1-Ys)+P*Ne;for(let rs=0;rs<we;++rs){const Rr=Ne*we+rs,Ln=I[gn+Rr],hr=O[Os+rs];Bt+=Ln*hr}}}b[v*ke+w*Ue+$*nt+Ne]=Bt}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const Iie={kernelName:kx,backendName:"cpu",kernelFunc:Nie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tie(n){const{inputs:e,backend:t}=n,{x:s}=e,r=ue(s.shape),i=t.data.get(s.dataId).values,a=ft([r,r],s.dtype),o=a.values;for(let c=0;c<i.length;c++)o[c*r+c]=i[c];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,a.dtype,a.values)}const Eie={kernelName:Nx,backendName:"cpu",kernelFunc:Tie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rie={kernelName:$p,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:a,dilations:o}=t,l=e,c=l.data.get(s.dataId).values,d=s.shape.length,f=l.data.get(r.dataId).values,p=r.shape.length,{batchSize:g,inHeight:x,inWidth:b,inChannels:v,outHeight:w,outWidth:$,padInfo:I,strideHeight:N,strideWidth:E,filterHeight:D,filterWidth:O,dilationHeight:L,dilationWidth:z,outShape:P}=nl(s.shape,r.shape,i,a,"NHWC",o),_=ue(P),H=P.length,q=kn(s.dtype,_);for(let Y=0;Y<g;++Y)for(let G=0;G<w;++G){const te=G*N-I.top;for(let re=0;re<$;++re){const he=re*E-I.left;for(let W=0;W<v;++W){let ne=Number.MIN_SAFE_INTEGER;for(let de=0;de<D;++de){const we=te+de*L;if(we>=0&&we<x)for(let ke=0;ke<O;++ke){const Ne=he+ke*z;if(Ne>=0&&Ne<b){const Ue=ua([Y,we,Ne,W],d,Ye(s.shape)),Le=ua([de,ke,W],p,Ye(r.shape)),Ge=c[Ue]+f[Le];Ge>ne&&(ne=Ge)}}}const pe=ua([Y,G,re,W],H,Ye(P));q[pe]=ne}}}return{dataId:l.write(wu(q,s.dtype),P,s.dtype),shape:P,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aie={kernelName:Ey,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:o,dilations:l}=t,c=e,d=pi(s.shape,c.data.get(s.dataId).values),f=pi(r.shape,c.data.get(r.dataId).values),{batchSize:p,inHeight:g,inWidth:x,inChannels:b,outHeight:v,outWidth:w,padInfo:$,strideHeight:I,strideWidth:N,filterHeight:E,filterWidth:D,dilationHeight:O,dilationWidth:L,outShape:z}=nl(s.shape,r.shape,a,o,"NHWC",l);B(i.rank===z.length,()=>`Error in ${Ey}, dy must have the same rank as output ${z.length}, but got ${i.rank}`);const P=pi(z,c.data.get(i.dataId).values),_=SE(r.shape,r.dtype);for(let q=0;q<p;++q)for(let ee=0;ee<v;++ee){const Y=ee*I-$.top;for(let G=0;G<w;++G){const te=G*N-$.left;for(let re=0;re<b;++re){let he=Number.MIN_SAFE_INTEGER,W=0,ne=0;for(let pe=0;pe<E;++pe){const de=Y+pe*O;if(de>=0&&de<g)for(let we=0;we<D;++we){const ke=te+we*L;if(ke>=0&&ke<x){const Ne=d[q][de][ke][re]+f[pe][we][re];Ne>he&&(he=Ne,W=pe,ne=we)}}}_[W][ne][re]+=P[q][ee][G][re]}}}return{dataId:c.write(wu(_,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Die={kernelName:Ty,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:o,dilations:l}=t,c=e,d=pi(s.shape,c.data.get(s.dataId).values),f=pi(r.shape,c.data.get(r.dataId).values),{batchSize:p,inHeight:g,inWidth:x,inChannels:b,outHeight:v,outWidth:w,padInfo:$,strideHeight:I,strideWidth:N,filterHeight:E,filterWidth:D,dilationHeight:O,dilationWidth:L,outShape:z}=nl(s.shape,r.shape,a,o,"NHWC",l);B(i.rank===z.length,()=>`Error in ${Ty}, dy must have the same rank as output ${z.length}, but got ${i.rank}`);const P=pi(z,c.data.get(i.dataId).values),_=SE(s.shape,s.dtype);for(let q=0;q<p;++q)for(let ee=0;ee<v;++ee){const Y=ee*I-$.top;for(let G=0;G<w;++G){const te=G*N-$.left;for(let re=0;re<b;++re){let he=Number.MIN_SAFE_INTEGER,W=Y<0?0:Y,ne=te<0?0:te;for(let pe=0;pe<E;++pe){const de=Y+pe*O;if(de>=0&&de<g)for(let we=0;we<D;++we){const ke=te+we*L;if(ke>=0&&ke<x){const Ne=d[q][de][ke][re]+f[pe][we][re];Ne>he&&(he=Ne,W=de,ne=ke)}}}_[q][W][ne][re]+=P[q][ee][G][re]}}}return{dataId:c.write(wu(_,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ie(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:a}=s,{contextOptions:o,imageOptions:l}=a||{},c=l?.alpha||1,d=o?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const f=i.getContext(d,o?.contextAttributes||{});if(f==null)throw new Error(`Could not get the context with ${d} type.`);const[p,g]=r.shape.slice(0,2),x=r.shape.length===2?1:r.shape[2],b=t.data.get(r.dataId).values,v=r.dtype==="float32"?255:1,w=new Uint8ClampedArray(g*p*4);for(let I=0;I<p*g;++I){const N=[0,0,0,255*c];for(let D=0;D<x;D++){const O=b[I*x+D];if(r.dtype==="float32"){if(O<0||O>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${O}.`)}else if(r.dtype==="int32"&&(O<0||O>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${O}.`);x===1?(N[0]=O*v,N[1]=O*v,N[2]=O*v):N[D]=O*v}const E=I*4;w[E+0]=Math.round(N[0]),w[E+1]=Math.round(N[1]),w[E+2]=Math.round(N[2]),w[E+3]=Math.round(N[3])}i.width=g,i.height=p;const $=new ImageData(w,g,p);return f.putImageData($,0,0),r}const Oie={kernelName:b2,backendName:"cpu",kernelFunc:_ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Em(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;qe(r,"sum");let o;r.dtype==="bool"?o=qo({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):o=pa({inputs:{x:r},backend:t});const l=o.shape.length,c=pt(i,o.shape),d=Zt(c,l);let f=c,p=o;d!=null&&(p=ur({inputs:{x:o},backend:t,attrs:{perm:d}}),f=cn(f.length,l)),Gn("sum",f,p.shape.length);const[g,x]=On(p.shape,f),b=ds(p.dtype,"int32");let v=By(t,g,b);const w=ue(x),$=t.data.get(v.dataId).values,I=t.data.get(p.dataId).values;for(let N=0;N<$.length;++N){const E=N*w;let D=0;for(let O=0;O<w;++O)D+=I[E+O];$[N]=D}if(a){const N=In(v.shape,c),E=v;v=ln({inputs:{x:v},backend:t,attrs:{shape:N}}),t.disposeIntermediateTensorInfo(E)}return t.disposeIntermediateTensorInfo(o),d!=null&&t.disposeIntermediateTensorInfo(p),v}const Fie={kernelName:sm,backendName:"cpu",kernelFunc:Em};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zie(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:l}=qb(r,i.length);Kb(a.length,l,i);const{path:c,steps:d}=Yb(o,l),f=d.length;let p=null,g=a.length;const x=[];for(let b=0;b<f;++b){for(const v of d[b]){const{permutationIndices:w,expandDims:$}=Xb(g,l[v]);let I;Qb(w)?I=i[v]:(I=ur({inputs:{x:i[v]},backend:t,attrs:{perm:w}}),x.push(I));const N=I.shape.slice();for(let E=0;E<$.length;++E)N.splice($[E],0,1);yt(I.shape,N)||(I=ln({inputs:{x:I},backend:t,attrs:{shape:N}}),x.push(I)),p===null?p=I:(p=s0({inputs:{a:I,b:p},backend:t}),x.push(p))}b<f-1&&(c[b]>=0&&(p=Em({inputs:{x:p},backend:t,attrs:{axis:c[b]-(a.length-g),keepDims:!1}}),x.push(p)),g--)}for(const b of x)b!==p&&t.disposeIntermediateTensorInfo(b);return p}const Lie={kernelName:Ix,backendName:"cpu",kernelFunc:zie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pie(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;qe([s,r],"eluGrad");const i=new Float32Array(ue(r.shape)),a=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values;for(let l=0;l<a.length;++l){const c=a[l];c>=0?i[l]=o[l]:i[l]=o[l]*(c+1)}return t.makeTensorInfo(r.shape,"float32",i)}const Mie={kernelName:Tx,backendName:"cpu",kernelFunc:Pie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bie=Vb,Vie=Ub,Uie=Wb,Wie=Gb,Gie=Hb,Hie=jb,jie=qt($h,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+Bie*t);return e*(1-((((Hie*s+Gie)*s+Wie)*s+Uie)*s+Vie)*s*Math.exp(-t*t))}),qie={kernelName:$h,backendName:"cpu",kernelFunc:jie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tx(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,a=r.shape.length,o=r.shape.slice();let l=i;return i<0&&(B(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+i+1),o.splice(l,0,1),ln({inputs:{x:r},backend:t,attrs:{shape:o}})}const Xie={kernelName:Np,backendName:"cpu",kernelFunc:tx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kie=Fn((n,e)=>n/e),iC=ss(Sh,Kie),o2={kernelName:Sh,backendName:"cpu",kernelFunc:iC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF(n,e,t){const s=n.shape,r=s[0],i=s[1],a=t.data.get(n.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,c=[r,i],d=ue(c),f=es("float32",d),p=es("float32",d);for(let v=0;v<r;v++){const w=gu({inputs:{x:o},backend:t,attrs:{begin:[v,0],size:[1,i]}}),$=gu({inputs:{x:l},backend:t,attrs:{begin:[v,0],size:[1,i]}}),I=wr({inputs:{real:w,imag:$},backend:t}),{real:N,imag:E}=Yie(I,e,t),D=Li(N,E);for(let O=0;O<i;O++){const L=SS(D,O);f[v*i+O]=L.real,p[v*i+O]=L.imag}t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo($),t.disposeIntermediateTensorInfo(I)}const g=t.makeTensorInfo(c,"float32",f),x=t.makeTensorInfo(c,"float32",p),b=wr({inputs:{real:g,imag:x},backend:t});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),b}function Yie(n,e,t){const s=ue(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,a=t.data.get(r.complexTensorInfos.imag.dataId).values;if(Qie(s)){const o=l2(i,a,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",o.real),d=t.makeTensorInfo(l,"float32",o.imag),f=t.makeTensorInfo([],"float32",Jo(s,"float32")),p=pa({inputs:{x:f},backend:t}),g=o2.kernelFunc({inputs:{a:c,b:f},backend:t}),x=o2.kernelFunc({inputs:{a:d,b:p},backend:t}),b=t.data.get(g.dataId).values,v=t.data.get(x.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),{real:b,imag:v}}return o}else{const o=Li(i,a),l=Zie(o,s,e);return _A(l)}}function Qie(n){return(n&n-1)===0}function l2(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=Li(n,e),a=t/2,o=OA(i),l=o.real,c=o.imag,d=[l.length],f=r.makeTensorInfo(d,"float32",l),p=r.makeTensorInfo(d,"float32",c),g=wr({inputs:{real:f,imag:p},backend:r}),x=FA(i),b=x.real,v=x.imag,w=[b.length],$=r.makeTensorInfo(w,"float32",b),I=r.makeTensorInfo(w,"float32",v),N=wr({inputs:{real:$,imag:I},backend:r}),E=l2(l,c,a,s,r),D=E.real,O=E.imag,L=[D.length],z=r.makeTensorInfo(L,"float32",D),P=r.makeTensorInfo(L,"float32",O),_=wr({inputs:{real:z,imag:P},backend:r}),H=l2(b,v,a,s,r),q=H.real,ee=H.imag,Y=[q.length],G=r.makeTensorInfo(Y,"float32",q),te=r.makeTensorInfo(Y,"float32",ee),re=wr({inputs:{real:G,imag:te},backend:r}),he=LA(t,s),W=[he.real.length],ne=r.makeTensorInfo(W,"float32",he.real),pe=r.makeTensorInfo(W,"float32",he.imag),de=wr({inputs:{real:ne,imag:pe},backend:r}),we=s0({inputs:{a:de,b:re},backend:r}),ke=eh({inputs:{a:_,b:we},backend:r}),Ne=DS({inputs:{a:_,b:we},backend:r}),Ue=mu({inputs:{input:ke},backend:r}),Le=mu({inputs:{input:Ne},backend:r}),Ge=sh({inputs:{input:ke},backend:r}),at=sh({inputs:{input:Ne},backend:r}),nt=rh({inputs:[Ue,Le],backend:r,attrs:{axis:0}}),Tt=rh({inputs:[Ge,at],backend:r,attrs:{axis:0}}),st=r.data.get(nt.dataId).values,gt=r.data.get(Tt.dataId).values;return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(re),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(we),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(Ne),r.disposeIntermediateTensorInfo(Ue),r.disposeIntermediateTensorInfo(Ge),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo(at),r.disposeIntermediateTensorInfo(nt),r.disposeIntermediateTensorInfo(Tt),{real:st,imag:gt}}function Zie(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,a=0;for(let o=0;o<e;o++){const l=PA(r*o,e,t),c=SS(n,o);i+=c.real*l.real-c.imag*l.imag,a+=c.real*l.imag+c.imag*l.real}t&&(i/=e,a/=e),zA(s,i,a,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jie(n){const{inputs:e,backend:t}=n,{input:s}=e,r=ue(s.shape),i=s.shape[s.shape.length-1],a=r/i,o=ln({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),l=mF(o,!1,t),c=ln({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const eae={kernelName:Ex,backendName:"cpu",kernelFunc:Jie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aC(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,a=i||bu(r),o=kn(a,ue(s));return nae(o,r,a),e.makeTensorInfo(s,a,o)}const tae={kernelName:Rx,backendName:"cpu",kernelFunc:aC};function nae(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sae={kernelName:Ax,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=es(s.dtype,ue(s.shape)),[a,o,l,c]=s.shape,d=r.data.get(s.dataId).values;for(let p=0;p<a;p++){const g=p*l*o*c;for(let x=0;x<o;x++){const b=x*(l*c);for(let v=0;v<l;v++){const w=v*c;for(let $=0;$<c;$++){const I=Math.round(l-v-1),N=g+b+w+$;let E=d[N];if(I>=0&&I<l){const D=I*c,O=g+b+D+$;E=d[O]}i[N]=E}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:x}=s;let b=fF({inputs:{x:r,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p}});if(a){const v=b;if(d==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const w=ln({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});b=eh({inputs:{a:b,b:w},backend:t}),t.disposeIntermediateTensorInfo(w)}else b=eh({inputs:{a:b,b:a},backend:t});t.disposeIntermediateTensorInfo(v)}if(g){const v=b;if(d==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const w=ln({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});b=ex(t,b,g,w,x),t.disposeIntermediateTensorInfo(w)}else b=ex(t,b,g,o,x);t.disposeIntermediateTensorInfo(v)}return b}const iae={kernelName:Uf,backendName:"cpu",kernelFunc:rae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:x}=s;let b=pF({inputs:{x:r,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p}});if(a){const v=b;b=eh({inputs:{a:b,b:a},backend:t}),t.disposeIntermediateTensorInfo(v)}if(g){const v=b;b=ex(t,b,g,o,x),t.disposeIntermediateTensorInfo(v)}return b}const oae={kernelName:Wf,backendName:"cpu",kernelFunc:aae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lae(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=ue(s.shape),a=r.shape,o=a[a.length-1],[l,c,d,f]=Db(s,r);if(c===0)return t.makeTensorInfo(l,s.dtype,[]);const p=t.data.get(r.dataId).values,g=t.bufferSync(s),x=w3(p,g,s.dtype,c,o,d,f,s.shape,i);return t.makeTensorInfo(l,s.dtype,x.values)}const uae={kernelName:Dx,backendName:"cpu",kernelFunc:lae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s;qe([r,i],"gatherV2");const l=pt(a,r.shape)[0],c=t.data.get(i.dataId).values,d=r.shape[l];for(let N=0;N<c.length;++N){const E=c[N];B(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let f=o;o==null&&(f=0);const p=ue(i.shape),g=Jb(r,i,l,f),x=ln({inputs:{x:r},backend:t,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),b=ln({inputs:{x:i},backend:t,attrs:{shape:[g.batchSize,p/g.batchSize]}}),v=[g.batchSize,g.outerSize,p/g.batchSize,g.sliceSize],w=t.bufferSync(b),$=t.bufferSync(x),I=S3($,w,v);return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),t.makeTensorInfo(g.outputShape,I.dtype,I.values)}const hae={kernelName:Tp,backendName:"cpu",kernelFunc:cae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dae(n){const{inputs:e,backend:t}=n,{input:s}=e,r=ue(s.shape),i=s.shape[s.shape.length-1],a=r/i,o=ln({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),l=mF(o,!0,t),c=ln({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const fae={kernelName:_x,backendName:"cpu",kernelFunc:dae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pae=qt(Ah,n=>Number.isFinite(n)?1:0,"bool"),mae={kernelName:Ah,backendName:"cpu",kernelFunc:pae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gae=qt(Dh,n=>Math.abs(n)===1/0?1:0,"bool"),yae={kernelName:Dh,backendName:"cpu",kernelFunc:gae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xae=qt(_h,n=>Number.isNaN(n)?1:0,"bool"),bae={kernelName:_h,backendName:"cpu",kernelFunc:xae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vae(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=I3(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const wae={kernelName:Fx,backendName:"cpu",kernelFunc:vae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sae=qt(Fh,n=>Math.log1p(n)),Cae={kernelName:Fh,backendName:"cpu",kernelFunc:Sae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ae=Fn((n,e)=>n&&e),kae=ss(_p,$ae,null,"bool"),Nae={kernelName:_p,backendName:"cpu",kernelFunc:kae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iae=qt(Op,n=>n?0:1,"bool"),Tae={kernelName:Op,backendName:"cpu",kernelFunc:Iae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eae=Fn((n,e)=>n||e),Rae=ss(Fp,Eae,null,"bool"),Aae={kernelName:Fp,backendName:"cpu",kernelFunc:Rae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s;qe(r,"LRN");const c=r.shape[3],d=c-1,f=t.data.get(r.dataId).values,p=ue(r.shape),g=new Float32Array(p);function x(b){const v=b%c;let w=b-v+Math.max(0,v-i);const $=b-v+Math.min(v+i,d);let I=0;for(;w<=$;w++){const N=f[w];I+=N*N}return I}for(let b=0;b<p;b++){const v=x(b),w=f[b]*Math.pow(a+o*v,-l);g[b]=w}return t.makeTensorInfo(r.shape,r.dtype,g)}const _ae={kernelName:zp,backendName:"cpu",kernelFunc:Dae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:c,beta:d}=s;qe(a,"LRNGrad");const f=ue(a.shape),p=a.shape[3],g=t.data.get(a.dataId).values,x=t.data.get(r.dataId).values,b=t.data.get(i.dataId).values,v=new Float32Array(f),w=f;for(let $=0;$<w;$++){const I=$%p,N=$-I+Math.max(0,I-o),E=$-I+Math.min(p,I+o+1);let D=0;for(let O=N;O<E;O++)D+=Math.pow(x[O],2);D=c*D+l;for(let O=N;O<E;O++){let L=-2*c*d*x[O]*b[$]/D;$===O&&(L+=Math.pow(D,-d)),L*=g[$],v[O]+=L}}return t.makeTensorInfo(a.shape,r.dtype,v)}const Fae={kernelName:zx,backendName:"cpu",kernelFunc:Oae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=t;let l=r.shape;const c=l.length,d=pt(i,l);let f=d;const p=Zt(f,c);let g=o.data.get(r.dataId).values;if(p!=null){const N=new Array(c);for(let E=0;E<N.length;E++)N[E]=l[p[E]];g=RS(g,l,r.dtype,p,N),f=cn(f.length,c),l=N}qe(r,"max"),Gn("max",f,c);const[x,b]=On(l,f),v=ue(b),w=E3(g,v,x,r.dtype),$=o.write(w,x,r.dtype);let I=x;return a&&(I=In(x,d)),{dataId:$,shape:I,dtype:r.dtype}}const zae={kernelName:Lp,backendName:"cpu",kernelFunc:gF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;qe(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,c=1;B(ns(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=As(r.shape,i,a,c,o,l);let f;if(d.filterWidth===1&&d.filterHeight===1&&yt(d.inShape,d.outShape))f=pa({inputs:{x:r},backend:t});else{const p=t.data.get(r.dataId).values,g=Ye(r.shape),x=rC(p,r.shape,r.dtype,g,d,"max");f=t.makeTensorInfo(d.outShape,r.dtype,x.values)}return f}const Pae={kernelName:Pp,backendName:"cpu",kernelFunc:Lae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s;qe(r,"maxPool3d");const d=jr(r.shape,i,a,1,o,l,c),f=t.data.get(r.dataId).values,p=dF(f,r.shape,r.dtype,Ye(r.shape),d,"max");return t.makeTensorInfo(p.shape,"float32",p.values)}const Bae={kernelName:Mp,backendName:"cpu",kernelFunc:Mae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vae(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:c}=s;qe([r,i],"maxPool3DGrad");const d=jr(i.shape,a,o,1,l,c),f=t.bufferSync(i),p=Ere(f,d),g=d.strideDepth,x=d.strideHeight,b=d.strideWidth,v=d.dilationDepth,w=d.dilationHeight,$=d.dilationWidth,I=d.effectiveFilterDepth,N=d.effectiveFilterHeight,E=d.effectiveFilterWidth,D=I-1-d.padInfo.front,O=E-1-d.padInfo.left,L=N-1-d.padInfo.top,z=ft(i.shape,"float32"),P=t.bufferSync(r);for(let _=0;_<d.batchSize;++_)for(let H=0;H<d.inChannels;++H)for(let q=0;q<d.inDepth;++q)for(let ee=0;ee<d.inHeight;++ee)for(let Y=0;Y<d.inWidth;++Y){const G=q-D,te=ee-L,re=Y-O;let he=0;for(let W=0;W<I;W+=v){const ne=(G+W)/g;if(!(ne<0||ne>=d.outDepth||Math.floor(ne)!==ne))for(let pe=0;pe<N;pe+=w){const de=(te+pe)/x;if(!(de<0||de>=d.outHeight||Math.floor(de)!==de))for(let we=0;we<E;we+=$){const ke=(re+we)/b;if(ke<0||ke>=d.outWidth||Math.floor(ke)!==ke)continue;const Ne=I*N*E-1-p.get(_,ne,de,ke,H),Ue=W*N*E+pe*E+we,Le=Ne===Ue?1:0;if(Le===0)continue;const Ge=P.get(_,ne,de,ke,H);he+=Ge*Le}}}z.set(he,_,q,ee,Y,H)}return t.makeTensorInfo(z.shape,z.dtype,z.values)}const Uae={kernelName:Px,backendName:"cpu",kernelFunc:Vae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wae(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;qe([i,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=s,p=As(o.shape,l,c,1,d,f),g=t.data.get(o.dataId).values,x=ft(p.outShape,o.dtype,hF(g,o.shape,o.dtype,p).values),b=p.strideHeight,v=p.strideWidth,w=p.dilationHeight,$=p.dilationWidth,I=p.effectiveFilterHeight,N=p.effectiveFilterWidth,E=N-1-p.padInfo.left,D=I-1-p.padInfo.top,O=ft(o.shape,"float32"),L=t.data.get(r.dataId).values,z=ft(r.shape,"float32",L);for(let P=0;P<p.batchSize;++P)for(let _=0;_<p.inChannels;++_)for(let H=0;H<p.inHeight;++H)for(let q=0;q<p.inWidth;++q){const ee=H-D,Y=q-E;let G=0;for(let te=0;te<I;te+=w){const re=(ee+te)/b;if(!(re<0||re>=p.outHeight||Math.floor(re)!==re))for(let he=0;he<N;he+=$){const W=(Y+he)/v;if(W<0||W>=p.outWidth||Math.floor(W)!==W)continue;const ne=I*N-1-x.get(P,re,W,_),pe=te*N+he,de=ne===pe?1:0;if(de===0)continue;const we=z.get(P,re,W,_);G+=we*de}}O.set(G,P,H,q,_)}return t.makeTensorInfo(O.shape,O.dtype,O.values)}const Gae={kernelName:Lx,backendName:"cpu",kernelFunc:Wae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hae(n,e,t,s,r){const i=Ye(e),a=rC(n,e,t,i,r,"max"),o=hF(n,e,t,r,!0,s);return[a.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jae={kernelName:Mx,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,l=t;qe(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,d=As(s.shape,r,i,[1,1],a),[f,p]=Hae(c,s.shape,s.dtype,o,d),g=l.write(f,d.outShape,s.dtype),x=l.write(p,d.outShape,s.dtype);return[{dataId:g,shape:d.outShape,dtype:s.dtype},{dataId:x,shape:d.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=pt(i,r.shape),c=On(r.shape,o)[1],d=ue(c),f=[],p=t.makeTensorInfo([],"float32",new Float32Array([d]));f.push(p);const g=qo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});f.push(g);const x=iC({inputs:{a:g,b:p},backend:t});f.push(x);const b=Em({inputs:{x},backend:t,attrs:{axis:i,keepDims:a}});return f.forEach(v=>t.disposeIntermediateTensorInfo(v)),b}const Xae={kernelName:Bp,backendName:"cpu",kernelFunc:qae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;qe(r,"min");const o=pt(i,r.shape);let l=o;const c=Zt(l,r.shape.length);let d=r;c!=null&&(d=ur({inputs:{x:r},backend:t,attrs:{perm:c}}),l=cn(l.length,r.shape.length)),Gn("min",l,d.shape.length);const[f,p]=On(d.shape,l),g=ue(p),x=ws(ue(f),d.dtype),b=t.data.get(d.dataId).values;for(let w=0;w<x.length;++w){const $=w*g;let I=b[$];for(let N=0;N<g;++N){const E=b[$+N];(Number.isNaN(E)||E<I)&&(I=E)}x[w]=I}c!=null&&t.disposeIntermediateTensorInfo(d);const v=t.makeTensorInfo(f,d.dtype,x);if(a){const w=In(f,o),$=ln({inputs:{x:v},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(v),$}return v}const Yae={kernelName:Vp,backendName:"cpu",kernelFunc:Kae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:a}=s;qe(r,"mirrorPad");const o=i.map((I,N)=>I[0]+r.shape[N]+I[1]),l=i.map(I=>I[0]),c=i.map((I,N)=>I[0]+r.shape[N]),d=a==="reflect"?0:1,f=t.data.get(r.dataId).values,p=r.shape.length,g=Ye(r.shape),x=ue(o),b=o.length,v=Ye(o),w=es(r.dtype,x);for(let I=0;I<x;I++){let N=uh(I,b,v);for(let D=0;D<b;D++)N[D]<l[D]?N[D]=l[D]*2-N[D]-d:N[D]>=c[D]&&(N[D]=(c[D]-1)*2-N[D]+d);N=N.map((D,O)=>D-l[O]);const E=ua(N,p,g);w[I]=f[E]}return{dataId:t.write(w,o,r.dtype),shape:o,dtype:r.dtype}}const Zae={kernelName:Up,backendName:"cpu",kernelFunc:Qae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jae=Fn((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),eoe=ss(Ph,Jae),toe={kernelName:Ph,backendName:"cpu",kernelFunc:eoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=r.shape.length;let o=i;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=pt([o],r.shape),c=gF({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),d=In(c.shape,l),f=ln({inputs:{x:c},backend:t,attrs:{shape:d}}),p=DS({inputs:{a:r,b:f},backend:t}),g=y3({inputs:{x:p},backend:t}),x=Em({inputs:{x:g},backend:t,attrs:{axis:l,keepDims:!1}}),b=ln({inputs:{x},backend:t,attrs:{shape:d}}),v=iC({inputs:{a:g,b},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),v}const noe={kernelName:am,backendName:"cpu",kernelFunc:yF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function soe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s;qe(r,"multinomial");const l=o?r:yF({inputs:{logits:r},backend:t,attrs:{dim:-1}}),c=l.shape[0],d=l.shape[1],f=t.data.get(l.dataId).values,p=[c,i],g=ws(ue(p),"int32");for(let x=0;x<c;++x){const b=x*d,v=new Float32Array(d-1);v[0]=f[b];for(let I=1;I<v.length;++I)v[I]=v[I-1]+f[b+I];const w=vb.alea(a.toString()),$=x*i;for(let I=0;I<i;++I){const N=w();g[$+I]=v.length;for(let E=0;E<v.length;E++)if(N<v[E]){g[$+I]=E;break}}}return o||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(p,"int32",g)}const roe={kernelName:Bx,backendName:"cpu",kernelFunc:soe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ioe=Rb;function aoe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s;qe(r,"NonMaxSuppression");const c=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,{selectedIndices:f}=ioe(c,d,a,o,l);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const ooe={kernelName:Vx,backendName:"cpu",kernelFunc:aoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const loe=fS;function uoe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s;qe(r,"NonMaxSuppressionPadded");const d=t.data.get(r.dataId).values,f=t.data.get(i.dataId).values,{selectedIndices:p,validOutputs:g}=loe(d,f,a,o,l,c);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const coe={kernelName:v2,backendName:"cpu",kernelFunc:uoe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hoe=Ab;function doe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s;qe(r,"NonMaxSuppressionWithScore");const d=t.data.get(r.dataId).values,f=t.data.get(i.dataId).values,p=a,g=o,x=l,b=c,{selectedIndices:v,selectedScores:w}=hoe(d,f,p,g,x,b);return[t.makeTensorInfo([v.length],"int32",new Int32Array(v)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const foe={kernelName:Ux,backendName:"cpu",kernelFunc:doe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function poe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:l}=s;qe(r,"oneHot");const c=ue(r.shape),d=new Float32Array(c*a);d.fill(l);const f=t.data.get(r.dataId).values;for(let p=0;p<c;++p)f[p]>=0&&f[p]<a&&(d[p*a+f[p]]=o);return t.makeTensorInfo([...r.shape,a],i,d)}const moe={kernelName:jp,backendName:"cpu",kernelFunc:poe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nx(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=mu({inputs:{input:s},backend:t}),i=nx({inputs:{x:r},backend:t}),a=sh({inputs:{input:s},backend:t}),o=nx({inputs:{x:a},backend:t}),l=wr({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return aC({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const goe={kernelName:um,backendName:"cpu",kernelFunc:nx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=mu({inputs:{input:s},backend:t}),i=xF({inputs:{x:r},backend:t}),a=sh({inputs:{input:s},backend:t}),o=nx({inputs:{x:a},backend:t}),l=wr({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return aC({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const yoe={kernelName:Hp,backendName:"cpu",kernelFunc:xF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return tx({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{cr(i,d.shape,"All tensors passed to stack must have matching shapes"),B(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(d=>{const f=tx({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(f),f}),c=rh({inputs:l,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}const xoe={kernelName:qp,backendName:"cpu",kernelFunc:bF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function boe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;qe(r,"pad");const o=i.map(($,I)=>$[0]+r.shape[I]+$[1]),l=i.map($=>$[0]),c=t.data.get(r.dataId).values,d=ue(r.shape),f=r.shape.length,p=Ye(r.shape),g=ue(o),x=o.length,b=Ye(o),v=es(r.dtype,g);a!==0&&v.fill(a);for(let $=0;$<d;$++){const N=uh($,f,p).map((D,O)=>D+l[O]),E=ua(N,x,b);v[E]=c[$]}return{dataId:t.write(v,o,r.dtype),shape:o,dtype:r.dtype}}const vF={kernelName:Xp,backendName:"cpu",kernelFunc:boe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const voe=Fn((n,e)=>Math.pow(n,e)),woe=ss(Bh,voe),Soe={kernelName:Bh,backendName:"cpu",kernelFunc:woe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Coe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:o}=s,l=r.map(w=>t.data.get(w.dataId).values),c=r.map(w=>w.shape),d=t.data.get(i.dataId).values,f=t.data.get(a.dataId).values,[p,g,x]=F3(l,c,d,i.shape,i.dtype,f,a.shape),b=p.map(w=>t.makeTensorInfo([w.length],"int32",w)),v=t.makeTensorInfo(x,i.dtype,g);return b.concat([v])}const $oe={kernelName:w2,backendName:"cpu",kernelFunc:Coe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function koe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[c,d]=z3(a,s.shape,s.dtype,o,r.shape,l,i.shape),f=t.makeTensorInfo([c.length],"int32",c),p=t.makeTensorInfo([d.length],s.dtype,d);return[f,p]}const Noe={kernelName:S2,backendName:"cpu",kernelFunc:koe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ioe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,c=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,f=t.data.get(a.dataId).values,p=o.map(v=>t.data.get(v.dataId).values),g=o.map(v=>v.shape),[x,b]=L3(c,r.shape,d,i.shape,i.dtype,f,a.shape,p,g,l);return t.makeTensorInfo(x,i.dtype,b)}const Toe={kernelName:C2,backendName:"cpu",kernelFunc:Ioe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eoe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:a}=t,o=P3(s,r,a,i);return e.makeTensorInfo([o.length],i,o)}const Roe={kernelName:Wx,backendName:"cpu",kernelFunc:Eoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aoe=qt(Vh,n=>1/n),Doe={kernelName:Vh,backendName:"cpu",kernelFunc:Aoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _oe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;qe(r,"resizeBilinear");const l=Ye(r.shape),[c,d]=o,[f,p,g,x]=r.shape,b=t.data.get(r.dataId).values,v=new Float32Array(ue([f,c,d,x])),w=[i&&c>1?p-1:p,i&&d>1?g-1:g],$=[i&&c>1?c-1:c,i&&d>1?d-1:d];let I=0;const N=w[0]/$[0],E=w[1]/$[1];for(let D=0;D<f;D++)for(let O=0;O<c;O++){let L;a?L=N*(O+.5)-.5:L=N*O;const z=Math.max(0,Math.floor(L)),P=L-z,_=Math.min(p-1,Math.ceil(L)),H=D*l[0]+z*l[1],q=D*l[0]+_*l[1];for(let ee=0;ee<d;ee++){let Y;a?Y=E*(ee+.5)-.5:Y=E*ee;const G=Math.max(0,Math.floor(Y)),te=Y-G,re=Math.min(g-1,Math.ceil(Y)),he=H+G*l[2],W=q+G*l[2],ne=H+re*l[2],pe=q+re*l[2];for(let de=0;de<x;de++){const we=b[he+de],ke=b[W+de],Ne=b[ne+de],Ue=b[pe+de],Le=we+(Ne-we)*te,Ge=ke+(Ue-ke)*te,at=Le+(Ge-Le)*P;v[I++]=at}}}return t.makeTensorInfo([f,c,d,x],"float32",v)}const Ooe={kernelName:Jp,backendName:"cpu",kernelFunc:_oe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Foe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;qe([i,r],"resizeBilinearGrad");const o=Ye(r.shape),[l,c,d,f]=r.shape,[,p,g]=i.shape,x=new Float32Array(l*c*d*f),b=[a&&p>1?c-1:c,a&&g>1?d-1:d],v=[a&&p>1?p-1:p,a&&g>1?g-1:g],w=b[0]/v[0],$=b[1]/v[1],I=t.data.get(i.dataId).values;let N=0;for(let E=0;E<l;E++){const D=E*o[0];for(let O=0;O<p;O++){const L=O*w,z=Math.floor(L),P=Math.min(Math.ceil(L),c-1),_=D+z*o[1],H=D+P*o[1],q=L-z,ee=1-q;for(let Y=0;Y<g;Y++){const G=Y*$,te=Math.floor(G),re=Math.min(Math.ceil(G),d-1),he=G-te,W=1-he,ne=_+te*o[2],pe=_+re*o[2],de=H+te*o[2],we=H+re*o[2],ke=ee*W,Ne=ee*he,Ue=q*W,Le=q*he;for(let Ge=0;Ge<f;Ge++){const at=I[N++];x[ne+Ge]+=at*ke,x[pe+Ge]+=at*Ne,x[de+Ge]+=at*Ue,x[we+Ge]+=at*Le}}}}return t.makeTensorInfo([l,d,c,f],"float32",x)}const zoe={kernelName:jx,backendName:"cpu",kernelFunc:Foe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Loe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;qe(r,"resizeNearestNeighbor");const l=Ye(r.shape),[c,d]=o,[f,p,g,x]=r.shape,b=t.data.get(r.dataId).values,v=new Float32Array(f*c*d*x),w=[i&&c>1?p-1:p,i&&d>1?g-1:g],$=[i&&c>1?c-1:c,i&&d>1?d-1:d],I=w[0]/$[0],N=w[1]/$[1];let E=0;for(let D=0;D<f;D++){const O=D*l[0];for(let L=0;L<c;L++){const z=a?I*(L+.5):I*L;let P=Math.min(p-1,i?Math.round(z):Math.floor(z));a&&(P=Math.max(0,P));const _=O+P*l[1];for(let H=0;H<d;H++){const q=a?N*(H+.5):N*H;let ee=Math.min(g-1,i?Math.round(q):Math.floor(q));a&&(ee=Math.max(0,ee));const Y=_+ee*l[2];for(let G=0;G<x;G++){const te=b[Y+G];v[E++]=te}}}}return t.makeTensorInfo([f,c,d,x],r.dtype,v)}const Poe={kernelName:Zp,backendName:"cpu",kernelFunc:Loe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Moe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;qe([i,r],"resizeNearestNeighborGrad");const o=Ye(r.shape),l=Ye(i.shape),[c,d,f,p]=r.shape,[,g,x]=i.shape,b=new Float32Array(c*d*f*p),v=t.data.get(i.dataId).values,w=[a&&g>1?d-1:d,a&&x>1?f-1:f],$=[a&&g>1?g-1:g,a&&x>1?x-1:x],I=w[0]/$[0],N=w[1]/$[1],E=1/I,D=1/N,O=Math.ceil(E)*2+2,L=Math.ceil(D)*2+2;for(let z=0;z<c;z++){const P=z*o[0];for(let _=0;_<d;_++){const H=P+_*o[1],q=Math.floor(_*E),ee=Math.floor(q-O/2);for(let Y=0;Y<f;Y++){const G=H+Y*o[2],te=Math.floor(Y*D),re=Math.floor(te-L/2);for(let he=0;he<p;he++){let W=0;for(let ne=0;ne<O;ne++){const pe=ne+ee;if(pe<0||pe>=g)continue;const de=P+pe*l[1],we=pe*I,ke=Math.min(d-1,a?Math.round(we):Math.floor(we));if(_===ke)for(let Ne=0;Ne<L;Ne++){const Ue=Ne+re;if(Ue<0||Ue>=x)continue;const Le=de+Ue*l[2],Ge=Ue*N,at=Math.min(f-1,a?Math.round(Ge):Math.floor(Ge));Y===at&&(W+=v[Le+he])}}b[G+he]=W}}}}return t.makeTensorInfo(r.shape,r.dtype,b)}const Boe={kernelName:Hx,backendName:"cpu",kernelFunc:Moe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Voe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;qe(r,"reverse");const a=r.shape.length,o=pt(i,r.shape);if(a===0)return pa({inputs:{x:r},backend:t});const l=new Qn(r.shape,r.dtype),c=t.bufferSync(r);for(let d=0;d<l.size;d++){const f=l.indexToLoc(d),p=f.slice();o.forEach(g=>p[g]=r.shape[g]-1-p[g]),l.set(c.get(...p),...f)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const Uoe={kernelName:em,backendName:"cpu",kernelFunc:Voe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Woe={kernelName:ib,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,l=es(s.dtype,ue(s.shape)),[c,d,f,p]=s.shape,[g,x]=Pb(a,d,f),b=255,v=Math.sin(r),w=Math.cos(r),$=o.data.get(s.dataId).values;for(let N=0;N<c;N++){const E=N*f*d*p;for(let D=0;D<d;D++){const O=D*(f*p);for(let L=0;L<f;L++){const z=L*p;for(let P=0;P<p;P++){const _=[c,D,L,P],H=_[2],q=_[1];let ee=(H-g)*w-(q-x)*v,Y=(H-g)*v+(q-x)*w;ee=Math.round(ee+g),Y=Math.round(Y+x);let G=i;if(typeof i!="number"&&(P===3?G=b:G=i[P]),ee>=0&&ee<f&&Y>=0&&Y<d){const re=Y*(f*p),he=ee*p,W=E+re+he+P;G=$[W]}const te=E+O+z+P;l[te]=G}}}}return{dataId:o.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Goe=qt(Gh,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),Hoe={kernelName:Gh,backendName:"cpu",kernelFunc:Goe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function joe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=va(i,r,a),p=!0,g=t.bufferSync(r),x=t.bufferSync(i),b=Ql(g,x,a,f,c,l,o,d,0,p);return t.makeTensorInfo(a,b.dtype,b.values)}const qoe={kernelName:qx,backendName:"cpu",kernelFunc:joe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xoe(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function Koe(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function Yoe(n,e,t,s,r,i){const a=kn("int32",t*r);for(let o=0;o<t;++o){const l=n.slice(o*s,(o+1)*s),c=o*r;for(let d=0;d<r;++d)a[c+d]=i==="left"?Xoe(l,e[d+c]):Koe(l,e[d+c])}return a}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qoe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,c=Yoe(o,l,r.shape[0],r.shape[1],i.shape[1],a);return t.makeTensorInfo(i.shape,"int32",c)}const Zoe={kernelName:Kx,backendName:"cpu",kernelFunc:Qoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Joe(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;qe([s,r,i],"select");const a=s.shape.length,o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,d=ds(r.dtype,i.dtype),f=ws(ue(r.shape),d);let p=0;const g=a===0||a>1||r.shape.length===1?1:ue(r.shape.slice(1));for(let x=0;x<o.length;x++)for(let b=0;b<g;b++)o[x]===1?f[p++]=l[x]:f[p++]=c[x];return t.makeTensorInfo(r.shape,d,f)}const ele={kernelName:tm,backendName:"cpu",kernelFunc:Joe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tle=xm,nle=bm,sle=qt(jh,n=>n>=0?nle*n:tle*(Math.exp(n)-1)),rle={kernelName:jh,backendName:"cpu",kernelFunc:sle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ile=qt(Kh,n=>n<0?-1:n>0?1:0),ale={kernelName:Kh,backendName:"cpu",kernelFunc:ile};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ole=qt(qh,n=>Math.sin(n)),lle={kernelName:qh,backendName:"cpu",kernelFunc:ole};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ule=qt(Xh,n=>Math.sinh(n)),cle={kernelName:Xh,backendName:"cpu",kernelFunc:ule};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hle=11920928955078125e-23,GT=Math.log(hle)+2,dle=qt(Qh,n=>{const e=n>-GT,t=n<GT,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),fle={kernelName:Qh,backendName:"cpu",kernelFunc:dle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ple(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;qe([r],"spaceToBatchND");const o=ue(i),l=[[0,0]];l.push(...a);for(let D=1+i.length;D<r.shape.length;++D)l.push([0,0]);const c=vF.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),d=$u(c.shape,i,o,!1),f=ku(d.length,i.length,!1),p=Nu(c.shape,i,o,!1),b=ln({inputs:{x:c},backend:t,attrs:{shape:d}}),$=ur({inputs:{x:b},backend:t,attrs:{perm:f}}),E=ln({inputs:{x:$},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo($),E}const mle={kernelName:rm,backendName:"cpu",kernelFunc:ple};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gle(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,d=t.data.get(a.dataId).values[0],[f,p,g,x,b]=U3(o,s.shape,s.dtype,l,r.dtype,c,d);return[t.makeTensorInfo(p,s.dtype,f),t.makeTensorInfo([p[0]],r.dtype,g),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(v=>Number(v)))),t.makeTensorInfo([b.length],s.dtype,new Int32Array(b))]}const yle={kernelName:$2,backendName:"cpu",kernelFunc:gle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xle(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.data.get(r.dataId).values),o=t.data.get(s.dataId).values,l=Array.from(t.data.get(i.dataId).values),[c,d,f]=W3(o,s.shape,s.dtype,a,l);return[t.makeTensorInfo(d,s.dtype,c),t.makeTensorInfo([f.length],i.dtype,new Int32Array(f))]}const ble={kernelName:k2,backendName:"cpu",kernelFunc:xle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vle(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[c,d]=AS(a,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(d,s.dtype,c)}const wle={kernelName:Yx,backendName:"cpu",kernelFunc:vle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sle(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[c,d]=AS(a,s.shape,s.dtype,o,l);return t.makeTensorInfo(d,s.dtype,c)}const Cle={kernelName:Qx,backendName:"cpu",kernelFunc:Sle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $le(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=va(i,r,o),g=!1,x=t.bufferSync(r);let b;switch(i.dtype){case"bool":{const v=t.bufferSync(i),w=!!t.data.get(a.dataId).values[0];b=Ql(x,v,o,p,d,c,l,f,w,g);break}case"float32":{const v=t.bufferSync(i),w=t.data.get(a.dataId).values[0];b=Ql(x,v,o,p,d,c,l,f,w,g);break}case"int32":{const v=t.bufferSync(i),w=t.data.get(a.dataId).values[0];b=Ql(x,v,o,p,d,c,l,f,w,g);break}case"string":{const v=t.bufferSync(i),w=Oi(t.data.get(a.dataId).values[0]);b=Ql(x,v,o,p,d,c,l,f,w,g);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(o,b.dtype,b.values)}const kle={kernelName:Zx,backendName:"cpu",kernelFunc:$le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=pt(a,r.shape)[0],l=Zb(r,i,o),c=new Array(r.shape.length).fill(0),d=r.shape.slice();return l.map(f=>{const p=[...d];p[o]=f;const g=gu({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[o]+=f,g})}const Ile={kernelName:im,backendName:"cpu",kernelFunc:Nle};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tle={kernelName:Jx,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;qe(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let o=0;o<r.length;++o){const l=r[o];i[o]=l*l}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ele=qt(rd,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),Rle={kernelName:rd,backendName:"cpu",kernelFunc:Ele};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ale(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=s;qe(r,"stridedSlice");const{finalShapeSparse:g,finalShape:x,isIdentity:b,sliceDim0:v,isSimpleSlice:w,begin:$,end:I,strides:N}=Fb(r.shape,i,a,o,l,c,d,f,p);let E;if(b)E=ln({inputs:{x:r},backend:t,attrs:{shape:x}});else if(v||w){B(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const D=Ob($,I,N),O=gu({inputs:{x:r},backend:t,attrs:{begin:$,size:D}});E=ln({inputs:{x:O},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(O)}else{const D=t.bufferSync(r),O=j3(g,D,N,$);E=t.makeTensorInfo(x,O.dtype,O.values)}return E}const Dle={kernelName:tb,backendName:"cpu",kernelFunc:Ale};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _le(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:d,dataSplits:f}=e,p=t.data.get(d.dataId).values,g=t.data.get(f.dataId).values,[x,b]=q3(p,g,r,i,a,o,l,c);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(f.shape,"int32",b)]}const Ole={kernelName:nb,backendName:"cpu",kernelFunc:_le};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fle(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values[0],[c,d,f]=X3(o,l,r),p=d.length;return[t.makeTensorInfo([p,2],"int32",c),t.makeTensorInfo([p],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const zle={kernelName:N2,backendName:"cpu",kernelFunc:Fle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lle(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(i.dataId).values,o=K3(a,r);return t.makeTensorInfo(i.shape,"int32",o)}const Ple={kernelName:I2,backendName:"cpu",kernelFunc:Lle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mle=qt(td,n=>Math.tan(n)),Ble={kernelName:td,backendName:"cpu",kernelFunc:Mle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vle=qt(nd,n=>Math.tanh(n)),Ule={kernelName:nd,backendName:"cpu",kernelFunc:Vle};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wle(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:a,numUpdates:o,sliceSize:l,strides:c,outputSize:d}=va(i,r,s.shape),f=!1,p=t.bufferSync(r),g=t.bufferSync(i),x=t.bufferSync(s),b=Ql(p,g,s.shape,d,l,o,a,c,x,f);return t.makeTensorInfo(s.shape,b.dtype,b.values)}const Gle={kernelName:Xx,backendName:"cpu",kernelFunc:Wle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;qe(r,"tile");const a=Q3(t.bufferSync(r),i);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const jle={kernelName:sd,backendName:"cpu",kernelFunc:Hle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s;qe(r,"topk");const o=t.data.get(r.dataId).values,[l,c]=J3(o,r.shape,r.dtype,i,a);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const Xle={kernelName:sb,backendName:"cpu",kernelFunc:qle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kle(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=t,[d,f,p,g]=r.shape,[x,b]=c??[f,p],v=[d,x,b,g],w=Ye(r.shape),$=w[0],I=w[1],N=w[2],E=Ye(v),D=E[0],O=E[1],L=E[2],z=es(r.dtype,ue(v));z.fill(l);const P=s.data.get(r.dataId).values,_=s.data.get(i.dataId).values;for(let q=0;q<d;++q){const ee=i.shape[0]===1?_:_.subarray(q*8,q*8+8);for(let Y=0;Y<x;++Y)for(let G=0;G<b;++G)for(let te=0;te<g;++te){let re;const he=ee[6]*G+ee[7]*Y+1;if(he===0)continue;const W=(ee[0]*G+ee[1]*Y+ee[2])/he,ne=(ee[3]*G+ee[4]*Y+ee[5])/he,pe=HT(W,p,o),de=HT(ne,f,o);switch(a){case"nearest":re=tue(P,f,p,$,I,N,q,de,pe,te,l);break;case"bilinear":re=nue(P,f,p,$,I,N,q,de,pe,te,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const we=q*D+Y*O+G*L+te;z[we]=re}return s.makeTensorInfo(v,r.dtype,z)}return{dataId:s.write(z,v,r.dtype),shape:r.shape,dtype:r.dtype}}const Yle={kernelName:rb,backendName:"cpu",kernelFunc:Kle};function HT(n,e,t){switch(t){case"reflect":return Qle(n,e);case"wrap":return Zle(n,e);case"nearest":return eue(n,e);case"constant":default:return Jle(n)}}function Qle(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return ru(0,t,e-1)}function Zle(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return ru(0,t,e-1)}function Jle(n,e){return n}function eue(n,e){return ru(0,n,e-1)}function Lf(n,e,t,s,r,i,a,o,l,c,d){const f=a*s+o*r+l*i+c;return 0<=o&&o<e&&0<=l&&l<t?n[f]:d}function tue(n,e,t,s,r,i,a,o,l,c,d){const f=Math.round(o),p=Math.round(l);return Lf(n,e,t,s,r,i,a,f,p,c,d)}function nue(n,e,t,s,r,i,a,o,l,c,d){const f=Math.floor(o),p=Math.floor(l),g=f+1,x=p+1,b=(x-l)*Lf(n,e,t,s,r,i,a,f,p,c,d)+(l-p)*Lf(n,e,t,s,r,i,a,f,x,c,d),v=(x-l)*Lf(n,e,t,s,r,i,a,g,p,c,d)+(l-p)*Lf(n,e,t,s,r,i,a,g,x,c,d);return(g-o)*b+(o-f)*v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sue(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;qe(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:c}=eD(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const rue={kernelName:T2,backendName:"cpu",kernelFunc:sue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iue(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,o=r.shape[i],l=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==i&&(l[c++]=r.shape[g]);const d=new Array(a).fill(0),f=r.shape.slice();f[i]=1;const p=new Array(o);for(let g=0;g<p.length;g++){d[i]=g;const x=gu({inputs:{x:r},backend:t,attrs:{begin:d,size:f}});p[g]=ln({inputs:{x},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(x)}return p}const aue={kernelName:om,backendName:"cpu",kernelFunc:iue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s;qe(r,"unsortedSegmentSum");const o=r.shape.length,l=i.shape.length,c=[],d=[],f=o-l;let p=i;for(let x=0;x<f;++x){const b=tx({inputs:{input:p},backend:t,attrs:{dim:x+1}});p=b,d.push(b)}for(let x=0;x<a;++x){const b=Jo(x,"int32"),v=t.makeTensorInfo([],"int32",b),w=m3({inputs:{a:v,b:p},backend:t}),$=qo({inputs:{x:w},backend:t,attrs:{dtype:"float32"}}),I=s0({inputs:{a:$,b:r},backend:t}),N=Em({inputs:{x:I},backend:t,attrs:{axis:0,keepDims:!1}});c.push(N),d.push(v),d.push(w),d.push($),d.push(I),d.push(N)}const g=bF({inputs:c,backend:t,attrs:{axis:0}});return d.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const lue={kernelName:lm,backendName:"cpu",kernelFunc:oue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uue=[sre,aq,ire,ore,dq,ure,hre,fre,mre,yre,bre,wre,Cre,Nre,Tre,Are,_re,Fre,Lre,tre,Mre,Vre,Wre,pq,Hre,cq,gq,qre,oq,Kre,Qre,Zre,eie,nie,rie,aie,lie,cie,die,pie,gie,xie,vie,Sie,Cie,kie,Iie,Eie,Rie,Aie,Die,Oie,Lie,Xse,Mie,yq,qie,xq,Xie,vq,eae,tae,sae,Sq,$q,iae,oae,uae,hae,Nq,Tq,lq,fae,Yre,mae,yae,bae,Kse,Rq,Dq,wae,Oq,Cae,Nae,Tae,Aae,_ae,Fae,zae,zq,Pae,Bae,Uae,Gae,jae,Xae,Yae,Pq,Zae,toe,roe,Bq,Uq,ooe,coe,foe,Gq,moe,yoe,xoe,vF,Soe,Qse,qq,$oe,Noe,Toe,Roe,uq,o2,Doe,Zse,Jse,ere,Ooe,zoe,Poe,Boe,Uoe,Woe,Hoe,t8,qoe,Zoe,ele,rle,s8,ale,lle,cle,r8,noe,fle,mle,yle,ble,wle,Cle,kle,Ile,o8,Tle,u8,h8,Rle,Dle,Ole,zle,Ple,m8,Fie,Ble,Ule,Gle,jle,Xle,Yle,Hq,rue,aue,lue,goe];for(const n of uue)E2(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kl={},iy={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function cue(n,e){Kl[n]=e}function Vi(n,e){if(!(n in Kl)||e!=null){const s=due(n,e);if(s!==null)Kl[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Kl[n];return t==null||t.isContextLost()?(delete Kl[n],Vi(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Kl[n])}function hue(n){if(!fe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function due(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??hue(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Kl[n]},!1),fe().getBool("SOFTWARE_WEBGL_ENABLED")&&(iy.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",iy)||t.getContext("experimental-webgl",iy):t.getContext("webgl2",iy)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ip;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(ip||(ip={}));var Vr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Vr||(Vr={}));var vs;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(vs||(vs={}));function Rm(n,e){return[e,n]}function fue(n,e){return n*e}function ay(n){const e=ue(n),t=Math.ceil(e/4);return dw(t)}function pd(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function pue(n,e){const[t,s]=pd(n,e);return t*s*4}function oC(n,e){const t=n;let s,r,i,a,o,l,c,d,f,p;return fe().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,a=t.RGBA32F,o=t.RED,c=4,d=1,f=t.HALF_FLOAT,p=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,a=t.RGBA,o=n.RGBA,c=4,d=4,f=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:f,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(n,e){const t=e();return fe().getBool("DEBUG")&&mue(n),t}function mue(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+bue(n,e))}const gue=596e-10,yue=65504;function xue(n){return!!(fe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||gue<Math.abs(n)&&Math.abs(n)<yue)}function bue(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function oy(n,e){return to(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function vue(n,e){const t=to(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(We(n,()=>n.shaderSource(t,e)),We(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function wue(n,e){const t=to(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(We(n,()=>n.shaderSource(t,e)),We(n,()=>n.compileShader(t)),fe().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw wF(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const Sue=/ERROR: [0-9]+:([0-9]+):/g;function wF(n,e){const t=Sue.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,a=r.map((f,p)=>Uc((p+1).toString(),i)+f);let o=0;for(let f=0;f<a.length;f++)o=Math.max(a[f].length,o);const l=a.slice(0,s-1),c=a.slice(s-1,s),d=a.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Uc(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function Cue(n){return to(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function $ue(n,e){if(We(n,()=>n.linkProgram(e)),!fe().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function aw(n,e){if(We(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function kue(n,e){const t=to(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return We(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),We(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Nue(n,e){const t=to(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return We(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),We(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Iue(n){return to(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Tue(n,e){const t=fe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Eue(n){return to(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function jT(n,e,t,s,r,i,a){const o=n.getAttribLocation(e,t);return o===-1?!1:(We(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),We(n,()=>n.vertexAttribPointer(o,r,n.FLOAT,!1,i,a)),We(n,()=>n.enableVertexAttribArray(o)),!0)}function Rue(n,e,t){Fue(n,t),We(n,()=>n.activeTexture(n.TEXTURE0+t)),We(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Aue(n,e,t){return to(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function Due(n,e,t){return n.getUniformLocation(e,t)}function _ue(n,e,t,s){We(n,()=>Rue(n,e,s)),We(n,()=>n.uniform1i(t,s))}function ow(n,e,t){We(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),We(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function qT(n,e){We(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),We(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function ly(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Oue(n,e))}function Oue(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function to(n,e,t){const s=We(n,()=>e());if(s==null)throw new Error(t);return s}function Fue(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function ih(n,e=2){return ue(n.slice(0,n.length-e))}function ah(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function uy(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[ih(n),...ah(n)]),e}function zue(n,e=!1){let t=fe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=fe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&fe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((o,l)=>l>=n.length-2?p2(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Zo(n).newShape);let r=ue(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const a=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||a)if(e){const o=ih(n);let l=2,c=2;n.length&&([l,c]=ah(n)),r=o*(l/2)*(c/2),i=dw(r).map(d=>d*2)}else i=dw(r);return i}function cy(n){return n%2===0}function sx(n,e){if(n=n.slice(-2),e=e.slice(-2),yt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||cy(t)&&cy(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&cy(n[0])&&cy(e[0])}let lw,uw;function Lue(n){if(lw==null){const e=Vi(n);lw=e.getParameter(e.MAX_TEXTURE_SIZE)}return lw}function Pue(n){if(uw==null){const e=Vi(n);uw=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,uw)}function Mue(n){if(n===0)return 0;let e;const t=Vi(n);return fi(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:fi(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function fi(n,e){return n.getExtension(e)!=null}function XT(n){try{if(Vi(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Bue(n){if(n===0)return!1;const e=Vi(n);if(n===1){if(!fi(e,"OES_texture_float"))return!1}else if(!fi(e,"EXT_color_buffer_float"))return!1;return u2(e)}function Vue(n){if(n===0)return!1;const e=Vi(n);if(n===1){if(!fi(e,"OES_texture_float")||!fi(e,"WEBGL_color_buffer_float"))return!1}else{if(fi(e,"EXT_color_buffer_float"))return u2(e);const s="EXT_color_buffer_half_float";if(fi(e,s)){const r=e.getExtension(s);return Uue(e,r)}return!1}return u2(e)}function u2(n){const e=oC(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),a}function Uue(n,e){const t=oC(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),o}function Wue(n){return n!==2?!1:Vi(n).fenceSync!=null}function Am(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&B(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ke=fe();Ke.registerFlag("HAS_WEBGL",()=>Ke.getNumber("WEBGL_VERSION")>0);Ke.registerFlag("WEBGL_VERSION",()=>XT(2)?2:XT(1)?1:0);Ke.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ke.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ke.get("WEBGL_VERSION")===2);Ke.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ke.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ke.registerFlag("WEBGL_PACK",()=>Ke.getBool("HAS_WEBGL"));Ke.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_CLIP",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_REDUCE",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_CONV_IM2COL",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Lue(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Pue(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Ke.getNumber("WEBGL_VERSION");return n===0?0:Mue(n)});Ke.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ke.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!LE());Ke.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Bue(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ke.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ke.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ke.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Vue(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Wue(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ke.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ke.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Ke.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>LE()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Ke.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ke.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ke.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ke.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ke.registerFlag("WEBGL_EXP_CONV",()=>!1);Ke.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ke.getBool("IS_TEST"));Ke.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ke.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ke.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ke.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(){let n,e,t,s,r,i,a,o,l,c;return fe().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o=fe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Du(n,e,t="index"){const s=Ye(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / ${r}`,o=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${a}; ${o};`}).join("")}function g0(n,e,t="index"){const s=Ye(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,o=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${a}; ${o};`}).join("")}function Gue(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function Hue(n,e,t="index"){const s=n.map((i,a)=>a),r=Gue(s,e);return r.map((i,a)=>{const o=`int ${n[a]} = ${t} / ${r[a]}`,l=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${o}; ${l};`}).join("")}function lC(n){const e=Ye(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function uC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const SF=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:CF}=NH;function jue(n,e,t){const s=[];if(n.forEach(g=>{const x=ue(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?s.push(`uniform float ${g.name}${x>1?`[${x}]`:""};`):(s.push(`uniform sampler2D ${g.name};`),s.push(`uniform int offset${g.name};`)),t.enableShapeUniforms){const{uniformShape:b}=cC(t.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(b.length){case 1:s.push(`uniform int ${g.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${g.name}Shape;`);break}s.push(`uniform ivec2 ${g.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(g=>{s.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(g=>que(g,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,o=Ks(),l=Yue(o);let c,d,f=Jue(o);return e.isPacked?(c=Xue(e.logicalShape,a,t.enableShapeUniforms),d=Zue(o)):(c=Kue(e.logicalShape,a,t.enableShapeUniforms),d=Que(o)),t.packedInputs&&(f+=sce),[f,l,d,r,c,i,t.userCode].join(`
`)}function md(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return mce(n,e);case 1:return yce(n,e);case 2:return bce(n,e);case 3:return wce(n,e);case 4:return Cce(n,e);case 5:return $ce(n);case 6:return kce(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function $F(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return pce(n);case 1:return gce(n,e);case 2:return xce(n,e);case 3:return vce(n,e);default:return Sce(n,e)}}function que(n,e,t=!1,s){let r="";t?r+=$F(n,s):r+=md(n,s);const i=n.shapeInfo.logicalShape,a=e.logicalShape;return i.length<=a.length&&(t?r+=Nce(n,e):r+=Ice(n,e)),r}function Xue(n,e,t){switch(n.length){case 0:return kF();case 1:return rce(n,e,t);case 2:return dce(n,e,t);case 3:return ace(n,e,t);default:return lce(n,e,t)}}function Kue(n,e,t){switch(n.length){case 0:return kF();case 1:return ice(n,e,t);case 2:return fce(n,e,t);case 3:return oce(n,e,t);case 4:return uce(n,e,t);case 5:return cce(n,e);case 6:return hce(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Yue(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Que(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Zue(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function Jue(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${ece}
    ${tce}
    ${nce}
  `}const ece=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,tce=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,nce=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,sce=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function kF(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function rce(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function ice(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function ace(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function oce(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${g0(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Du(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function lce(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let a=i,o="",l="b, r, c";for(let c=2;c<n.length-1;c++)a*=n[n.length-c-1],o=`
      int b${c} = index / ${a};
      index -= b${c} * ${a};
    `+o,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function uce(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${g0(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Du(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function cce(n,e){const t=Du(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function hce(n,e){const t=Du(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function dce(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(yt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function fce(n,e,t){return yt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function _u(n){return`offset${n}`}function pce(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ks();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function mce(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=_u(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[o,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function gce(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Ks();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function yce(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${gd(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],a=r[1];if(a===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=_u(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${a}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function xce(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=i[0],o=i[1],l=Ks();if(i!=null&&yt(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function bce(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&yt(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const p=i[0],g=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:o}=Zo(t),l=a;if(l.length<t.length){const p=yd(n,l),g=["row","col"];return`
      ${md(p,e)}
      float ${r}(int row, int col) {
        return ${r}(${xd(g,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${gd(n)}
      }
    `;const c=i[0],d=i[1],f=_u(s);return d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${f};
    vec2 uv = uvFromFlat(${c}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function vce(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const p=t.slice(1),g=[1,2],x=yd(n,p),b=["b","row","col"];return`
        ${$F(x,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${xd(b,g)});
        }
      `}const o=Ks();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const l=a[0],c=a[1],d=Math.ceil(t[2]/2),f=d*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${f}, ${d}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function wce(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],a=t[2],{newShape:o,keptDims:l}=Zo(t),c=o;if(c.length<t.length){const b=yd(n,c),v=["row","col","depth"];return`
        ${md(b,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${xd(v,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${a}, 1)));
        ${gd(n)}
      }
    `;const d=n.shapeInfo.texShape,f=d[0],p=d[1],g=n.shapeInfo.flatOffset;if(p===i&&g==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${f}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===a&&g==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `;const x=_u(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${x};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${a} + depth + ${x};
        vec2 uv = uvFromFlat(${f}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Sce(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Ks();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,a=i.length,o=n.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=l[0],d=l[1],f=Math.ceil(i[a-1]/2);let p=f*Math.ceil(i[a-2]/2),g="int b, int row, int col",x=`b * ${p} + (row / 2) * ${f} + (col / 2)`;for(let b=2;b<a-1;b++)g=`int b${b}, `+g,p*=i[a-b-1],x=`b${b} * ${p} + `+x;return`
    vec4 ${s}(${g}) {
      int index = ${x};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});
      return ${r.texture2D}(${t}, uv);
    }
  `}function Cce(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],a=t[2]*i,o=t[1]*a,{newShape:l,keptDims:c}=Zo(t);if(l.length<t.length){const $=yd(n,l),I=["row","col","depth","depth2"];return`
      ${md($,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${xd(I,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${i}, 1)));
        ${gd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,p=f[0],g=f[1],x=`int stride2 = ${s}Shape[3];`,b=`int stride1 = ${s}Shape[2] * stride2;`,v=`int stride0 = ${s}Shape[1] * stride1;`;if(g===o&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${x}
        ${b}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(g===i&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;const w=_u(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${x}
      ${b}
      ${v}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${w});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${p}, ${g}, index + ${w});
      return sampleTexture(${s}, uv);
    }
  `}function $ce(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,a=e[2]*i,o=e[1]*a,{newShape:l,keptDims:c}=Zo(e);if(l.length<e.length){const b=yd(n,l),v=["row","col","depth","depth2","depth3"];return`
      ${md(b)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${xd(v,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${i}, ${r})) +
          depth3;
        ${gd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,p=f[0],g=f[1];if(g===o&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=_u(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${i} +
          depth2 * ${r} + depth3 + ${x};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function kce(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=Zo(e);if(r.length<e.length){const v=yd(n,r),w=["row","col","depth","depth2","depth3","depth4"];return`
      ${md(v)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${xd(w,i)});
      }
    `}const a=e[5],o=e[4]*a,l=e[3]*o,c=e[2]*l,d=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${c}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${gd(n)}
      }
    `;const f=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,g=p[0],x=p[1];if(x===d&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(x===a&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;const b=_u(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${c} + depth * ${l} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${b};
      vec2 uv = uvFromFlat(${g}, ${x}, index);
      return sampleTexture(${t}, uv);
    }
  `}function gd(n){const e=n.name,t=ue(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Nce(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=CF(n.shapeInfo.logicalShape,e.logicalShape),l=Qt(a),c=a-i;let d;const f=["x","y","z","w","u","v"];i===0?d="":a<2&&o.length>=1?d="coords = 0;":d=o.map($=>`coords.${f[$+c]} = 0;`).join(`
`);let p="";a<2&&i>0?p="coords":p=n.shapeInfo.logicalShape.map(($,I)=>`coords.${f[I+c]}`).join(", ");let g="return outputValue;";const b=ue(n.shapeInfo.logicalShape)===1,w=ue(e.logicalShape)===1;if(i===1&&!b&&!w)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(b&&!w)a===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){const $=i-2,I=i-1;o.indexOf($)>-1&&o.indexOf(I)>-1?g="return vec4(outputValue.x);":o.indexOf($)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(I)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${p});
      ${g}
    }
  `}function Ice(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,a=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&o===l&&n.shapeInfo.flatOffset==null&&yt(a,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Qt(l),d=CF(n.shapeInfo.logicalShape,e.logicalShape),f=l-o;let p;const g=["x","y","z","w","u","v"];o===0?p="":l<2&&d.length>=1?p="coords = 0;":p=d.map(b=>`coords.${g[b+f]} = 0;`).join(`
`);let x="";return l<2&&o>0?x="coords":x=n.shapeInfo.logicalShape.map((b,v)=>`coords.${g[v+f]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${s}(${x});
    }
  `}function Qt(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function cC(n,e,t){const{newShape:s,keptDims:r}=Zo(e),i=e.length,a=n&&i===3&&e[0]===1,o=a?e.slice(1):s,l=!n&&i>1&&!yt(e,t)&&s.length<i||a;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:r}}function yd(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function xd(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tce(n,e,t,s){const r=t.map((d,f)=>{const p={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(p.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:p}}),i=r.map(d=>d.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=jue(r,a,e),l=wue(n.gl,o),c=n.createProgram(l);return fe().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:i,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:i,outShapeInfo:a},NF(n,e,c)))}function NF(n,e,t){const s=[],r=[];let i,a,o,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),fe().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(const f of e.variableNames){const p={name:f,uniform:n.getUniformLocation(t,f,d),offset:n.getUniformLocation(t,`offset${f}`,d)};e.enableShapeUniforms&&(p.shape=n.getUniformLocation(t,`${f}Shape`,d),p.texShape=n.getUniformLocation(t,`${f}TexShape`,d)),s.push(p)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",d),o=n.getUniformLocation(t,"outShapeStrides",d),a=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms)for(const f of e.customUniforms)r.push(n.getUniformLocation(t,f.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:a}}function KT(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],a=i.shape;if(!yt(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&i.isUniform)return;const o=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!yt(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function Ece(n,e,t,s,r){e.program.enableShapeUniforms||(KT(e.inShapeInfos,t),KT([e.outShapeInfo],[s]));const i=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):n.setOutputMatrixTexture(i.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),fe().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:d,offset:f,shape:p,texShape:g}=e.variablesLocations[l];if(p){const{uniformShape:x}=cC(e.program.packedInputs,c.shape,c.texData.texShape);switch(x.length){case 1:n.gl.uniform1iv(p,new Int32Array(x));break;case 2:n.gl.uniform2iv(p,new Int32Array(x));break;case 3:n.gl.uniform3iv(p,new Int32Array(x));break;case 4:n.gl.uniform4iv(p,new Int32Array(x));break}}if(g&&n.gl.uniform2i(g,c.texData.texShape[0],c.texData.texShape[1]),d!=null){if(c.isUniform){if(ue(c.shape)<2)n.gl.uniform1f(d,c.uniformValues[0]);else{let x=c.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),n.gl.uniform1fv(d,x)}continue}c.texData.slice!=null&&f!=null&&n.gl.uniform1i(f,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,d,l)}}const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=Ye(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],d=e.customUniformLocations[l],f=r[l];if(c.type==="float")n.gl.uniform1fv(d,f);else if(c.type==="vec2")n.gl.uniform2fv(d,f);else if(c.type==="vec3")n.gl.uniform3fv(d,f);else if(c.type==="vec4")n.gl.uniform4fv(d,f);else if(c.type==="int")n.gl.uniform1iv(d,f);else if(c.type==="ivec2")n.gl.uniform2iv(d,f);else if(c.type==="ivec3")n.gl.uniform3iv(d,f);else if(c.type==="ivec4")n.gl.uniform4iv(d,f);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function Rce(n,e,t){let s="";e.concat(t).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:f}=cC(n.packedInputs,a.shape,l);let p="",g="",x="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)g=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=Ye(d);x=`${E[0]===l[1]}_${E[E.length-1]===l[1]}`}const b=a.shape.length,v=d.length===2&&yt(a.shape,l),w=ue(a.shape)===1,$=Ho(a.shape,t.shape),I=!n.packedInputs&&b===t.shape.length&&yt(l,t.texData.texShape),N=n.packedInputs||d.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${b}_${I}_${c?f:""}_${d.length}_${w}_${$}_${v}_${p}_${g}_${x}_${N}_${o}`}else{const l=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${l}_${o}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${fe().getNumber("WEBGL_VERSION")}`,i}function _s(n){return fe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ace{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ip.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ks();this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?g0(["r","c","d"],e):Du(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ip.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ks();this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?g0(["r","c","d"],e):Du(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ce{constructor(e){this.variableNames=["A"],this.outTexUsage=Vr.DOWNLOAD;const t=Ks();this.outputShape=e,this.userCode=`
      ${SF}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Vr.DOWNLOAD;const t=Ks();this.outputShape=e,this.userCode=`
      ${SF}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fce={R:0,G:1,B:2,A:3};class YT{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ks();this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let a="";for(let o=0;o<s.length;o++){const l=s[o];a+=`
          if(offset == ${o}) {
            result = values[${Fce[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?uC():lC(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zce{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ks();this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const l=a*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?uC():lC(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lce(n){const e=Ks(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return vue(n,t)}function Pce(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return kue(n,e)}function Mce(n){const e=new Uint16Array([0,1,2,2,1,3]);return Nue(n,e)}function Dm(n,e,t,s,r,i){Tue(e,t);const a=Iue(n),o=n.TEXTURE_2D;return We(n,()=>n.bindTexture(o,a)),We(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),We(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),We(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),We(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),fe().getNumber("WEBGL_VERSION")===1?We(n,()=>n.texImage2D(o,0,s,e,t,0,r,i,null)):We(n,()=>n.texStorage2D(o,1,s,e,t)),We(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function IF(n){return n.internalFormatFloat}function Bce(n,e,t,s){const[r,i]=Rm(e,t);return Dm(n,r,i,IF(s),s.textureFormatFloat,n.FLOAT)}function TF(n){return n.internalFormatHalfFloat}function Vce(n,e,t,s){const[r,i]=Rm(e,t);return Dm(n,r,i,TF(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function EF(n){return n.downloadTextureFormat}function Uce(n,e,t,s){const[r,i]=Rm(e,t);return Dm(n,r,i,EF(s),n.RGBA,n.UNSIGNED_BYTE)}function RF(n){return n.internalFormatPackedFloat}function Wce(n,e,t,s){const[r,i]=pd(e,t);return Dm(n,r,i,RF(s),n.RGBA,n.FLOAT)}function AF(n){return n.internalFormatPackedHalfFloat}function Gce(n,e,t,s){const[r,i]=pd(e,t);return Dm(n,r,i,AF(s),n.RGBA,s.textureTypeHalfFloat)}function Hce(n,e,t){return We(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),jT(n,e,"clipSpacePos",t,3,20,0)&&jT(n,e,"uv",t,2,20,12)}function jce(n,e,t,s,r,i){We(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,o,l;r instanceof Uint8Array?(a=new Uint8Array(t*s*4),o=n.UNSIGNED_BYTE,l=n.RGBA):(a=new Float32Array(t*s*4),o=n.FLOAT,l=i.internalFormatPackedFloat),a.set(r),fe().getNumber("WEBGL_VERSION")===2?We(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,o,a)):We(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,o,a)),We(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function qce(n,e,t){We(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?fe().getNumber("WEBGL_VERSION")===2?We(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):We(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):fe().getNumber("WEBGL_VERSION")===2?We(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):We(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),We(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Xce(n,e,t,s){const r=n.createBuffer();We(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const o=4*4*e*t;return We(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),We(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),We(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function Kce(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function Yce(n,e,t,s){const[r,i]=Rm(e,t),a=4,o=new Uint8Array(fue(e*t,a));return We(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function Qce(n,e,t,s,r,i,a,o){const l=n,c=new Float32Array(pue(i,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function Zce(n,e,t){const s=new Float32Array(e*t*4);return We(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cw{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=fe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,cue(t,e)):this.gl=Vi(t),e=this.gl,fe().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>We(i,()=>i.createVertexArray()),this.bindVertexArray=a=>We(i,()=>i.bindVertexArray(a)),this.deleteVertexArray=a=>We(i,()=>i.deleteVertexArray(a)),this.getVertexArray=()=>We(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>We(e,()=>i.createVertexArrayOES()),this.bindVertexArray=a=>We(e,()=>i.bindVertexArrayOES(a)),this.deleteVertexArray=a=>We(e,()=>i.deleteVertexArrayOES(a)),this.getVertexArray=()=>We(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),fe().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=oy(this.gl,i),fi(this.gl,a))this.textureHalfFloatExtension=oy(this.gl,a);else if(fe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),fi(this.gl,r))this.colorBufferHalfFloatExtension=oy(this.gl,r);else if(fe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",fi(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(fi(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Pce(this.gl),this.indexBuffer=Mce(this.gl),this.framebuffer=Eue(this.gl),this.textureConfig=oC(this.gl,this.textureHalfFloatExtension)}get debug(){return fe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;We(e,()=>e.finish()),We(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),We(e,()=>e.deleteFramebuffer(this.framebuffer)),We(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),We(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),We(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Bce(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Vce(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Uce(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),qce(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),jce(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Gce(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Wce(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(qT(this.gl,this.framebuffer),this.outputTexture=null),We(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Yce(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,a){return Qce(this.gl,e,t,s,r,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Kce(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=Xce(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(fe().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(i,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=i}else fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Zce(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=Lce(t));const s=Cue(t);We(t,()=>t.attachShader(s,this.vertexShader)),We(t,()=>t.attachShader(s,e)),$ue(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&aw(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;We(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Hce(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(We(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&aw(this.gl,this.program),We(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?Aue(this.gl,e,t):Due(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),We(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),_ue(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=pd(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&aw(this.gl,this.program),ly(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}We(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),We(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=oy(this.gl,fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await FN(()=>this.disposed||this.isQueryAvailable(e,fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=Jce(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in fe().platform&&(s=fe().platform.setTimeoutCustom.bind(fe().platform)),FN(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),ow(this.gl,e,this.framebuffer),this.debug&&ly(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(ow(this.gl,this.outputTexture,this.framebuffer),this.debug&&ly(this.gl)):qT(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;ow(r,e,this.framebuffer),this.debug&&ly(r),this.outputTexture=e,We(r,()=>r.viewport(0,0,t,s)),We(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),We(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Jce(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:ehe,bincountImpl:DF,bincountReduceImpl:the,bitwiseAndImpl:nhe,castImpl:she,ceilImpl:rhe,concatImpl:ihe,equalImpl:ahe,expImpl:ohe,expm1Impl:lhe,floorImpl:uhe,gatherNdImpl:che,gatherV2Impl:hhe,greaterImpl:dhe,greaterEqualImpl:fhe,lessImpl:phe,lessEqualImpl:mhe,linSpaceImpl:ghe,logImpl:yhe,maxImpl:xhe,maximumImpl:bhe,minimumImpl:vhe,multiplyImpl:whe,negImpl:She,notEqualImpl:Che,prodImpl:$he,raggedGatherImpl:khe,raggedRangeImpl:Nhe,raggedTensorToTensorImpl:Ihe,rangeImpl:The,rsqrtImpl:Ehe,scatterImpl:Rhe,sigmoidImpl:Ahe,simpleAbsImpl:_F,sliceImpl:Dhe,sparseFillEmptyRowsImpl:_he,sparseReshapeImpl:Ohe,sparseSegmentReductionImpl:OF,sqrtImpl:Fhe,staticRegexReplaceImpl:zhe,stridedSliceImpl:Lhe,stringNGramsImpl:Phe,stringSplitImpl:Mhe,stringToHashBucketFastImpl:Bhe,subImpl:Vhe,tileImpl:Uhe,topKImpl:Whe,transposeImpl:hC,uniqueImpl:Ghe}=tD;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Gs(n,e){return e===1?[n]:FF(n,e)}function Hhe(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jhe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=_s(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Gs("rc",this.rank),s=Qt(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)i=`${e[e.length-1-a]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${qhe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?uC():lC(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function qhe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Hue(["r","c","d"],"inputShape"):Du(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xhe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=ZT(t,s),i=JT(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const a=QT(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let o;return r===vs.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===vs.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===vs.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===vs.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===vs.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=ZT(s,r),a=JT(t,i,r);a in this.freeTextures||(this.freeTextures[a]=[]);const o=QT(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=fe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[a],d=c&&c.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Khe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function QT(n,e,t,s,r){const i=Yhe(e,s);let a;if(r){const[l,c]=pd(n[0],n[1]);a=l*c}else{const[l,c]=Rm(n[0],n[1]);a=l*c}const o=Khe(t,i);return a*o}function Yhe(n,e){switch(n){case vs.PACKED_2X2_FLOAT32:return RF(e);case vs.PACKED_2X2_FLOAT16:return AF(e);case vs.UNPACKED_FLOAT32:return IF(e);case vs.UNPACKED_FLOAT16:return TF(e);case vs.PACKED_4X1_UNSIGNED_BYTE:return EF(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function Qhe(n){return fe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?vs.PACKED_2X2_FLOAT32:vs.UNPACKED_FLOAT32:n?vs.PACKED_2X2_FLOAT16:vs.UNPACKED_FLOAT16}function ZT(n,e){if(n===Vr.UPLOAD)return vs.PACKED_2X2_FLOAT32;if(n===Vr.RENDER||n==null)return Qhe(e);if(n===Vr.DOWNLOAD||n===Vr.PIXELS)return vs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function JT(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class la{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const wi="if (isnan(x)) return x;",Zhe="return x;",eE="return abs(x);",Jhe="return (x >= 0.0) ? x : (exp(x) - 1.0);",ede=wi+`
  return (x < 0.0) ? 0.0 : x;
`,tde=wi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_o="return x;",nde="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sde="return x;",rde=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ide=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ade=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ode="return 1.0 / (1.0 + exp(-1.0 * x));";class Lo{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lde{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);const t=e.length,s=Gs("rc",t),r=Qt(t),i=Hhe(t,s),a=s.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ude=cS,cde=1e-7,hde=1e-4,hy={};function dde(n){return n in hy||(hy[n]={}),hy[n]}const fde=fe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),pde=600;function mde(){return fe().global.screen==null?1024:fe().global.screen.height*fe().global.screen.width*window.devicePixelRatio*pde/1024/1024}class y0 extends lx{nextDataId(){return y0.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!fe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof cw)t=e;else{const s=Vi(fe().getNumber("WEBGL_VERSION"),e);t=new cw(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Vi(fe().getNumber("WEBGL_VERSION"));t=new cw(s),this.binaryCache=dde(fe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Xhe(this.gpgpu),this.numMBBeforeWarning=mde(),this.texData=new f2(this,Vs())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,a){const o=this.makeTensorInfo(t,s),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,i]},l.texShape=[r,i];const c=uy(t),d=new YT(c,!1,a),f=this.runWebGLProgram(d,[o],s,[[r,i]]);return f.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(o),f.dataId}write(e,t,s){if((fe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||fe().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:Vr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(fe().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:Vr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:a,shape:o,isPacked:l}=t;if(a!=null){let p;l?p=new Lo(o,_o):p=new la(o,_o);const g=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:r}],r),x=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const c=this.activeTimers!=null;let d;c&&(d=nr());let f;if(r==="complex64"){const p=this.readSync(i.real.dataId),g=this.readSync(i.imag.dataId);f=Li(p,g)}else f=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=nr()-d),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const x=this.pendingRead.get(e);return new Promise(b=>x.push(b))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:a,complexTensorInfos:o,isPacked:l}=t;if(i!=null){let x;l?x=new Lo(r,_o):x=new la(r,_o);const b=this.runWebGLProgram(x,[{dataId:e,shape:r,dtype:a}],a),v=this.read(b.dataId);return this.disposeIntermediateTensorInfo(b),v}if(s!=null)return this.convertAndCacheOnCPU(e);if(fe().getBool("DEBUG")&&!fe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&fe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,d;if(a!=="complex64"&&fe().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const x=this.texData.get(d.dataId);c=this.gpgpu.createBufferFromTexture(x.texture.texture,...ay(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(a==="complex64"){const x=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),b=x[0],v=x[1];f=Li(b,v)}else if(c==null)f=this.getValuesFromTexture(e);else{const x=ue(r);f=this.gpgpu.downloadFloat32MatrixFromBuffer(c,x)}if(d!=null&&this.disposeIntermediateTensorInfo(d),c!=null){const x=this.gpgpu.gl;We(x,()=>x.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,f),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(x=>x(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Vs().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:a,dtype:o,isPacked:l,texture:c}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let g;l?g=new Lo(i,_o):g=new la(i,_o);const x=this.runWebGLProgram(g,[{dataId:e,shape:i,dtype:o}],o),b=this.readToGPU(x,t);return this.disposeIntermediateTensorInfo(x),b}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),f=Vs().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:f},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Oi(r));return ft(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ft(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!xue(s))throw fe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=ue(t);if(fe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),g=this.texData.get(p.dataId),x=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...ay(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(p),x}const a=fe().getBool("WEBGL_PACK")&&r===!0,o=a?uy(t):t,l=a?new Oce(o):new _ce(o),c=this.runWebGLProgram(l,[{shape:o,dtype:s,dataId:e}],"float32"),d=this.texData.get(c.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),f}timerAvailable(){return fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Ka(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=Ka(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);o.kernelMs=vE(l),o.getExtraProfileInfo=()=>l.map((c,d)=>({name:a[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:nr(),endMs:null}}endTimer(e){return fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=nr(),e)}async getQueryTime(e){if(fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:a,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=fde){return fe().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&ue(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Br("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return ude(e.shape,t)}packedUnaryOp(e,t,s){const r=new Lo(e.shape,t),i=this.compileAndRun(r,[e],s);return Vs().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=_F(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(fe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,eE,e.dtype);const t=new la(e.shape,eE),s=this.compileAndRun(t,[e]);return Vs().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&lh(s[0])){const i=s.map(a=>Ha(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return Vs().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new lde(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new jhe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[ih(e.shape),...ah(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[ih(t),...ah(t)],a=new zF(i,s),o=!0,l=[s],c=this.runWebGLProgram(a,[r],e.dtype,l,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:a}=s;if(t!=null){const p=ue(i),g=t[0]*t[1]*4;B(p<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=uy(i);let l;r?l=new Dce(o):l=new Ace(o);const c=!0,d=[t??ay(o)],f=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:e}],a,d,c,t);return{dtype:a,shape:i,dataId:f.dataId}}runWebGLProgram(e,t,s,r,i=!1,a){const o=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===ip.DENSE){const w=a??ay(e.outputShape);l.texShape=w.map($=>$*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),ue(o.shape)===0)return l.values=es(o.dtype,0),o;const c=[],d=t.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let $=this.texData.get(w.dataId);if($.texture==null){if(!e.packedInputs&&ue(w.shape)<=fe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:$.values};e.packedInputs&&($.isPacked=!0,$.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!$.isPacked!=!!e.packedInputs)w=$.isPacked?this.unpackTensor(w):this.packTensor(w),c.push(w),$=this.texData.get(w.dataId);else if($.isPacked&&!sx($.shape,w.shape)){const I=w,N=w.shape;w.shape=$.shape,w=this.packedReshape(w,N),c.push(w),$=this.texData.get(w.dataId),I.shape=N}return{shape:w.shape,texData:$,isUniform:!1}});this.uploadToGPU(o.dataId);const f={shape:o.shape,texData:l,isUniform:!1},p=Rce(e,d,f),g=this.getAndSaveBinary(p,()=>Tce(this.gpgpu,e,d,f)),x=this.activeTimers!=null;let b;x&&(b=this.startTimer()),fe().get("ENGINE_COMPILE_ONLY")||Ece(this.gpgpu,g,d,f,r),c.forEach(w=>this.disposeIntermediateTensorInfo(w)),x&&(b=this.endTimer(b),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(b)}));const v=fe().getNumber("WEBGL_FLUSH_THRESHOLD");if(v>0){const w=nr();w-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!fe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const w=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),w}return o}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(fe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ce(()=>{if(!fe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=fe().getBool("DEBUG");fe().set("DEBUG",!1);const t=this.abs(Qe(1e-8)).dataSync()[0];if(fe().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?cde:hde}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:a,usage:o,isPacked:l}=t;if(a!=null)return;const c=this.activeTimers!=null;let d;c&&(d=nr());let f=t.texShape;if(f==null&&(f=zue(s,l),t.texShape=f),i!=null){const p=uy(s);let g,x=f[1],b=f[0];const v=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!v)&&([x,b]=pd(f[0],f[1])),l?g=new zce(p,v):g=new YT(p,v);const w=v?[b,x]:f,$=this.makeTensorInfo(w,r),I=this.texData.get($.dataId);v?I.usage=Vr.PIXELS:I.usage=Vr.UPLOAD,I.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture($.dataId),x,b,i);const N=[[b,x]],D=this.runWebGLProgram(g,[$],r,N,!0),O=this.texData.get(D.dataId);t.texShape=O.texShape,t.isPacked=O.isPacked,t.usage=O.usage,fe().get("ENGINE_COMPILE_ONLY")?this.disposeData(D.dataId):(t.texture=O.texture,t.values=null,this.texData.delete(D.dataId)),this.disposeIntermediateTensorInfo($),c&&(this.uploadWaitMs+=nr()-d)}else{const p=this.acquireTexture(f,o,r,l);t.texture=p}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=gde(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Iy(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await TA(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(wF(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:l}=NF(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:a,channels:o}=e,l=Vs().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(r,t,s,i,a,o);return Vs().makeTensorFromDataId(c,t,s,l)}}y0.nextDataId=0;function gde(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */PE()&&R2("webgl",()=>new y0,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class xu{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=tt(t,s),this.enableShapeUniforms=_s(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ou=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class bd{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=tt(t,s);const i=this.outputShape.length;this.enableShapeUniforms=_s(i);let a="";if(r)if(i===0||ue(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Qt(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Gs("coords",i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const yde={kernelName:Rh,backendName:"webgl",kernelFunc:Ir};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ll(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(i.dataId),o=Ir({inputs:{x:s},backend:t}),l=Ir({inputs:{x:r},backend:t});return a.complexTensorInfos={real:o,imag:l},i}const xde={kernelName:gx,backendName:"webgl",kernelFunc:ll};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF="return (a < 0.) ? b * a : a;",PF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function bde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,a=t.makeTensorInfo([],"float32",Jo(i,"float32")),o=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bd(PF,r.shape,a.shape):new xu(LF,r.shape,a.shape),l=t.runWebGLProgram(o,[r,a],"float32");return t.disposeIntermediateTensorInfo(a),l}const vde={kernelName:Rp,backendName:"webgl",kernelFunc:bde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MF="return (a < 0.) ? b * a : a;",BF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function wde(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bd(BF,s.shape,r.shape):new xu(MF,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const Sde={kernelName:Kp,backendName:"webgl",kernelFunc:wde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vd="if (isnan(x)) return x;";function Ft({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,o=i,l=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&t!=null){const f=o.texData.get(a.dataId),p=t(f.values,l);return o.makeTensorInfo(a.shape,l,p)}const c=fe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return c?d=new Lo(a.shape,e):d=new la(a.shape,n),o.runWebGLProgram(d,[a],l)}}function $s({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:o})=>{const{a:l,b:c}=a,d=o;if(s&&l.dtype==="complex64"){const x=d.texData.get(l.dataId),b=d.texData.get(c.dataId),[v,w]=[[x.complexTensorInfos.real,b.complexTensorInfos.real],[x.complexTensorInfos.imag,b.complexTensorInfos.imag]].map(I=>{const[N,E]=I,D={dataId:N.dataId,dtype:N.dtype,shape:l.shape},O={dataId:E.dataId,dtype:E.dtype,shape:c.shape},L=new xu(n,l.shape,c.shape);return d.runWebGLProgram(L,[D,O],ds(N.dtype,E.dtype))}),$=ll({inputs:{real:v,imag:w},backend:d});return d.disposeIntermediateTensorInfo(v),d.disposeIntermediateTensorInfo(w),$}const f=i||ds(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||d.shouldExecuteOnCPU([l,c]))&&r!=null){const x=d.texData.get(l.dataId).values,b=d.texData.get(c.dataId).values,v=l.dtype==="string"?Pi(x):x,w=l.dtype==="string"?Pi(b):b,[$,I]=r(l.shape,c.shape,v,w,f),N=d.makeTensorInfo(I,f),E=d.texData.get(N.dataId);return E.values=$,N}const p=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return p?g=new bd(e,l.shape,c.shape,t):g=new xu(n,l.shape,c.shape),d.runWebGLProgram(g,[l,c],f)}}function ap(n,e=!1){if(n==="linear")return e?sde:Zhe;if(n==="relu")return e?ide:ede;if(n==="elu")return e?rde:Jhe;if(n==="relu6")return e?ade:tde;if(n==="prelu")return e?BF:MF;if(n==="leakyrelu")return e?PF:LF;if(n==="sigmoid")return e?ode:nde;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VF{constructor(e,t,s,r=!1,i=!1,a=!1,o=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=_s(this.outputShape.length);const d=r?e[1]:e[2],f=Math.ceil(d/2),p=r?"i * 2, rc.y":"rc.y, i * 2",g=i?"rc.z, i * 2":"i * 2, rc.z",x=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],b=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let v="",w="";o&&(l?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:c?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:v=`vec4 activation(vec4 x) {
          ${o}
        }`,w="result = activation(result);");const $=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let I="rc.x",N="rc.x";e[0]<t[0]?I=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(N=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${I};
        int batchB = ${N};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${x[0]} * ${b[0]});
          result += (${x[1]} * ${b[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${$}

        ${w}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tE={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class nE{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=tt(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sE="return a * b;";function fC(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=ds(s.dtype,r.dtype);if(s.dtype==="complex64"){const o=t.texData.get(s.dataId),l=t.texData.get(r.dataId),c=new nE(tE.REAL,s.shape,r.shape),d=new nE(tE.IMAG,s.shape,r.shape),f=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],p=t.runWebGLProgram(c,f,"float32"),g=t.runWebGLProgram(d,f,"float32"),x=ll({inputs:{real:p,imag:g},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),x}if(t.shouldExecuteOnCPU([s,r])){const o=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[c,d]=whe(s.shape,r.shape,o.values,l.values,i),f=t.makeTensorInfo(d,i),p=t.texData.get(f.dataId);return p.values=c,f}let a;return fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new bd(sE,s.shape,r.shape):a=new xu(sE,s.shape,r.shape),t.runWebGLProgram(a,[s,r],i)}const Cde={kernelName:Mh,backendName:"webgl",kernelFunc:fC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $de(n,e,t){const s=[ih(n.shape),...ah(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[ih(e),...ah(e)],a=new zF(i,s),o=!0,l=[s],c=t.runWebGLProgram(a,[r],n.dtype,l,o);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ze(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=t,o=ue(r.shape),l=m2(i,o),c=ue(l);B(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const d=a.texData.get(r.dataId);return d.isPacked&&!sx(r.shape,l)&&!(d.texture!==null&&sx(d.shape,l))?$de(r,l,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const kde={kernelName:Qp,backendName:"webgl",kernelFunc:ze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rE{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];const o=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const f=1/t;c=`sumValue += dot(values * ${Xc(f)?f.toPrecision(2):f}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nde{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];let o="0.0",l="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",l="min"):t==="max"&&(o="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const d=Math.floor(s/4)*4,f=s%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";t==="all"?(o="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):t==="any"&&(o="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let x="";i%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${x}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ide(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=Lb(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Fu(n,e,t,s){const r=Ide(n.shape);let i=n;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:l,outSize:c}=r[a];let d,f;t==="mean"?d=a===0?new rE({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c},o):new rE({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c}):d=new Nde({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c},t),f=i,i=s.runWebGLProgram(d,[i],e),f.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(f)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tde{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const r=Qt(this.rank),i=Ede(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Ede(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rde{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[t[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Qt(this.rank),i=FF("rc",this.rank),a=new Array(this.rank);for(let d=0;d<t.length;d++)a[t[d]]=i[d];const o=`vec2(${a.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0(n,e,t){const s=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rde(n.shape,e):new Tde(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ade(n,e,t,s){const r=e,i=n.shape.length,a=pt(r,n.shape);let o=a;const l=Zt(o,i),c=l!=null;let d=n;c&&(d=x0(n,l,s),o=cn(o.length,i)),Gn("sum",o,i);const[f,p]=On(d.shape,o);let g=f;t&&(g=In(f,a));const x=ue(p),v=ue(n.shape)/x,w=ze({inputs:{x:d},attrs:{shape:[v,x]},backend:s}),$=ob(n.dtype),I=Fu(w,$,"sum",s),N=ze({inputs:{x:I},attrs:{shape:g},backend:s});return s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(I),c&&s.disposeIntermediateTensorInfo(d),N}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return Ade(r,i,a,t)}const Dde={kernelName:sm,backendName:"webgl",kernelFunc:b0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qs(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,a=t,o=r.shape.length,l=new Array(o);for(let d=0;d<l.length;d++)l[d]=r.shape[i[d]];let c;if(a.shouldExecuteOnCPU([r])){const f=a.texData.get(r.dataId).values,p=hC(f,r.shape,r.dtype,i,l);c=a.makeTensorInfo(l,r.dtype);const g=a.texData.get(c.dataId);g.values=p}else c=x0(r,i,a);return c}const _de={kernelName:Jl,backendName:"webgl",kernelFunc:qs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UF=1e3;function rx({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape.length,d=e.shape.length,f=t?n.shape[c-2]:n.shape[c-1],p=s?e.shape[d-1]:e.shape[d-2],g=t?n.shape[c-1]:n.shape[c-2],x=s?e.shape[d-2]:e.shape[d-1],b=n.shape.slice(0,-2),v=e.shape.slice(0,-2),w=ue(b),$=ue(v),N=tt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,x]);B(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[w,f,g]:[w,g,f],D=s?[$,x,p]:[$,p,x],O=ze({inputs:{x:n},backend:r,attrs:{shape:E}}),L=ze({inputs:{x:e},backend:r,attrs:{shape:D}}),z=[O,L],P=Math.max(w,$),_=t?O.shape[1]:O.shape[2],H=i!=null,q=a!=null,ee=l==="leakyrelu",Y=l!=null?ap(l,!0):null,G=H||q||ee||Y!=null;let te;if((g===1||x===1)&&_>UF&&G===!1){let he=O,W=L;t&&(he=qs({inputs:{x:O},backend:r,attrs:{perm:[0,2,1]}}),z.push(he)),s&&(W=qs({inputs:{x:L},backend:r,attrs:{perm:[0,2,1]}}),z.push(W));const ne=x!==1,pe=x===1;let de=he;ne&&(de=ze({inputs:{x:he},backend:r,attrs:{shape:[P,_,1]}}),z.push(de));const we=x===1?2:1;let ke=W;pe&&(ke=ze({inputs:{x:W},backend:r,attrs:{shape:[P,1,_]}}),z.push(ke));const Ne=fC({inputs:{a:de,b:ke},backend:r});te=b0({inputs:{x:Ne},backend:r,attrs:{axis:we,keepDims:!0}}),z.push(Ne)}else{const he=ds(n.dtype,e.dtype),W=new VF(E,D,[P,g,x],t,s,H,Y,q,ee),ne=[O,L];if(i!=null&&ne.push(i),q&&ne.push(a),ee){const pe=r.makeTensorInfo([],"float32",Jo(o,"float32"));ne.push(pe),z.push(pe)}te=r.runWebGLProgram(W,ne,he)}const re=ze({inputs:{x:te},backend:r,attrs:{shape:N}});z.push(te);for(const he of z)r.disposeIntermediateTensorInfo(he);return re}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ode(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=s;return rx({a:r,b:i,transposeA:l,transposeB:c,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:f,activation:d})}const Fde={kernelName:Vf,backendName:"webgl",kernelFunc:Ode};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iE="return abs(x);";function zde(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),a=_F(i.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let r;return fe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Lo(s.shape,iE):r=new la(s.shape,iE),t.runWebGLProgram(r,[s],s.dtype)}const Lde={kernelName:up,backendName:"webgl",kernelFunc:zde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pde=wi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Mde=Ft({opSnippet:Pde}),Bde={kernelName:ch,backendName:"webgl",kernelFunc:Mde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vde=wi+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Ude=Ft({opSnippet:Vde}),Wde={kernelName:hh,backendName:"webgl",kernelFunc:Ude};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aE="return a + b;",Gde=$s({opSnippet:aE,packedOpSnippet:aE,supportsComplex:!0,cpuKernelImpl:ehe}),Hde={kernelName:vu,backendName:"webgl",kernelFunc:Gde};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jde{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qde{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ny(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Ir({inputs:{x:s[0]},backend:t});if(s.length>fe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=Ny({inputs:s.slice(0,l),backend:t}),d=Ny({inputs:s.slice(l),backend:t});return Ny({inputs:[c,d],backend:t})}const r=s.map(l=>l.dtype).reduce((l,c)=>ds(l,c)),i=s.map(l=>l.shape),o=fe().getBool("WEBGL_PACK")?new qde(s[0].shape,i):new jde(s[0].shape,i);return t.runWebGLProgram(o,s,r)}const Xde={kernelName:cp,backendName:"webgl",kernelFunc:Ny};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=pt(i,r.shape);let c=l;const d=Zt(c,o);let f=r;d!=null&&(f=qs({inputs:{x:r},backend:t,attrs:{perm:d}}),c=cn(c.length,o)),Gn("all",c,o);const[p,g]=On(f.shape,c),x=ue(g),b=ze({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),v=Fu(b,b.dtype,"all",t);let w;if(a){const $=In(p,l);w=ze({inputs:{x:v},backend:t,attrs:{shape:$}})}else w=ze({inputs:{x:v},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),d!=null&&t.disposeIntermediateTensorInfo(f),w}const Yde={kernelName:ux,backendName:"webgl",kernelFunc:Kde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=pt(i,r.shape);let c=l;const d=Zt(c,o);let f=r;d!=null&&(f=qs({inputs:{x:r},backend:t,attrs:{perm:d}}),c=cn(c.length,o)),Gn("any",c,o);const[p,g]=On(f.shape,c),x=ue(g),b=ze({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),v=Fu(b,b.dtype,"any",t);let w;if(a){const $=In(p,l);w=ze({inputs:{x:v},backend:t,attrs:{shape:$}})}else w=ze({inputs:{x:v},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),d!=null&&t.disposeIntermediateTensorInfo(f),w}const Zde={kernelName:cx,backendName:"webgl",kernelFunc:Qde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jde{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const o=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class efe{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,B(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],a=Math.ceil(i/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,c=Qt(l),d=Gs("coords",l);let f,p;if(a===1){p=l+1;const L=Qt(p);f=`
        ${L} sourceLocR = ${L}(${d.join()}, 0);
        ++${d[l-1]};
        ${L} sourceLocG = ${L}(${d.join()}, 0);
        ++${d[l-2]};
        ${L} sourceLocA = ${L}(${d.join()}, 0);
        --${d[l-1]};
        ${L} sourceLocB = ${L}(${d.join()}, 0);
        --${d[l-2]};`}else p=l,f=`
        ${c} sourceLocR = coords;
        ++${d[l-1]};
        ${c} sourceLocG = coords;
        ++${d[l-2]};
        ${c} sourceLocA = coords;
        --${d[l-1]};
        ${c} sourceLocB = coords;
        --${d[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,p),x="."+g[p-1],b=g.map(L=>"int "+L),v=Gs("sourceLocR",p-1).concat("inIdx.r"),w=Gs("sourceLocG",p-1).concat("inIdx.g"),$=Gs("sourceLocB",p-1).concat("inIdx.b"),I=Gs("sourceLocA",p-1).concat("inIdx.a"),N=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${$.join()}),
                             getBestIndicesAChannel(${I.join()})));`,D=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${w.join()}) : 0.,
            hasNextRow ? getAChannel(${$.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${I.join()}) : 0.)`,O=r?"":`
      float getBestIndicesAChannel(${b.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${b.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${O}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${d[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${d[l-2]} < ${o[l-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${x}, sourceLocG${x},
          sourceLocB${x}, sourceLocA${x}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${D};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${D};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${N}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WF(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const a=Lb(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},l=new Jde(o,t,s==null),c=[e];s!=null&&c.push(s);const d=n.runWebGLProgram(l,c,"int32");if(d.shape[1]===1)return d;const f=WF(n,e,t,d);return n.disposeIntermediateTensorInfo(d),f}function GF(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],a=Lb(i),o=new efe(r,a,t,s==null),l=s==null?[e]:[e,s],c=n.runWebGLProgram(o,l,"int32");if(c.shape.length===e.shape.length){const d=GF(n,e,t,c);return n.disposeIntermediateTensorInfo(c),d}return c}function HF(n,e,t,s){const r=[t];if(Gn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!fe().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],a=n.texData.get(e.dataId),o=a!==null&&a.isPacked;let l=e;o&&(l=n.unpackTensor(e),i.push(l));const[c,d]=On(l.shape,r),f=ue(d),p=ze({inputs:{x:l},backend:n,attrs:{shape:[-1,f]}});i.push(p);const g=WF(n,p,s);i.push(g);const x=ze({inputs:{x:g},backend:n,attrs:{shape:c}});return i.forEach(b=>n.disposeIntermediateTensorInfo(b)),x}return GF(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=pt(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const c=[];o!=null&&(l=qs({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(l),a=cn(a.length,l.shape.length)),Gn("argMax",[a[0]],l.shape.length);const d=HF(t,l,a[0],"max");return c.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}const nfe={kernelName:hp,backendName:"webgl",kernelFunc:tfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=pt(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const c=[];o!=null&&(l=qs({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(l),a=cn(a.length,l.shape.length)),Gn("argMin",[a[0]],l.shape.length);const d=HF(t,l,a[0],"min");return c.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}const rfe={kernelName:dp,backendName:"webgl",kernelFunc:sfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ife=wi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,afe=Ft({opSnippet:ife}),ofe={kernelName:dh,backendName:"webgl",kernelFunc:afe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lfe=wi+"return log(x + sqrt(x * x + 1.0));",ufe=Ft({opSnippet:lfe}),cfe={kernelName:fh,backendName:"webgl",kernelFunc:ufe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hfe=wi+`
  return atan(x);
`,dfe=Ft({opSnippet:hfe}),ffe={kernelName:ph,backendName:"webgl",kernelFunc:dfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pfe=dC+`
  return atan(a, b);
`,mfe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ou+`
  return result;
`,gfe=$s({opSnippet:pfe,packedOpSnippet:mfe}),yfe={kernelName:gh,backendName:"webgl",kernelFunc:gfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xfe=wi+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,bfe=Ft({opSnippet:xfe}),vfe={kernelName:mh,backendName:"webgl",kernelFunc:bfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class op{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterHeight,p=e.effectiveFilterWidth,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const b=t==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,w=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let $="0.0";if(b||($="-1.0 / 1e-20"),s){const L=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${g}, ${x});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${L} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?v:w:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let N=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(N="avgValue / max(count, 1.0)");const E=Math.floor(a/4)*4,D=a%4,O=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${g}, ${x});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${O}
          }

          int xC = xCCorner + ${E};
          if (${D===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${O}
          } else if (${D===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${O}
          } else if (${D===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${O}
          }
        }
        setOutput(${N});
      }
    `}}class pC{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideDepth,l=e.strideHeight,c=e.strideWidth,d=e.dilationDepth,f=e.dilationHeight,p=e.dilationWidth,g=e.effectiveFilterDepth,x=e.effectiveFilterHeight,b=e.effectiveFilterWidth,v=e.padInfo.front,w=e.padInfo.top,$=e.padInfo.left;this.outputShape=e.outShape;const I=t==="avg";let N="0.0";if(I||(N="-1.0 / 1e-20"),s){const P=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${c});
        const ivec3 pads = ivec3(${v}, ${w}, ${$});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${x};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${b};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${x} * ${b} +
                      wR * ${b} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let D=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(D="avgValue / max(count, 1.0)");const O=Math.floor(a/4)*4,L=a%4,z=`
      if (${I}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${c});
      const ivec3 pads = ivec3(${v}, ${w}, ${$});
      const float initializationValue = ${N};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${N});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${x};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${O}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${z}
            }

            int xC = xCCorner + ${O};
            if (${L===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${z}
            } else if (${L===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${z}
            } else if (${L===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${z}
            }
          }
        }
        setOutput(${D});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Am(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,c=1;B(ns(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=As(r.shape,i,a,c,o,l);if(d.filterWidth===1&&d.filterHeight===1&&yt(d.inShape,d.outShape))return Ir({inputs:{x:r},backend:t});const f=new op(d,"avg",!1);return t.runWebGLProgram(f,[r],"float32")}const Sfe={kernelName:fp,backendName:"webgl",kernelFunc:wfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s,d=[1,1,1],f=jr(r.shape,i,a,d,o,l,c),p=new pC(f,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const $fe={kernelName:pp,backendName:"webgl",kernelFunc:Cfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kfe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=l-1-e.padInfo.top,f=c-1-e.padInfo.left,p=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${f});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Nfe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,p=e.effectiveFilterHeight,g=e.effectiveFilterWidth,x=f-1-e.padInfo.front,b=p-1-e.padInfo.top,v=g-1-e.padInfo.left,w=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${x}, ${b}, ${v});
      const float avgMultiplier = float(${w});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ife(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:c,dimRoundingMode:d}=s,f=[1,1,1],p=jr(a.shape,o,l,f,c,d),g=new Nfe(p);return t.runWebGLProgram(g,[r],a.dtype)}const Tfe={kernelName:dx,backendName:"webgl",kernelFunc:Ife};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;Am([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,d=As(a.shape,o,l,1,c),f=new kfe(d);return t.runWebGLProgram(f,[r],a.dtype)}const Rfe={kernelName:hx,backendName:"webgl",kernelFunc:Efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Afe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return rx({a:r,b:i,transposeA:a,transposeB:o,backend:t})}const Dfe={kernelName:mp,backendName:"webgl",kernelFunc:Afe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _fe{constructor(e,t,s,r,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],tt(e,t),tt(e,s);let o="0.0";r!=null&&(tt(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";i!=null&&(tt(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ofe{constructor(e,t,s,r,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],tt(e,t),tt(e,s);let o="vec4(0.0)";r!=null&&(tt(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(tt(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ffe=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:a,scale:o}=n;B(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[s,r,i];let d=null;a!=null&&(d=a.shape,c.push(a));let f=null;o!=null&&(f=o.shape,c.push(o));const p=fe().getBool("WEBGL_PACK_NORMALIZATION")?new Ofe(s.shape,r.shape,i.shape,d,f,l):new _fe(s.shape,r.shape,i.shape,d,f,l);return e.runWebGLProgram(p,c,c[0].dtype)},zfe={kernelName:Ip,backendName:"webgl",kernelFunc:Ffe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lfe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Qt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Pfe(this.rank);let r;const i=e.map((a,o)=>`sourceLoc.${c2[o]} = start[${o}] + coords.${c2[o]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const c2=["x","y","z","w","u","v"];function Pfe(n){if(n===1)return"sourceLoc";if(n<=6)return c2.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mfe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Qt(this.rank),s=Gs("coords",this.rank),r=Gs("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${i})`,o=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,f)=>`start[${f}]`).join()});`:e.map((d,f)=>`${r[f]} = ${s[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bfe(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),a=s.texData.get(i.dataId);Object.assign(a,r),a.refCount=1,a.shape=t,a.dtype=n.dtype;let o=vS(e,Ye(n.shape));r.slice&&(o+=r.slice.flatOffset),a.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),i}function wd(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s,[o,l]=ym(r,i,a);if(_b(r,o,l),ue(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const f=t.texData.get(r.dataId),p=Dhe(f.values,o,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,p)}const{isPacked:c}=t.texData.get(r.dataId),d=bS(r.shape,o,l);if(c||!d){const f=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mfe(l):new Lfe(l),p=[o];return t.runWebGLProgram(f,[r],r.dtype,p)}return t.uploadToGPU(r.dataId),Bfe(r,o,l,t)}const Vfe={kernelName:nm,backendName:"webgl",kernelFunc:wd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ufe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;B(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce(($,I)=>$*I),l=$u(r.shape,i,o),c=ku(l.length,i.length),d=Nu(r.shape,i,o),f=Mb(a,i.length),p=Bb(d,a,i.length),g=[],x=ze({inputs:{x:r},backend:t,attrs:{shape:l}}),b=qs({inputs:{x},backend:t,attrs:{perm:c}}),v=ze({inputs:{x:b},backend:t,attrs:{shape:d}}),w=wd({inputs:{x:v},backend:t,attrs:{begin:f,size:p}});return g.push(x),g.push(b),g.push(v),g.forEach($=>t.disposeIntermediateTensorInfo($)),w},Wfe={kernelName:gp,backendName:"webgl",kernelFunc:Ufe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=t.readSync(r.dataId),l=t.readSync(i.dataId),c=DF(o,l,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,c)}const Hfe={kernelName:fx,backendName:"webgl",kernelFunc:Gfe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jfe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,qfe=`
  return float(int(a.r) & int(b.r));
`;function Xfe(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=fe().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||a===1){const l=t.texData.get(s.dataId).values,c=t.texData.get(r.dataId).values,[d,f]=nhe(s.shape,r.shape,l,c,s.dtype),p=t.makeTensorInfo(f,s.dtype),g=t.texData.get(p.dataId);return g.values=d,p}let o;return i?o=new bd(jfe,s.shape,r.shape,!1):o=new xu(qfe,s.shape,r.shape),t.runWebGLProgram(o,[s,r],s.dtype)}const Kfe={kernelName:px,backendName:"webgl",kernelFunc:Xfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yfe(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),a=t.readSync(r.dataId),o=tt(Array.from(i),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Qfe={kernelName:mx,backendName:"webgl",kernelFunc:Yfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zfe="return float(a != b);",jF=$s({opSnippet:Zfe,cpuKernelImpl:Che,dtype:"bool"}),Jfe={kernelName:Gp,backendName:"webgl",kernelFunc:jF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _m(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Ir({inputs:{x:r.complexTensorInfos.real},backend:t})}const epe={kernelName:Gx,backendName:"webgl",kernelFunc:_m};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tpe="return float(int(x));";function npe(n,e){const t=new la(n.shape,tpe),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Ir({inputs:{x:r},backend:t});const a=Dn(r.shape),o=h2({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=ll({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(o),l}if(r.dtype==="complex64"){const a=_m({inputs:{input:r},backend:t}),o=h2({inputs:{x:a},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(a),o}if(!g2(r.dtype,i)){const a=Ir({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId).values,[o,l,c]=she(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,l,c)}if(i==="int32")return npe(r,t);if(i==="bool"){const a=t.makeTensorInfo([],"bool",es("bool",1)),l=jF({inputs:{a:r,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const spe={kernelName:yh,backendName:"webgl",kernelFunc:h2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oE="return ceil(x);",rpe=Ft({opSnippet:oE,packedOpSnippet:oE,cpuKernelImpl:rhe}),ipe={kernelName:xh,backendName:"webgl",kernelFunc:rpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ape{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ope{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;fe().getBool("WEBGL_PACK_CLIP")?o=new ope(r.shape):o=new ape(r.shape);const l=[[i],[a]];return t.runWebGLProgram(o,[r],r.dtype,l)}const upe={kernelName:bh,backendName:"webgl",kernelFunc:lpe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cpe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lE(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function hpe(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new cpe(s.shape),a=[lE(s,r.complexTensorInfos.real),lE(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,a,a[0].dtype)}const dpe={kernelName:yp,backendName:"webgl",kernelFunc:hpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fpe{constructor(e){this.outputShape=[],this.outputShape=ir(e,1),this.variableNames=e.map((a,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const o=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ppe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ir(e,t);const s=this.outputShape,r=s.length,i=Qt(r),a=Gs("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((b,v)=>`T${v}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let b=1;b<l.length;b++)l[b]=l[b-1]+e[b][t];const c=o[t],d=o.slice(-2),f=o.join();let p=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${f}), vec2(${d.join()}));
        }`;for(let b=1;b<l.length;b++){const v=l[b-1];p+=`
        if (${c} < ${l[b]}  && ${c} >= ${l[b-1]}) {
          return getChannel(
            getT${b}(${dy(o,c,v)}),
            vec2(${dy(d,c,v)}));
        }`}const g=l.length,x=l[l.length-1];p+=`
        return getChannel(
          getT${g}(${dy(o,c,x)}),
          vec2(${dy(d,c,x)}));`,this.userCode=`
      float getValue(${o.map(b=>"int "+b)}) {
        ${p}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function dy(n,e,t){const s=n.indexOf(e);return n.map((i,a)=>a===s?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Ir({inputs:{x:r.complexTensorInfos.imag},backend:t})}const mpe={kernelName:Ox,backendName:"webgl",kernelFunc:v0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(n,e,t){const s=n[0].dtype;if(s==="complex64"){const g=n.map($=>_m({inputs:{input:$},backend:t})),x=n.map($=>v0({inputs:{input:$},backend:t})),b=Pf(g,e,t),v=Pf(x,e,t),w=ll({inputs:{real:b,imag:v},backend:t});return g.forEach($=>t.disposeIntermediateTensorInfo($)),x.forEach($=>t.disposeIntermediateTensorInfo($)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),w}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const g=n.map(N=>{const D=[-1,ue(N.shape.slice(e))];return ze({inputs:{x:N},backend:t,attrs:{shape:D}})}),x=g.map(N=>({vals:t.readSync(N.dataId),shape:N.shape})),b=ir(g.map(N=>N.shape),1),v=g[0].shape[0]===1,w=ihe(x,b,s,v),$=ir(n.map(N=>N.shape),e),I=t.makeTensorInfo($,s,w);return g.forEach(N=>t.disposeIntermediateTensorInfo(N)),I}const i=n.filter(g=>ue(g.shape)>0),a=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const g=a?new la(n[0].shape,_o):new Lo(n[0].shape,_o);return t.runWebGLProgram(g,n,s)}const o=fe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){const g=[];for(let b=0;b<i.length;b+=o){const v=i.slice(b,b+o);g.push(Pf(v,e,t))}const x=Pf(g,e,t);for(const b of g)t.disposeIntermediateTensorInfo(b);return x}if(a){const g=new ppe(i.map(x=>x.shape),e);return t.runWebGLProgram(g,i,s)}const{tensors2D:l,outShape:c}=gpe(i,e,t),d=new fpe(l.map(g=>g.shape)),f=t.runWebGLProgram(d,l,s);l.forEach(g=>t.disposeIntermediateTensorInfo(g));const p=ze({inputs:{x:f},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(f),p}function gpe(n,e,t){const s=ir(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>ze({inputs:{x:i},attrs:{shape:[-1,ue(i.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qF(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=pt(r,e[0].shape)[0],a=e.map(c=>c.shape);zb(a,i);const o=ir(e.map(c=>c.shape),i);if(ue(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(c=>ue(c.shape)>0);return l.length===1?Ir({inputs:{x:l[0]},backend:t}):Pf(l,i,t)}const ype={kernelName:xp,backendName:"webgl",kernelFunc:qF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XF{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,o=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,f=e.dilationWidth,p=e.filterHeight,g=e.filterWidth,x=Math.floor(e.inChannels/4)*4,b=e.inChannels%4,v=e.dataFormat==="channelsLast",w=v?1:2,$=v?2:3,I=v?3:1;let N="",E="";s&&(r?N=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?N=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:N=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const D=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${N}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${I}];

        ivec2 xRCCorner =
            ivec2(coords[${w}], coords[${$}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${x}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${b===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${x}) *
                    getW(wR, wC, ${x}, d2);
              } else {
                dotProd +=
                    getX(batch, ${x}, xR, xC) *
                    getW(wR, wC, ${x}, d2);
              }

            } else if (${b===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${b===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2),
                getW(wR, wC, ${x} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1),
                  getX(batch, xR, xC, ${x} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC),
                  getX(batch, ${x} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${D}
        ${E}
        setOutput(result);
      }
    `}}class xpe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,f=e.filterDepth,p=e.filterHeight,g=e.filterWidth,x=Math.floor(e.inChannels/4)*4,b=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${x}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${b===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${x}) *
                  getW(wF, wR, wC, ${x}, d2);
              } else if (${b===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${b===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1),
                  getX(batch, xF, xR, xC, ${x} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2),
                  getW(wF, wR, wC, ${x} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KF{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_s(this.outputShape.length);const a=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,f=d;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<d;v++)p+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<d;v++)p+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(f+1)/2;v++){const w=v*2;if(p+=`
           xC = xCCorner + ${w*l};
           `,o===1){if(w<d&&(a%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }
               `,l===1&&w>0?p+=`
                 xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                   } else {
                     xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xC${w} = xTexelC${w};
                 `,w+1<d)){const $=a%2===0?p2(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${$};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                     xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${w+1}.zw = vec2(0.0);
                     }
                     xTexelC${w+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                     } else {
                      xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                     }
                     `:p+=`
                     xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                     `):$===1?p+=`
                     xC${w+1} = xTexelC${w};
                     `:p+=`
                     xCOffset = xC + ${$};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                       xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${w+1}.zw = vec2(0.0);
                       }
                       xTexelC${w+1}Ready = 1;
                     }

                     xC${w+1} = xTexelC${w+1};
                     `}}else w<d&&(a%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.0);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
               `,w+1<d&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(
                   xTexelC${w}.xy, xTexelC${w+1}.xy);
               `,w+1<d&&(p+=`
                   xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                 `)));w<d&&(p+=`
             wTexel = getW(r, ${w}, d1, d2);
             dotProd += xC${w}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${w}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,w+1<d&&(p+=`
               wTexel = getW(r, ${w+1}, d1, d2);
               dotProd += xC${w+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${w+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let g="",x="";s&&(r?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:g=`vec4 activation(vec4 x) {
           ${s}
         }`,x="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${b}
         ${x}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bpe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=_s(this.outputShape.length);const{dataFormat:s}=t,r=Ks(),i=s==="channelsLast",a=i?1:2,o=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let f=0;f<=1;f++)c+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${d};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ix(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function YF({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const l=n.shape,c=s.texData.get(n.dataId),d=t.inChannels,f=l[0]*l[1]*l[2],p=t.outChannels,g=t.dataFormat==="channelsLast",x=!1,b=!1;let v;const w=[];if(i!=null){const N=ix(i.shape,g);N!=null&&(i=ze({inputs:{x:i},backend:s,attrs:{shape:N}}),w.push(i))}if(r!=null){const N=ix(r.shape,g);N!=null&&(r=ze({inputs:{x:r},backend:s,attrs:{shape:N}}),w.push(r))}if(!((f===1||p===1)&&d>UF)&&c.isPacked&&g&&c.texture!=null&&l[2]%2!==0&&yt(c.shape.slice(-3),l.slice(-3))){const N=l[0]*l[1]*(l[2]+1),E={dataId:n.dataId,shape:[1,N,t.inChannels],dtype:n.dtype},D=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,B(sx(c.shape,E.shape),()=>`packed reshape ${c.shape} to ${E.shape} isn't free`);const O=ze({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});w.push(O);const L=rx({a:E,b:O,backend:s,transposeA:x,transposeB:b,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),z=s.texData.get(L.dataId);B(z.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=D,z.shape=t.outShape,v=Ir({inputs:{x:L},backend:s}),v.shape=t.outShape,w.push(L)}else{const N=t.outHeight*t.outWidth,E=ze({inputs:{x:n},backend:s,attrs:{shape:g?[t.batchSize,N,t.inChannels]:[t.batchSize,t.inChannels,N]}}),D=ze({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),O=rx({a:g?E:D,b:g?D:E,transposeA:!g,transposeB:b,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});v=ze({inputs:{x:O},backend:s,attrs:{shape:t.outShape}}),w.push(E),w.push(D),w.push(O)}for(const N of w)s.disposeIntermediateTensorInfo(N);return v}function QF({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:c,inChannels:d,outWidth:f,outHeight:p,dataFormat:g}=t,x=g==="channelsLast",b=l*c*d,v=p*f,w=[t.batchSize,b,v],$=!0,I=!1,N=[];if(i!=null){const re=ix(i.shape,x);re!=null&&(i=ze({inputs:{x:i},backend:s,attrs:{shape:re}}),N.push(i))}if(r!=null){const re=ix(r.shape,x);re!=null&&(r=ze({inputs:{x:r},backend:s,attrs:{shape:re}}),N.push(r))}const E=ze({inputs:{x:e},backend:s,attrs:{shape:[1,b,ue(e.shape)/b]}});N.push(E);const D=new bpe(w,t),O=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],L=s.runWebGLProgram(D,[n],"float32",O),z=ze({inputs:{x:L},backend:s,attrs:{shape:w}});N.push(L),N.push(z);const P=r!=null,_=i!=null,H=o==="leakyrelu",q=o?ap(o,!0):null,ee=new VF(x?z.shape:E.shape,x?E.shape:z.shape,x?[t.batchSize,v,t.outChannels]:[t.batchSize,t.outChannels,v],$,I,P,q,_,H),Y=x?[z,E]:[E,z];if(r&&Y.push(r),_&&Y.push(i),H){const re=s.makeTensorInfo([],"float32",Jo(a,"float32"));Y.push(re),N.push(re)}const G=s.runWebGLProgram(ee,Y,"float32"),te=ze({inputs:{x:G},backend:s,attrs:{shape:t.outShape}});N.push(G);for(const re of N)s.disposeIntermediateTensorInfo(re);return te}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:d}=s,f=Tr(l),p=un(r.shape,i.shape,a,c,o,d,!1,f);let g;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))g=YF({x:r,filter:i,convInfo:p,backend:t});else if(p.strideWidth<=2&&f==="channelsLast"&&fe().getBool("WEBGL_EXP_CONV")){const b=new KF(p),v=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];g=t.runWebGLProgram(b,[r,i],"float32",v)}else if(fe().getBool("WEBGL_CONV_IM2COL"))g=QF({x:r,filter:i,convInfo:p,backend:t});else{const b=new XF(p);g=t.runWebGLProgram(b,[r,i],"float32")}const x=ze({inputs:{x:g},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(g),x}const wpe={kernelName:bp,backendName:"webgl",kernelFunc:vpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Spe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Cpe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=a?1:2,d=a?2:3,f=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $pe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class kpe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=t-1-e.padInfo.front,c=s-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Npe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:d}=s,f=Tr(l),p=un(r.shape,d,a,1,o,c,!1,f),g=new Spe(p);return t.runWebGLProgram(g,[r,i],"float32")}const Ipe={kernelName:yx,backendName:"webgl",kernelFunc:Npe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tpe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=_s(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Epe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:d}=s,f=Tr(c),p=un(a,i.shape,o,1,l,d,!1,f);if(fe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const g=[[p.strideHeight,p.strideWidth]],x=new Tpe(p);return t.runWebGLProgram(x,[r,i],"float32",g)}else{const g=new Cpe(p);return t.runWebGLProgram(g,[r,i],"float32")}}const Rpe={kernelName:vp,backendName:"webgl",kernelFunc:Epe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ape(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,c=Wi(r.shape,i.shape,a,l,o),d=new xpe(c);return t.runWebGLProgram(d,[r,i],"float32")}const Dpe={kernelName:wp,backendName:"webgl",kernelFunc:Ape};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _pe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s,c=Wi(r.shape,l,a,1,o),d=new $pe(c);return t.runWebGLProgram(d,[r,i],"float32")}const Ope={kernelName:xx,backendName:"webgl",kernelFunc:_pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fpe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:l}=s,c=Wi(l,i.shape,o,1,a),d=new kpe(c);return t.runWebGLProgram(d,[r,i],"float32")}const zpe={kernelName:bx,backendName:"webgl",kernelFunc:Fpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lpe=vd+`
  return cos(x);
`,Ppe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Ou}
  return result;
`,Mpe=Ft({opSnippet:Lpe,packedOpSnippet:Ppe}),Bpe={kernelName:vh,backendName:"webgl",kernelFunc:Mpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vpe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Upe=Ft({opSnippet:Vpe}),Wpe={kernelName:wh,backendName:"webgl",kernelFunc:Upe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gpe{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,l,c]=e,[d]=t,[f,p]=s;this.outputShape=[d,f,p,c];const g=r==="bilinear"?1:0,[x,b]=[`${o-1}.0`,`${l-1}.0`],[v,w,$]=f>1?[`${(o-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${x} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${x}`],[I,N,E]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${b} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${b}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${I});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${w};
        float width_scale = ${N};

        float in_y = ${$};
        if( in_y < 0.0 || in_y > ${x} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${b} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hpe=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:c}=s,d=new Gpe(r.shape,i.shape,o,l,c);return t.runWebGLProgram(d,[r,i,a],"float32")},jpe={kernelName:wx,backendName:"webgl",kernelFunc:Hpe};var lp;(function(n){n.Prod="*",n.Sum="+"})(lp||(lp={}));class uE{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=this.op===lp.Prod?"1.0":"0.0",o=s?a:`getX(${cE(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",d="";s?(c=r?`end != ${l-1}`:"end != 0",d=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${l}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Qt(i)} coords = getOutputCoords();
        int end = ${hE(i,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${d};
          ${hE(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${cE(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function cE(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function hE(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(n,e,t,s,r,i){const a=e.shape.length,o=Zt([s],a);let l=e;o!=null&&(l=qs({inputs:{x:e},backend:t,attrs:{perm:o}}));const c=cn(1,a)[0];if(c!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=l.shape[c];let f=Ir({inputs:{x:l},backend:t});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const g=new uE(n,l.shape,!1,i),x=[[p]],b=f;f=t.runWebGLProgram(g,[f],f.dtype,x),t.disposeIntermediateTensorInfo(b)}if(r){const p=new uE(n,l.shape,r,i),g=f;f=t.runWebGLProgram(p,[f],f.dtype),t.disposeIntermediateTensorInfo(g)}if(o!=null){const p=xa(o),g=qs({inputs:{x:f},backend:t,attrs:{perm:p}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(l),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return ZF(lp.Prod,r,t,i,a,o)}const Xpe={kernelName:vx,backendName:"webgl",kernelFunc:qpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return ZF(lp.Sum,r,t,i,a,o)}const Ype={kernelName:Sp,backendName:"webgl",kernelFunc:Kpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),c=t.readSync(i.dataId),d=DF(l,c,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const l=t.bufferSync(r),c=t.bufferSync(i),d=the(l,c,a,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Zpe={kernelName:Sx,backendName:"webgl",kernelFunc:Qpe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jpe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s,o=r.shape[0],l=a==="NHWC"?r.shape[1]:r.shape[2],c=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],f=l*i,p=c*i,g=d/(i*i),x=a==="NHWC"?[o,f,p,g]:[o,g,f,p],b=new Jpe(x,i,a);return t.runWebGLProgram(b,[r],r.dtype)}const tme={kernelName:Cx,backendName:"webgl",kernelFunc:eme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JF{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_s(this.outputShape.length);const a=e.filterHeight,o=e.filterWidth,l=e.outChannels/e.inChannels;let c="",d="";s&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ez{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_s(this.outputShape.length);const a=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,p=f;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<f;w++)g+=`
          vec4 xTexelC${w*2};
          int xTexelC${w*2}Ready;
          vec4 xTexelC${w*2+1};
          int xTexelC${w*2+1}Ready;
          vec4 xC${w};`;g+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let w=0;w<f;w++)g+=`
          xTexelC${w*2} = vec4(0.0);
          xTexelC${w*2}Ready = 0;
          xTexelC${w*2+1} = vec4(0.0);
          xTexelC${w*2+1}Ready = 0;
          xC${w} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let w=0;w<(p+1)/2;w++){const $=w*2;if(g+=`
          xC = xCCorner + ${$*c};
          `,l===1){if($<f&&(o%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,c===1&&$>0?g+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<f)){const I=o%2===0?p2(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${I};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,c>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${$+1} = vec4(previous.zw, xTexelC${$+1}.xy);
                    } else {
                     xC${$+1} = vec4(0.0, 0.0, xTexelC${$+1}.xy);
                    }
                    `:g+=`
                    xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                    `):I===1?g+=`
                    xC${$+1} = xTexelC${$};
                    `:g+=`
                    xCOffset = xC + ${I};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<f&&(o%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<f&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<f&&(g+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<f&&(g+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<f&&(g+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let x="",b="";s&&(r?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:x=`vec4 activation(vec4 x) {
          ${s}
        }`,b="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${b}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:c}=s;let d=l;d==null&&(d=[1,1]),B(ns(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const f=un(r.shape,i.shape,a,d,o,c,!0);let p;fe().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?p=new ez(f):p=new JF(f);const g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return t.runWebGLProgram(p,[r,i],"float32",g)}const sme={kernelName:Cp,backendName:"webgl",kernelFunc:nme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rme{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ime{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=t-1-e.padInfo.top,o=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ame(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:d}=s,f=un(r.shape,d,a,o,l,c,!0),p=new rme(f);return t.runWebGLProgram(p,[r,i],"float32")}const ome={kernelName:$x,backendName:"webgl",kernelFunc:ame};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lme(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:d}=s,f=un(d,i.shape,a,o,l,c,!0),p=new ime(f);return t.runWebGLProgram(p,[r,i],"float32")}const ume={kernelName:kx,backendName:"webgl",kernelFunc:lme};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cme{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hme(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=ue(s.shape),a=ze({inputs:{x:s},backend:t,attrs:{shape:[i]}}),o=new cme(i),l=t.runWebGLProgram(o,[a],a.dtype),c=ze({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const dme={kernelName:Nx,backendName:"webgl",kernelFunc:hme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fme{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:a,filterHeight:o,filterWidth:l,dilationHeight:c,dilationWidth:d}=e,{top:f,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${f}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,c=nl(r.shape,i.shape,a,o,"NHWC",l);let d;const f=new fme(c);d=t.runWebGLProgram(f,[r,i],"float32");const p=ze({inputs:{x:d},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(d),p}const mme={kernelName:$p,backendName:"webgl",kernelFunc:pme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gme(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:l}=qb(r,i.length);Kb(a.length,l,i);const{path:c,steps:d}=Yb(o,l),f=d.length;let p=null,g=a.length;const x=[];for(let b=0;b<f;++b){for(const v of d[b]){const{permutationIndices:w,expandDims:$}=Xb(g,l[v]);let I;Qb(w)?I=i[v]:(I=qs({inputs:{x:i[v]},backend:t,attrs:{perm:w}}),x.push(I));const N=I.shape.slice();for(let E=0;E<$.length;++E)N.splice($[E],0,1);yt(I.shape,N)||(I=ze({inputs:{x:I},backend:t,attrs:{shape:N}}),x.push(I)),p===null?p=I:(p=fC({inputs:{a:I,b:p},backend:t}),x.push(p))}b<f-1&&(c[b]>=0&&(p=b0({inputs:{x:p},backend:t,attrs:{axis:c[b]-(a.length-g),keepDims:!1}}),x.push(p)),g--)}for(const b of x)b!==p&&t.disposeIntermediateTensorInfo(b);return p}const yme={kernelName:Ix,backendName:"webgl",kernelFunc:gme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xme="return (x >= 0.0) ? x : (exp(x) - 1.0);",bme=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,vme=Ft({opSnippet:xme,packedOpSnippet:bme}),wme={kernelName:Ch,backendName:"webgl",kernelFunc:vme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sme="return (b >= 0.0) ? a : a * (b + 1.0);",Cme=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,$me=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bd(Cme,s.shape,r.shape):new xu(Sme,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},kme={kernelName:Tx,backendName:"webgl",kernelFunc:$me};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nme=`
  return vec4(equal(a, b));
`,Ime="return float(a == b);",Tme=$s({opSnippet:Ime,packedOpSnippet:Nme,dtype:"bool",cpuKernelImpl:ahe}),Eme={kernelName:kp,backendName:"webgl",kernelFunc:Tme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rme=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Vb};
  float a1 = ${Ub};
  float a2 = ${Wb};
  float a3 = ${Gb};
  float a4 = ${Hb};
  float a5 = ${jb};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Ame=Ft({opSnippet:Rme}),Dme={kernelName:$h,backendName:"webgl",kernelFunc:Ame};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _me=vd+`
  return exp(x);
`,Ome=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tz=Ft({opSnippet:_me,packedOpSnippet:Ome,cpuKernelImpl:ohe,dtype:"float32"}),Fme={kernelName:kh,backendName:"webgl",kernelFunc:tz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d2(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,a=i.shape.length,o=i.shape.slice();let l=r;return r<0&&(B(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),o.splice(l,0,1),ze({inputs:{x:i},backend:s,attrs:{shape:o}})}const zme={kernelName:Np,backendName:"webgl",kernelFunc:d2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dE="return exp(x) - 1.0;",Lme=Ft({opSnippet:dE,packedOpSnippet:dE,cpuKernelImpl:lhe}),Pme={kernelName:Nh,backendName:"webgl",kernelFunc:Lme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fE{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nz(n,e,t){const s=t.texData.get(n.dataId),r=ue(n.shape),i=n.shape[n.shape.length-1],a=r/i,o=ze({inputs:{x:n},backend:t,attrs:{shape:[a,i]}}),l=o.shape,c=new fE("real",l,e),d=new fE("imag",l,e),f=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],p=t.runWebGLProgram(c,f,"float32"),g=t.runWebGLProgram(d,f,"float32"),x=ll({inputs:{real:p,imag:g},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g);const b=ze({inputs:{x},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(x),b}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mme(n){const{inputs:e,backend:t}=n,{input:s}=e;return nz(s,!1,t)}const Bme={kernelName:Ex,backendName:"webgl",kernelFunc:Mme};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vme{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Om(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||bu(r),i==="string"){const a=kn(i,ue(s));return a.fill(r),e.makeTensorInfo(s,i,a)}else{const a=new Vme(s,r),o=[[r]];return e.runWebGLProgram(a,[],i,o)}}const Ume={kernelName:Rx,backendName:"webgl",kernelFunc:Om};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wme{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gme={kernelName:Ax,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new Wme(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pE="return floor(x);",Hme=Ft({opSnippet:pE,packedOpSnippet:pE,cpuKernelImpl:uhe}),jme={kernelName:Ih,backendName:"webgl",kernelFunc:Hme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qme=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Xme=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Kme=$s({opSnippet:qme,packedOpSnippet:Xme,dtype:"int32"}),Yme={kernelName:Th,backendName:"webgl",kernelFunc:Kme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qme{constructor(e){this.variableNames=["A"];const t=Ks(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zme{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Ks(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jme={kernelName:Ry,backendName:"webgl",kernelFunc:ege};let zc,hw=fe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function ege(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,c]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[c,l],f=[c,l,i];if(o||a){const b=fe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(zc==null||b!==hw)&&(hw=b,zc=document.createElement("canvas").getContext("2d",{willReadFrequently:hw})),zc.canvas.width=l,zc.canvas.height=c,zc.drawImage(r,0,0,l,c),r=zc.canvas}const p=t.makeTensorInfo(d,"int32");t.texData.get(p.dataId).usage=Vr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),r);const g=fe().getBool("WEBGL_PACK")?new Zme(f):new Qme(f),x=t.runWebGLProgram(g,[p],"int32");return t.disposeData(p.dataId),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:x}=s,b=Tr(d),v=un(r.shape,i.shape,l,f,c,p,!1,b);let w;const $=[],I=a!=null,N=o!=null,E=g==="leakyrelu",D=()=>{const L=[r,i],z=(P,_)=>{if(_==="NCHW"&&P.shape.length===1&&P.shape[0]!==1){const H=ze({inputs:{x:P},backend:t,attrs:{shape:[P.shape[0],1,1]}});return $.push(H),H}return P};if(I&&L.push(z(a,d)),N&&L.push(z(o,d)),E){const P=t.makeTensorInfo([],"float32",Jo(x,"float32"));L.push(P),$.push(P)}return L};if(v.filterHeight===1&&v.filterWidth===1&&v.dilationHeight===1&&v.dilationWidth===1&&v.strideHeight===1&&v.strideWidth===1&&(v.padInfo.type==="SAME"||v.padInfo.type==="VALID"))w=YF({x:r,filter:i,convInfo:v,backend:t,bias:a,activation:g,preluActivationWeights:o,leakyreluAlpha:x});else if(v.strideWidth<=2&&b==="channelsLast"&&fe().getBool("WEBGL_EXP_CONV")){const L=g?ap(g,!0):null,z=new KF(v,I,L,N,E),P=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],_=D();w=t.runWebGLProgram(z,_,"float32",P)}else if(fe().getBool("WEBGL_CONV_IM2COL"))w=QF({x:r,filter:i,convInfo:v,backend:t,bias:a,activation:g,preluActivationWeights:o,leakyreluAlpha:x});else{const L=g?ap(g,!1):null,z=new XF(v,I,L,N,E),P=D();w=t.runWebGLProgram(z,P,"float32")}const O=ze({inputs:{x:w},backend:t,attrs:{shape:v.outShape}});return $.push(w),$.forEach(L=>t.disposeIntermediateTensorInfo(L)),O}const nge={kernelName:Uf,backendName:"webgl",kernelFunc:tge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=s,x=[];let b=d;b==null&&(b=[1,1]),B(ns(l,b),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${b}'`);const v=un(r.shape,i.shape,l,b,c,f,!0),w=fe().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels===1,$=p?ap(p,w):null,I=[r,i],N=a!=null,E=o!=null,D=p==="leakyrelu";if(N&&I.push(a),E&&I.push(o),D){const P=t.makeTensorInfo([],"float32",Jo(g,"float32"));I.push(P),x.push(P)}let O;w?O=new ez(v,N,$,E,D):O=new JF(v,N,$,E,D);const L=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],z=t.runWebGLProgram(O,I,"float32",L);return x.forEach(P=>t.disposeIntermediateTensorInfo(P)),z}const rge={kernelName:Wf,backendName:"webgl",kernelFunc:sge};class ige{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=Qt(s.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function age(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,a=i[i.length-1],o=ue(s.shape),[l,c,d,f]=Db(s,r),p=ze({inputs:{x:r},backend:t,attrs:{shape:[c,a]}}),g=ze({inputs:{x:s},backend:t,attrs:{shape:[ue(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const w=t.readSync(r.dataId),$=t.bufferSync(s),I=che(w,$,s.dtype,c,a,d,f,s.shape,o);return t.makeTensorInfo(l,s.dtype,I.values)}const x=new ige(a,f,[c,d],s.shape),b=t.runWebGLProgram(x,[g,p],g.dtype),v=ze({inputs:{x:b},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),v}const oge={kernelName:Dx,backendName:"webgl",kernelFunc:age};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lge{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Qt(this.rank),r=uge(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function uge(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s,l=pt(a,r.shape)[0];if(fe().get("DEBUG")){const $=t.readSync(i.dataId),I=r.shape[l];for(let N=0;N<$.length;++N){const E=$[N];B(E<=I-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${I-1}]`)}}const c=Jb(r,i,l,o),d=ue(i.shape),f=[],p=ze({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=ze({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,d/c.batchSize]}});f.push(p),f.push(g);const x=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const $=t.bufferSync(g),I=t.bufferSync(p),N=hhe(I,$,x);return f.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(c.outputShape,N.dtype,N.values)}const b=new lge(p.shape,x),v=t.runWebGLProgram(b,[p,g],p.dtype);f.push(v);const w=ze({inputs:{x:v},backend:t,attrs:{shape:c.outputShape}});return f.forEach($=>t.disposeIntermediateTensorInfo($)),w}const cge={kernelName:Tp,backendName:"webgl",kernelFunc:sz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hge="return float(a > b);",dge=`
  return vec4(greaterThan(a, b));
`,fge=$s({opSnippet:hge,packedOpSnippet:dge,cpuKernelImpl:dhe,dtype:"bool"}),pge={kernelName:Ep,backendName:"webgl",kernelFunc:fge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mge="return float(a >= b);",gge=`
  return vec4(greaterThanEqual(a, b));
`,yge=$s({opSnippet:mge,packedOpSnippet:gge,dtype:"bool",cpuKernelImpl:fhe}),xge={kernelName:Eh,backendName:"webgl",kernelFunc:yge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bge(n){const{inputs:e,backend:t}=n,{input:s}=e;return nz(s,!0,t)}const vge={kernelName:_x,backendName:"webgl",kernelFunc:bge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wge="return float(!isnan(x) && !isinf(x));",Sge=Ft({opSnippet:wge,dtype:"bool"}),Cge={kernelName:Ah,backendName:"webgl",kernelFunc:Sge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ge="return float(isinf(x));",kge=Ft({opSnippet:$ge,dtype:"bool"}),Nge={kernelName:Dh,backendName:"webgl",kernelFunc:kge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ige="return float(isnan(x));",Tge=Ft({opSnippet:Ige,dtype:"bool"}),Ege={kernelName:_h,backendName:"webgl",kernelFunc:Tge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rge="return float(a < b);",Age=`
  return vec4(lessThan(a, b));
`,Dge=$s({opSnippet:Rge,packedOpSnippet:Age,cpuKernelImpl:phe,dtype:"bool"}),_ge={kernelName:Ap,backendName:"webgl",kernelFunc:Dge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oge="return float(a <= b);",Fge=`
  return vec4(lessThanEqual(a, b));
`,zge=$s({opSnippet:Oge,packedOpSnippet:Fge,cpuKernelImpl:mhe,dtype:"bool"}),Lge={kernelName:Dp,backendName:"webgl",kernelFunc:zge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pge(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=ghe(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const Mge={kernelName:Fx,backendName:"webgl",kernelFunc:Pge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bge=vd+`
  return x < 0.0 ? 0./0. : log(x);
`,Vge=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Uge=Ft({opSnippet:Bge,packedOpSnippet:Vge,cpuKernelImpl:yhe}),Wge={kernelName:Oh,backendName:"webgl",kernelFunc:Uge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gge=vd+`
  return log(1.0 + x);
`,Hge=Ft({opSnippet:Gge}),jge={kernelName:Fh,backendName:"webgl",kernelFunc:Hge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qge="return float(a >= 1.0 && b >= 1.0);",Xge=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Kge=$s({opSnippet:qge,packedOpSnippet:Xge,dtype:"bool"}),Yge={kernelName:_p,backendName:"webgl",kernelFunc:Kge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qge="return float(!(x >= 1.0));",Zge=Ft({opSnippet:Qge}),Jge={kernelName:Op,backendName:"webgl",kernelFunc:Zge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eye="return float(a >= 1.0 || b >= 1.0);",tye=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,nye=$s({opSnippet:eye,packedOpSnippet:tye,dtype:"bool"}),sye={kernelName:Fp,backendName:"webgl",kernelFunc:nye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rye{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const a=t,o=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iye{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,o=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aye=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s,c=fe().getBool("WEBGL_PACK_NORMALIZATION")?new iye(r.shape,i,a,o,l):new rye(r.shape,i,a,o,l);return t.runWebGLProgram(c,[r],r.dtype)},oye={kernelName:zp,backendName:"webgl",kernelFunc:aye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lye{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uye=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:c,beta:d}=s,f=new lye(r.shape,o,l,c,d);return t.runWebGLProgram(f,[r,i,a],r.dtype)},cye={kernelName:zx,backendName:"webgl",kernelFunc:uye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hye(n,e,t,s){const r=ue(e),a=ue(n.shape)/r,o=ze({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),l=Fu(o,n.dtype,"max",s),c=ze({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=r.shape.length,l=pt(i,r.shape);let c=l;const d=Zt(c,o),f=d!=null,p=t.shouldExecuteOnCPU([r]);let g=r;if(f){if(p){const I=t.texData.get(g.dataId).values,N=new Array(o);for(let O=0;O<N.length;O++)N[O]=r.shape[d[O]];const E=hC(I,r.shape,r.dtype,d,N);g=t.makeTensorInfo(N,r.dtype);const D=t.texData.get(g.dataId);D.values=E}else g=x0(r,d,t);c=cn(c.length,o)}Gn("max",c,o);const[x,b]=On(g.shape,c);let v=x;a&&(v=In(x,l));let w;if(p){const I=t.texData.get(g.dataId).values,N=xhe(I,ue(b),v,r.dtype);w=t.makeTensorInfo(v,r.dtype);const E=t.texData.get(w.dataId);E.values=N}else w=hye(g,b,v,t);return f&&t.disposeIntermediateTensorInfo(g),w}const dye={kernelName:Lp,backendName:"webgl",kernelFunc:rz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fye=dC+`
  return max(a, b);
`,pye=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ou+`
  return result;
`,mye=$s({opSnippet:fye,packedOpSnippet:pye,cpuKernelImpl:bhe}),gye={kernelName:zh,backendName:"webgl",kernelFunc:mye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Am(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,c=1;B(ns(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=As(r.shape,i,a,c,o,l);if(d.filterWidth===1&&d.filterHeight===1&&yt(d.inShape,d.outShape))return Ir({inputs:{x:r},backend:t});const f=new op(d,"max",!1);return t.runWebGLProgram(f,[r],r.dtype)}const xye={kernelName:Pp,backendName:"webgl",kernelFunc:yye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:c}=s,d=[1,1,1],f=jr(r.shape,i,a,d,o,c,l),p=new pC(f,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const vye={kernelName:Mp,backendName:"webgl",kernelFunc:bye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wye{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=i-1-e.padInfo.top,l=a-1-e.padInfo.left,c=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Sye{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=l-1-e.padInfo.front,p=c-1-e.padInfo.top,g=d-1-e.padInfo.left,x=l*c*d-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${p}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${x} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cye(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:c,dimRoundingMode:d}=s,f=[1,1,1],p=jr(a.shape,o,l,f,c,d),g=new pC(p,"max",!0),x=t.runWebGLProgram(g,[a],a.dtype),b=new Sye(p),v=t.runWebGLProgram(b,[r,x],a.dtype);return t.disposeIntermediateTensorInfo(x),v}const $ye={kernelName:Px,backendName:"webgl",kernelFunc:Cye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kye(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;Am([i,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=s,p=As(o.shape,l,c,1,d,f),g=!0,x=new op(p,"max",g),b=t.runWebGLProgram(x,[o],o.dtype),v=new wye(p),w=t.runWebGLProgram(v,[r,b],o.dtype);return t.disposeIntermediateTensorInfo(b),w}const Nye={kernelName:Lx,backendName:"webgl",kernelFunc:kye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iye(n,e,t,s){let r=new op(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new op(t,"max",!0,!0,e);const a=s.runWebGLProgram(r,[n],"float32");return[i,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tye={kernelName:Mx,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,l=t;B(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];B(ns(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=As(s.shape,r,i,c,a),[f,p]=Iye(s,o,d,l);return[f,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eye(n,e,t,s){const r=ue(e),a=ue(n.shape)/r,o=ze({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),l=Fu(o,"float32","mean",s),c=ze({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rye={kernelName:Bp,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,a=t,o=s.shape.length,l=pt(i,s.shape);let c=l;const d=Zt(c,o),f=d!=null,p=a.shouldExecuteOnCPU([s]),g=[];let x=s;if(f){if(p){const N=a.texData.get(x.dataId).values,E=new Array(o);for(let L=0;L<E.length;L++)E[L]=s.shape[d[L]];const D=hC(N,s.shape,s.dtype,d,E);x=a.makeTensorInfo(E,s.dtype);const O=a.texData.get(x.dataId);O.values=D}else x=x0(s,d,a);g.push(x),c=cn(c.length,o)}Gn("sum",c,o);const[b,v]=On(x.shape,c);let w=b;r&&(w=In(b,l));const $=Eye(x,v,w,a);for(const I of g)a.disposeIntermediateTensorInfo(I);return $}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=pt(i,r.shape);let c=l;const d=Zt(c,o);let f=r;d!=null&&(f=qs({inputs:{x:r},backend:t,attrs:{perm:d}}),c=cn(c.length,r.shape.length)),Gn("min",c,o);const[p,g]=On(f.shape,c),x=ue(g),b=ze({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),v=Fu(b,b.dtype,"min",t);let w;if(a){const $=In(p,l);w=ze({inputs:{x:v},backend:t,attrs:{shape:$}})}else w=ze({inputs:{x:v},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),d!=null&&t.disposeIntermediateTensorInfo(f),w}const Dye={kernelName:Vp,backendName:"webgl",kernelFunc:Aye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ye=dC+`
  return min(a, b);
`,Oye=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ou+`
  return result;
`,Fye=$s({opSnippet:_ye,packedOpSnippet:Oye,cpuKernelImpl:vhe}),zye={kernelName:Lh,backendName:"webgl",kernelFunc:Fye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lye{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((d,f)=>d[0]+e[f]+d[1]);const r=e.length,i=Qt(r),a=t.map(d=>d[0]).join(","),o=t.map((d,f)=>d[0]+e[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pye{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((x,b)=>x[0]+e[b]+x[1]);const r=e.length,i=Qt(r),a=t.map(x=>x[0]).join(","),o=t.map((x,b)=>x[0]+e[b]).join(","),l=Gs("rc",r),c=Gs("source",r),d=`${l[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${c.slice(-2).join()})`,p=s==="reflect"?0:1;let g="";if(r===1){const x=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;g=`
        ${i} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[r-1]} += 1;
        if(${d}) {
          ${x}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
      `}else{const x=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;g=`
        ${i} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[r-1]} += 1;
        if(${d}) {
          ${x}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${x}
          result[2] = getChannel(getX(${c.join()}), ${f});
          ${l[r-1]} += 1;
          if(${d}) {
            ${x}
            result[3] = getChannel(getX(${c.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mye=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,a=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pye(s.shape,r,i):new Lye(s.shape,r,i);return e.runWebGLProgram(a,[s],s.dtype)},Bye={kernelName:Up,backendName:"webgl",kernelFunc:Mye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vye=`if (b == 0.0) return NAN;
  return mod(a, b);`,Uye=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Ou+`
  return result;
`,Wye=$s({opSnippet:Vye,packedOpSnippet:Uye}),Gye={kernelName:Ph,backendName:"webgl",kernelFunc:Wye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hye{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jye=`
if (a == b) {
  return 1.0;
};
return a / b;`,qye=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,iz=$s({opSnippet:jye,packedOpSnippet:qye,checkOutOfBounds:!0}),Xye={kernelName:Sh,backendName:"webgl",kernelFunc:iz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mE="return a - b;",az=$s({opSnippet:mE,packedOpSnippet:mE,supportsComplex:!0,cpuKernelImpl:Vhe}),Kye={kernelName:ed,backendName:"webgl",kernelFunc:az};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oz(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=pt([i],r.shape),o=rz({inputs:{x:r},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),l=In(o.shape,a),c=ze({inputs:{x:o},backend:t,attrs:{shape:l}}),d=az({inputs:{a:r,b:c},backend:t}),f=tz({inputs:{x:d},backend:t}),p=b0({inputs:{x:f},backend:t,attrs:{axis:a,keepDims:!1}}),g=ze({inputs:{x:p},backend:t,attrs:{shape:l}}),x=iz({inputs:{a:f,b:g},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),x}const Yye={kernelName:am,backendName:"webgl",kernelFunc:oz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,l=o?r:oz({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=l.shape[0],d=l.shape[1],f=new Hye(c,d,i),p=[[a]],g=t.runWebGLProgram(f,[l],"int32",p);return o||t.disposeIntermediateTensorInfo(l),g}const Zye={kernelName:Bx,backendName:"webgl",kernelFunc:Qye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jye=wi+`
  return -x;
`,exe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function txe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[a,o]=She(i.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,a)}let r;return fe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Lo(s.shape,exe):r=new la(s.shape,Jye),t.runWebGLProgram(r,[s],s.dtype)}const nxe={kernelName:Wp,backendName:"webgl",kernelFunc:txe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sxe=Rb;function rxe(n){Br("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,c=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:f}=sxe(c,d,a,o,l);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const ixe={kernelName:Vx,backendName:"webgl",kernelFunc:rxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const axe=fS;function oxe(n){Br("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s,d=t.readSync(r.dataId),f=t.readSync(i.dataId),{selectedIndices:p,validOutputs:g}=axe(d,f,a,o,l,c);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const lxe={kernelName:v2,backendName:"webgl",kernelFunc:oxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uxe=Ab;function cxe(n){Br("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s,d=t.readSync(r.dataId),f=t.readSync(i.dataId),p=a,g=o,x=l,b=c,{selectedIndices:v,selectedScores:w}=uxe(d,f,p,g,x,b);return[t.makeTensorInfo([v.length],"int32",new Int32Array(v)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const hxe={kernelName:Ux,backendName:"webgl",kernelFunc:cxe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dxe{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fxe=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:l}=s,c=ue(r.shape),d=new dxe(c,a,o,l),f=ze({inputs:{x:r},backend:t,attrs:{shape:[c]}}),p=t.runWebGLProgram(d,[f],i);t.disposeIntermediateTensorInfo(f);const g=[...r.shape,a],x=ze({inputs:{x:p},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(p),x},pxe={kernelName:jp,backendName:"webgl",kernelFunc:fxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ax(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=_m({inputs:{input:s},backend:t}),i=ax({inputs:{x:r},backend:t}),a=v0({inputs:{input:s},backend:t}),o=ax({inputs:{x:a},backend:t}),l=ll({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return Om({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const mxe={kernelName:um,backendName:"webgl",kernelFunc:ax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lz(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=_m({inputs:{input:s},backend:t}),i=lz({inputs:{x:r},backend:t}),a=v0({inputs:{input:s},backend:t}),o=ax({inputs:{x:a},backend:t}),l=ll({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return Om({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const gxe={kernelName:Hp,backendName:"webgl",kernelFunc:lz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yxe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return d2({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{cr(i,d.shape,"All tensors passed to stack must have matching shapes"),B(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(d=>{const f=d2({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(f),f}),c=qF({inputs:l,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}const xxe={kernelName:qp,backendName:"webgl",kernelFunc:yxe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bxe{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,d)=>c[0]+e[d]+c[1]);const r=e.length,i=Qt(r),a=t.map(c=>c[0]).join(","),o=t.map((c,d)=>c[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vxe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((b,v)=>b[0]+e[v]+b[1]);const r=e.length,i=Qt(r),a=t.map(b=>b[0]).join(","),o=t.map((b,v)=>b[0]+e[v]).join(","),l=Gs("rc",r),c=Gs("source",r),d=`${l[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${d}) {`],g=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let x="";for(let b=0,v=r===1?2:4;b<v;b++)x+=`
        ${p[b]}
        if (${g}) {
          result[${b}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${b}] = getChannel(getX(${c.join()}), ${f});
        }
      `;x+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uz=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;if(ue(r.shape)===0){const c=i.map((d,f)=>d[0]+r.shape[f]+d[1]);return Om({backend:t,attrs:{shape:c,value:a,dtype:r.dtype}})}const o=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vxe(r.shape,i,a):new bxe(r.shape,i,a),l=[[a]];return t.runWebGLProgram(o,[r],r.dtype,l)},wxe={kernelName:Xp,backendName:"webgl",kernelFunc:uz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sxe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Cxe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ou+`
  return result;
`,$xe=$s({opSnippet:Sxe,packedOpSnippet:Cxe}),kxe={kernelName:Bh,backendName:"webgl",kernelFunc:$xe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=[],c=pt(i,r.shape);let d=c;const f=Zt(d,o);let p=r;f!=null&&(p=qs({inputs:{x:r},backend:t,attrs:{perm:f}}),d=cn(d.length,o),l.push(p)),Gn("prod",d,o);let g;if(t.shouldExecuteOnCPU([p])){const x=t.texData.get(p.dataId).values,{outVals:b,outShape:v,outDtype:w}=$he(p.shape,p.dtype,x,d);g=t.makeTensorInfo(v,w,b)}else{const[x,b]=On(p.shape,d),v=ue(b),w=ze({inputs:{x:p},backend:t,attrs:{shape:[-1,v]}}),$=ob(r.dtype),I=Fu(w,$,"prod",t);g=ze({inputs:{x:I},backend:t,attrs:{shape:x}}),l.push(w),l.push(I)}if(a){l.push(g);const x=In(g.shape,c);g=ze({inputs:{x:g},backend:t,attrs:{shape:x}})}return l.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const Ixe={kernelName:Yp,backendName:"webgl",kernelFunc:Nxe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:o}=s,l=r.map(w=>t.readSync(w.dataId)),c=r.map(w=>w.shape),d=t.readSync(i.dataId),f=t.readSync(a.dataId),[p,g,x]=khe(l,c,d,i.shape,i.dtype,f,a.shape,o),b=p.map(w=>t.makeTensorInfo([w.length],"int32",w)),v=t.makeTensorInfo(x,i.dtype,g);return b.concat([v])}const Exe={kernelName:w2,backendName:"webgl",kernelFunc:Txe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rxe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(i.dataId),[c,d]=Nhe(a,s.shape,s.dtype,o,r.shape,l,i.shape),f=t.makeTensorInfo([c.length],"int32",c),p=t.makeTensorInfo([d.length],s.dtype,d);return[f,p]}const Axe={kernelName:S2,backendName:"webgl",kernelFunc:Rxe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dxe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,c=t.readSync(r.dataId),d=t.readSync(i.dataId),f=t.readSync(a.dataId),p=o.map(v=>t.readSync(v.dataId)),g=o.map(v=>v.shape),[x,b]=Ihe(c,r.shape,d,i.shape,i.dtype,f,a.shape,p,g,l);return t.makeTensorInfo(x,i.dtype,b)}const _xe={kernelName:C2,backendName:"webgl",kernelFunc:Dxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cz=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:a}=t,o=The(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},Oxe={kernelName:Wx,backendName:"webgl",kernelFunc:cz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fxe="return 1.0 / x;",zxe=Ft({opSnippet:Fxe}),Lxe={kernelName:Vh,backendName:"webgl",kernelFunc:zxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pxe=wi+`
  return (x < 0.0) ? 0.0 : x;
`,Mxe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Bxe=Ft({opSnippet:Pxe,packedOpSnippet:Mxe}),Vxe={kernelName:Uh,backendName:"webgl",kernelFunc:Bxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uxe=wi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Wxe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Gxe=Ft({opSnippet:Uxe,packedOpSnippet:Wxe}),Hxe={kernelName:Wh,backendName:"webgl",kernelFunc:Gxe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jxe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,l,c]=e;this.outputShape=[a,t,s,c];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],f=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;i?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qxe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,c]=e;this.outputShape=[a,t,s,c];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],f=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;i?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xxe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,c]=o,d=fe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qxe(r.shape,l,c,i,a):new jxe(r.shape,l,c,i,a);return t.runWebGLProgram(d,[r],"float32")}const Kxe={kernelName:Jp,backendName:"webgl",kernelFunc:Xxe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yxe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,o]=e,l=[s&&a>1?r-1:r,s&&o>1?i-1:i],c=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=l[0]/c[0],f=l[1]/c[1],p=1/d,g=1/f,x=Math.ceil(p)*2+2,b=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${x});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qxe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,o=new Yxe(i.shape,r.shape,a);return t.runWebGLProgram(o,[i],i.dtype)}const Zxe={kernelName:jx,backendName:"webgl",kernelFunc:Qxe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jxe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,l,c]=e;this.outputShape=[a,t,s,c];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],f=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let g;i?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ebe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,c]=e;this.outputShape=[a,t,s,c];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],f=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let g;i?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tbe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,c]=o,d=fe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ebe(r.shape,l,c,i,a):new Jxe(r.shape,l,c,i,a);return t.runWebGLProgram(d,[r],r.dtype)}const nbe={kernelName:Zp,backendName:"webgl",kernelFunc:tbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sbe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,o]=e,l=[s&&a>1?r-1:r,s&&o>1?i-1:i],c=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=l[0]/c[0],f=l[1]/c[1],p=1/d,g=1/f,x=Math.ceil(p)*2+2,b=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${x});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rbe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,o=new sbe(i.shape,r.shape,a);return t.runWebGLProgram(o,[i],i.dtype)}const ibe={kernelName:Hx,backendName:"webgl",kernelFunc:rbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class abe{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,i=e.map((o,l)=>r(l)).join(","),a=Qt(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class obe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Gs("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=Qt(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${c(r.slice())};
          }
          if(${a}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${f(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(x){return p(x)}function c(x){return x[s-1]="("+x[s-1]+" + 1)",p(x)}function d(x){return x[s-2]="("+x[s-2]+" + 1)",p(x)}function f(x){return x[s-1]="("+x[s-1]+" + 1)",x[s-2]="("+x[s-2]+" + 1)",p(x)}function p(x){const b=e.map(($,I)=>g(I,x)),v=b.join(","),w=b.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${w}))`}function g(x,b){return t.indexOf(x)!==-1&&e[x]!==1?`${e[x]} - ${b[x]} - 1`:`${b[x]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,a=r.shape.length,o=pt(i,r.shape);if(a===0)return Ir({inputs:{x:r},backend:t});const l=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new obe(r.shape,o):new abe(r.shape,o);return t.runWebGLProgram(l,[r],r.dtype)}const ube={kernelName:em,backendName:"webgl",kernelFunc:lbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cbe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hbe={kernelName:ib,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,l=new cbe(s.shape,i),[c,d]=Pb(a,s.shape[1],s.shape[2]),f=[[c,d,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[s],s.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dbe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,fbe=Ft({opSnippet:dbe}),pbe={kernelName:Gh,backendName:"webgl",kernelFunc:fbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mbe="return inversesqrt(x);",gbe=Ft({opSnippet:mbe,cpuKernelImpl:Ehe}),ybe={kernelName:Hh,backendName:"webgl",kernelFunc:gbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mC{constructor(e,t,s,r,i,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const c=Qt(i.length),d=Qt(a.length);let f="";s===1?f="i":s===2&&(f="i, j");const p=`getIndices(${f})`;let g="";r===1?g="i":r===2&&(g="i, coords[1]");const x=`getUpdates(${g})`;let b="";l&&(b="coords[0], coords[1]");const v=`getDefaultValue(${b})`,w=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${w};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${x};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xbe{constructor(e,t,s,r,i,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const c=Qt(i.length),d=Qt(a.length);let f="";s===1?f="i":s===2&&(f="i, j");const p=`getIndices(${f})`;let g="";r===1?g="i":r===2&&(g="i, coords[1]");const x=`getUpdates(${g})`;let b="";l&&(b="coords[0], coords[1]");const v=`getDefaultValue(${b})`,w=t>1?"strides[j]":"strides",$=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${w};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${$};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${x};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bbe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=va(i,r,a),p=[f/c,c];if(f===0)return t.makeTensorInfo(a,r.dtype);const g=ze({inputs:{x:r},backend:t,attrs:{shape:[l,o]}}),x=ze({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),b=t.makeTensorInfo([],"float32",new Float32Array([0]));let v;fe().getBool("WEBGL_PACK")?v=new xbe(l,o,g.shape.length,x.shape.length,d,p):v=new mC(l,o,g.shape.length,x.shape.length,d,p);const w=t.runWebGLProgram(v,[x,g,b],x.dtype),$=ze({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(b),$}const vbe={kernelName:qx,backendName:"webgl",kernelFunc:bbe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wbe{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=fe().getNumber("WEBGL_VERSION")===2?i:a,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sbe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=new wbe(r.shape[0],r.shape[1],i.shape[1],a),l=[[r.shape[1]]];return t.runWebGLProgram(o,[r,i],"int32",l)}const Cbe={kernelName:Kx,backendName:"webgl",kernelFunc:Sbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $be{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let d=0;d<t.length;d++)c.push(`${o[d]}`),d<e&&l.push(`${o[d]}`);r=l.join(),i=c.join()}const a=Qt(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kbe(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,a=new $be(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(a,[s,r,i],ds(r.dtype,i.dtype))}const Nbe={kernelName:tm,backendName:"webgl",kernelFunc:kbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ibe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${xm};
  float scale = ${bm};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Tbe=Ft({opSnippet:Ibe}),Ebe={kernelName:jh,backendName:"webgl",kernelFunc:Tbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rbe=vd+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Abe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dbe=Ft({opSnippet:Rbe,packedOpSnippet:Abe,cpuKernelImpl:Ahe}),_be={kernelName:Yh,backendName:"webgl",kernelFunc:Dbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Obe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Fbe=Ft({opSnippet:Obe}),zbe={kernelName:Kh,backendName:"webgl",kernelFunc:Fbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lbe=vd+`
  return sin(x);
`,Pbe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Ou}
  return result;
`,Mbe=Ft({opSnippet:Lbe,packedOpSnippet:Pbe}),Bbe={kernelName:qh,backendName:"webgl",kernelFunc:Mbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vbe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Ube=Ft({opSnippet:Vbe}),Wbe={kernelName:Xh,backendName:"webgl",kernelFunc:Ube};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gbe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Hbe=Ft({opSnippet:Gbe}),jbe={kernelName:Qh,backendName:"webgl",kernelFunc:Hbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qbe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;B(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((w,$)=>w*$),l=[[0,0]];l.push(...a);for(let w=1+i.length;w<r.shape.length;++w)l.push([0,0]);const c=[],d=uz({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),f=$u(d.shape,i,o,!1),p=ku(f.length,i.length,!1),g=Nu(d.shape,i,o,!1),x=ze({inputs:{x:d},backend:t,attrs:{shape:f}}),b=qs({inputs:{x},backend:t,attrs:{perm:p}}),v=ze({inputs:{x:b},backend:t,attrs:{shape:g}});return c.push(d),c.push(x),c.push(b),c.forEach(w=>t.disposeIntermediateTensorInfo(w)),v},Xbe={kernelName:rm,backendName:"webgl",kernelFunc:qbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),d=t.readSync(a.dataId)[0],[f,p,g,x,b]=_he(o,s.shape,s.dtype,l,r.dtype,c,d);return[t.makeTensorInfo(p,s.dtype,f),t.makeTensorInfo([p[0]],r.dtype,g),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(v=>Number(v)))),t.makeTensorInfo([b.length],s.dtype,new Int32Array(b))]}const Ybe={kernelName:$2,backendName:"webgl",kernelFunc:Kbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qbe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.readSync(r.dataId)),o=t.readSync(s.dataId),l=Array.from(t.readSync(i.dataId)),[c,d,f]=Ohe(o,s.shape,s.dtype,a,l);return[t.makeTensorInfo(d,s.dtype,c),t.makeTensorInfo([f.length],i.dtype,new Int32Array(f))]}const Zbe={kernelName:k2,backendName:"webgl",kernelFunc:Qbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const a=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(i.dataId),[c,d]=OF(a,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(d,s.dtype,c)}const e0e={kernelName:Yx,backendName:"webgl",kernelFunc:Jbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0e(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const a=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(i.dataId),[c,d]=OF(a,s.shape,s.dtype,o,l);return t.makeTensorInfo(d,s.dtype,c)}const n0e={kernelName:Qx,backendName:"webgl",kernelFunc:t0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0e(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=va(i,r,o),g=!1;if(i.dtype==="string"){const w=t.bufferSync(r),$=t.bufferSync(i),I=Oi(t.readSync(a.dataId)[0]),N=Rhe(w,$,o,p,d,c,l,f,I,g);return t.makeTensorInfo(o,N.dtype,N.values)}const x=new mC(c,l,r.shape.length,i.shape.length,f,[p,1],g),b=t.runWebGLProgram(x,[i,r,a],i.dtype),v=ze({inputs:{x:b},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(b),v}const r0e={kernelName:Zx,backendName:"webgl",kernelFunc:s0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=pt(a,r.shape)[0],l=Zb(r,i,o),c=r.shape.length,d=new Array(c).fill(0),f=r.shape.slice();return l.map(p=>{const g=[...f];g[o]=p;const x=wd({inputs:{x:r},backend:t,attrs:{begin:d,size:g}});return d[o]+=p,x})}const a0e={kernelName:im,backendName:"webgl",kernelFunc:i0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gE="return sqrt(x);",o0e=Ft({opSnippet:gE,packedOpSnippet:gE,cpuKernelImpl:Fhe}),l0e={kernelName:Zh,backendName:"webgl",kernelFunc:o0e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u0e="return x * x;",c0e=Ft({opSnippet:u0e}),h0e={kernelName:Jx,backendName:"webgl",kernelFunc:c0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yE="return (a - b) * (a - b);",d0e=$s({opSnippet:yE,packedOpSnippet:yE}),f0e={kernelName:Jh,backendName:"webgl",kernelFunc:d0e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),a=Pi(i),o=zhe(a,"string",s);return t.makeTensorInfo(r.shape,"string",o)}const m0e={kernelName:eb,backendName:"webgl",kernelFunc:p0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0e({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=wi+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new la(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const y0e={kernelName:rd,backendName:"webgl",kernelFunc:g0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x0e{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=Qt(s.length),a=Qt(s.length);let o="";if(r===1)o="coords * strides + begin";else{let l=0;o=s.map((c,d)=>(l++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${l-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=s,{finalShapeSparse:g,finalShape:x,isIdentity:b,sliceDim0:v,isSimpleSlice:w,begin:$,end:I,strides:N}=Fb(r.shape,i,a,o,l,c,d,f,p);let E;if(b)E=ze({inputs:{x:r},backend:t,attrs:{shape:x}});else if(v||w){B(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const O=Ob($,I,N),L=wd({inputs:{x:r},backend:t,attrs:{begin:$,size:O}});E=ze({inputs:{x:L},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(L)}else if(t.shouldExecuteOnCPU([r])){const L=t.readSync(r.dataId),z=ft(r.shape,r.dtype,L),P=Lhe(g,z,N,$);E=t.makeTensorInfo(x,r.dtype,P.values)}else{const L=new x0e($,N,g);E=t.runWebGLProgram(L,[r],r.dtype)}const D=ze({inputs:{x:E},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(E),D}const v0e={kernelName:tb,backendName:"webgl",kernelFunc:b0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0e(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:d,dataSplits:f}=e,p=t.readSync(d.dataId),g=t.readSync(f.dataId),[x,b]=Phe(p,g,r,i,a,o,l,c);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(f.shape,"int32",b)]}const S0e={kernelName:nb,backendName:"webgl",kernelFunc:w0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0e(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.readSync(i.dataId),l=t.readSync(a.dataId)[0],[c,d,f]=Mhe(o,l,r),p=d.length;return[t.makeTensorInfo([p,2],"int32",c),t.makeTensorInfo([p],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const $0e={kernelName:N2,backendName:"webgl",kernelFunc:C0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0e(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(i.dataId),o=Bhe(a,r);return t.makeTensorInfo(i.shape,"int32",o)}const N0e={kernelName:I2,backendName:"webgl",kernelFunc:k0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I0e="return tan(x);",T0e=Ft({opSnippet:I0e}),E0e={kernelName:td,backendName:"webgl",kernelFunc:T0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R0e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,A0e=Ft({opSnippet:R0e}),D0e={kernelName:nd,backendName:"webgl",kernelFunc:A0e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0e(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:a}=e,{sliceRank:o,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=va(a,i,r.shape),p=[f/c,c];if(f===0)return t.makeTensorInfo(r.shape,i.dtype);const g=ze({inputs:{x:i},backend:t,attrs:{shape:[l,o]}}),x=ze({inputs:{x:a},backend:t,attrs:{shape:[l,c]}}),b=ze({inputs:{x:r},backend:t,attrs:{shape:p}}),v=new mC(l,o,g.shape.length,x.shape.length,d,p,!1,!0),w=t.runWebGLProgram(v,[x,g,b],b.dtype),$=ze({inputs:{x:w},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(w),$}const O0e={kernelName:Xx,backendName:"webgl",kernelFunc:_0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F0e{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const r=Qt(this.rank),i=z0e(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function z0e(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),c=r.dtype==="string"?l.map(p=>Oi(p)):l,d=ft(r.shape,r.dtype,c),f=Uhe(d,i);return t.makeTensorInfo(f.shape,f.dtype,f.values)}const a=new F0e(r.shape,i);return t.runWebGLProgram(a,[r],r.dtype)}const L0e={kernelName:sd,backendName:"webgl",kernelFunc:hz};class P0e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class M0e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vl(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function xE(n){let e=1;for(;e<n;)e*=2;return e}function B0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s,o=fe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=fe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,d=c[c.length-1];if(t.shouldExecuteOnCPU([r])||d<o||i>l){const P=t.readSync(r.dataId),[_,H]=Whe(P,c,r.dtype,i,a);return[t.makeTensorInfo(_.shape,_.dtype,_.values),t.makeTensorInfo(H.shape,H.dtype,H.values)]}if(i===0)return c[c.length-1]=0,[t.makeTensorInfo(c,r.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(d===1)return[r,Om({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const f=t.texData.get(r.dataId),p=f!==null&&f.isPacked,g=p?t.unpackTensor(r):r,b=ue(c)/d,v=ze({inputs:{x:g},attrs:{shape:[b,d]},backend:t});p&&Vl(t,g);const w=xE(i),$=xE(d);let I=null;const N=()=>I===null?[v,v]:[v,I],E=(P,_,H)=>{const q=N(),ee=new P0e(H),G=[[d],[I===null?1:0],[Number.NEGATIVE_INFINITY],[P],[_]],te=I;I=t.runWebGLProgram(ee,q,"int32",G),Vl(t,te)};for(let P=1;P<w;P*=2){const _=P*2;for(let H=P;H>=1;H/=2)E(_,H,[b,$])}for(let P=$;P>w;P/=2){const _=N(),H=new M0e([b,P/2]),ee=[[d],[I===null?1:0],[w]],Y=I;I=t.runWebGLProgram(H,_,"int32",ee),Vl(t,Y);const G=w/2,te=G*2;for(let re=G;re>=1;re/=2)E(te,re,I.shape)}let D=I;I=wd({inputs:{x:I},backend:t,attrs:{begin:0,size:[b,i]}}),Vl(t,D);let O=sz({inputs:{x:v,indices:I},backend:t,attrs:{axis:1,batchDims:1}});Vl(t,v);const L=c.slice(0,-1);L.push(i),D=I,I=ze({inputs:{x:I},attrs:{shape:L},backend:t}),Vl(t,D);const z=O;return O=ze({inputs:{x:O},attrs:{shape:L},backend:t}),Vl(t,z),[O,I]}const V0e={kernelName:sb,backendName:"webgl",kernelFunc:B0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U0e{constructor(e,t,s,r,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=s,[d,f,p,g]=r.shape,[x,b]=c??[f,p],v=[d,x,b,g],w=new U0e(f,p,a,o,l,v);return t.runWebGLProgram(w,[r,i],"float32")}const G0e={kernelName:rb,backendName:"webgl",kernelFunc:W0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0e(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Am(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:l,indices:c}=Ghe(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const j0e={kernelName:T2,backendName:"webgl",kernelFunc:H0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,l=r.shape[i],c=new Array(o-1);let d=0;for(let b=0;b<o;b++)b!==i&&(c[d++]=a.shape[b]);const f=[],p=new Array(o).fill(0),g=a.shape.slice();g[i]=1;const x=new Array(l);for(let b=0;b<x.length;b++){p[i]=b;const v=wd({inputs:{x:a},backend:t,attrs:{begin:p,size:g}}),w=ze({inputs:{x:v},backend:t,attrs:{shape:c}});x[b]=w,f.push(v)}return f.forEach(b=>t.disposeIntermediateTensorInfo(b)),x}const X0e={kernelName:om,backendName:"webgl",kernelFunc:q0e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K0e{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,a=e.numSegments,o=a*Math.ceil(i/s);this.outputShape=[r,o];const l="0.0",c="sumValue",d=Math.floor(s/4)*4,f=s%4,p=`
        sumValue += dot(values, segFilter);
    `;let g="";i%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let x="";i%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${x}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s,o=r.shape.length,l=[];let c=0;const d=Zt([c],o);let f=r;d!=null&&(f=qs({inputs:{x:r},backend:t,attrs:{perm:d}}),l.push(f),c=cn(1,o)[0]);const p=CS(f.shape,c,a),g=ue([f.shape[c]]),x=ze({inputs:{x:f},backend:t,attrs:{shape:[-1,g]}});l.push(x);const b=ob(r.dtype),v=(N,E,D,O,L)=>{const z=N.shape[0],P=N.shape[1],_=YA(P,L),H={windowSize:_,inSize:P,batchSize:z,numSegments:L},q=new K0e(H,E),ee=t.compileAndRun(q,[N,D],O);if(l.push(ee),ee.shape[1]===L)return ee;const Y=cz({backend:t,attrs:{start:0,stop:L,step:1,dtype:"float32"}}),G=hz({inputs:{x:Y},backend:t,attrs:{reps:[P/_]}});return l.push(Y),l.push(G),v(ee,E,G,O,L)},w=v(x,"unsortedSegmentSum",i,b,a),$=ze({inputs:{x:w},backend:t,attrs:{shape:p}});let I=$;if(d!=null){l.push($);const N=xa(d);I=qs({inputs:{x:I},backend:t,attrs:{perm:N}})}return l.forEach(N=>t.disposeIntermediateTensorInfo(N)),I}const Q0e={kernelName:lm,backendName:"webgl",kernelFunc:Y0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z0e=[Fde,Lde,Bde,Wde,Hde,Xde,Yde,Zde,nfe,rfe,ofe,cfe,ffe,yfe,vfe,Sfe,$fe,Tfe,Rfe,Dfe,zfe,Wfe,Hfe,Kfe,Qfe,spe,ipe,upe,xde,dpe,ype,wpe,Ipe,Rpe,Dpe,Ope,zpe,Bpe,Wpe,jpe,Xpe,Ype,Zpe,tme,sme,ome,ume,dme,mme,yme,wme,kme,Eme,Dme,Fme,zme,Pme,Bme,Ume,Gme,jme,Yme,Jme,nge,rge,oge,cge,pge,xge,yde,vge,mpe,Cge,Nge,Ege,vde,_ge,Lge,Mge,Wge,jge,Yge,Jge,sye,oye,cye,dye,gye,xye,vye,$ye,Nye,Tye,Rye,Dye,zye,Bye,Gye,Zye,Cde,nxe,ixe,lxe,hxe,Jfe,pxe,gxe,xxe,wxe,kxe,Sde,Ixe,Exe,Axe,_xe,Oxe,epe,Xye,Lxe,Vxe,Hxe,kde,Kxe,Zxe,nbe,ibe,ube,hbe,pbe,ybe,vbe,Cbe,Nbe,Ebe,_be,zbe,Bbe,Wbe,Vfe,Yye,jbe,Xbe,Ybe,Zbe,e0e,n0e,r0e,a0e,l0e,h0e,f0e,m0e,y0e,v0e,S0e,$0e,N0e,Kye,Dde,E0e,D0e,O0e,L0e,V0e,G0e,_de,j0e,X0e,Q0e,mxe];for(const n of Z0e)E2(n);const J0e=(n,e)=>{Gl.useEffect(()=>{(async()=>{await BP("webgl"),await VP();const s=await qJ(ca.MoveNet,{modelType:XJ.modelType.SINGLEPOSE_LIGHTNING}),r=async()=>{if(n.current?.video.readyState===4){const i=await s.estimatePoses(n.current.video);i.length>0&&e(i[0].keypoints)}requestAnimationFrame(r)};r()})()},[n,e])},Vc=(n,e,t)=>{const s={x:n.x-e.x,y:n.y-e.y},r={x:t.x-e.x,y:t.y-e.y},i=s.x*r.x+s.y*r.y,a=Math.hypot(s.x,s.y),o=Math.hypot(r.x,r.y);return Math.acos(i/(a*o))*180/Math.PI||180},e1e=(n,e)=>{n.clearRect(0,0,640,480),n.fillStyle="red",n.strokeStyle="lime",n.lineWidth=2,e.forEach(d=>{d.score>.5&&(n.beginPath(),n.arc(d.x,d.y,5,0,2*Math.PI),n.fill())});const t=[["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["left_shoulder","right_shoulder"],["left_shoulder","left_hip"],["right_shoulder","right_hip"],["left_hip","right_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["right_hip","right_knee"],["right_knee","right_ankle"]],s=Object.fromEntries(e.map(d=>[d.name,d]));t.forEach(([d,f])=>{const p=s[d],g=s[f];p?.score>.5&&g?.score>.5&&(n.beginPath(),n.moveTo(p.x,p.y),n.lineTo(g.x,g.y),n.stroke())});const r=s.left_hip,i=s.left_knee,a=s.left_ankle;if(r&&i&&a&&r.score>.5&&i.score>.5&&a.score>.5){n.strokeStyle="orange",n.beginPath(),n.moveTo(i.x,i.y),n.lineTo(r.x,r.y),n.stroke(),n.beginPath(),n.moveTo(i.x,i.y),n.lineTo(a.x,a.y),n.stroke();const d=Vc(r,i,a).toFixed(1);n.fillStyle="black",n.font="18px Arial",n.fillStyle=d<90?"red":"green",n.save(),n.scale(-1,1),n.fillText(`Ángulo: ${d}°`,-i.x-10,i.y-10),n.restore()}const o=s.right_hip,l=s.right_knee,c=s.right_ankle;if(o&&l&&c&&o.score>.5&&l.score>.5&&c.score>.5){n.strokeStyle="orange",n.beginPath(),n.moveTo(l.x,l.y),n.lineTo(o.x,o.y),n.stroke(),n.beginPath(),n.moveTo(l.x,l.y),n.lineTo(c.x,c.y),n.stroke();const d=Vc(o,l,c).toFixed(1);n.fillStyle="black",n.font="18px Arial",n.fillStyle=d<90?"red":"green",n.save(),n.scale(-1,1),n.fillText(`Ángulo: ${d}°`,-l.x-10,l.y-10),n.restore()}n.restore()},t1e=(n,e,t,s)=>{const r=n.find(g=>g.name==="left_hip"),i=n.find(g=>g.name==="left_knee"),a=n.find(g=>g.name==="left_ankle"),o=n.find(g=>g.name==="right_hip"),l=n.find(g=>g.name==="right_knee"),c=n.find(g=>g.name==="right_ankle"),d=r.score>.5&&i.score>.5&&a.score>.5,f=o.score>.5&&l.score>.5&&c.score>.5;let p;if(d&&f)p=(Vc(r,i,a)+Vc(o,l,c))/2;else if(d)p=Vc(r,i,a);else if(f)p=Vc(o,l,c);else return;p<90&&e.current==="up"&&t("down"),p>160&&e.current==="down"&&(t("up"),s(g=>g+1))};function n1e(){const n=Gl.useRef(null),e=Gl.useRef(null),[t,s]=Gl.useState(0),[r,i]=Gl.useState("up"),a=Gl.useRef("up"),o=l=>{a.current=l,i(l)};return J0e(n,l=>{const c=e.current.getContext("2d");c.save(),c.scale(-1,1),c.translate(-640,0),e1e(c,l),c.restore(),t1e(l,a,o,s)}),Ga.jsxs("div",{className:"app-container",children:[Ga.jsxs("div",{className:"reps-counter",children:["Repeticiones: ",Ga.jsx("span",{children:t})]}),Ga.jsx(XL,{webcamRef:n,canvasRef:e})]})}WL.createRoot(document.getElementById("root")).render(Ga.jsx(Gl.StrictMode,{children:Ga.jsx(n1e,{})}));
